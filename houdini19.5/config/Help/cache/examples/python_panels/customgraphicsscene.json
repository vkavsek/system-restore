{"type": "root", "attrs": {}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Custom Graphics"], "extent": [0, 20]}, {"type": "summary", "indent": 0, "text": ["Custom OpenGL drawing in a Python Panel."], "extent": [20, 69]}, {"type": "pre", "text": ["<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<pythonPanelDocument>\n  <!-- This file contains definitions of Python interfaces and the\n interfaces menu.  It should not be hand-edited when it is being\n used by the application.  Note, that two definitions of the\n same interface or of the interfaces menu are not allowed\n in a single file. -->\n  <interface name=\"CustomGraphicSceneExample\" label=\"Graphics Scene Example\" icon=\"SOP_torus\">\n    <script><![CDATA[import math\nfrom hutil.Qt import QtCore, QtWidgets\n\npy_gl_found = True\n\ntry:\n    from OpenGL.GL import *\n    from OpenGL.GL import shaders\n    from OpenGL.arrays import *\nexcept ImportError:\n    py_gl_found = False\n    QtWidgets.QMessageBox.critical(None, \"Custom Graphics Scene Example\",\n                            \"PyOpenGL must be installed to run this example.\",\n                            QtWidgets.QMessageBox.Ok | QtWidgets.QMessageBox.Default,\n                            QtWidgets.QMessageBox.NoButton)\ndef float_array(py_array):\n    floats = GLfloatArray.zeros(len(py_array))\n    for x in xrange(0, len(py_array)):\n        floats[x] = py_array[x]\n                        \n    return floats\n\nlabel_style = \"background: rgba(0,0,0,0); color: #FFFFFF; font-size: 14px\"\nlight_label_style = \"background: rgba(0,0,0,0); color: #CCCCCC; font-size: 12px\"\n\ndesc_text = \"\"\"This example uses a custom graphics scene to combine QWidgets with \\\nOpenGL rendering.\nUse the left mouse button to pan and the mouse wheel to zoom.\"\"\"\n\nbox_verts = [-1, 1, -1, 1, 1, 1, 1, 1, -1, -1,  1, -1, -1, 1, 1, 1, 1, 1,\n             -1, 1, -1, 1, 1, -1, -1, -1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1,\n             -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, 1, 1, -1, -1, -1,-1, -1, 1,\n             -1, 1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1,\n              1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1,\n             -1, -1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1,\n            ]\n            \nclass CustomScene(QtWidgets.QGraphicsScene):\n    def __init__(self):\n        \"\"\"Initializes the custom graphics scene. Sets up labels and default\n           values for rotation and zoom factors.\"\"\"\n           \n        QtWidgets.QGraphicsScene.__init__(self)\n        self.xRot = 35.0\n        self.yRot = 25.0\n        self.lastPos = None\n        self.zoom = 1.0\n        \n        self.rotationLabel = QtWidgets.QLabel(\"Rotation:  [35.0, 25.0]\")\n        self.rotationLabel.move(10, 10)\n        self.rotationLabel.setFixedWidth(200)\n        self.rotationLabel.setStyleSheet(label_style)\n        \n        self.zoomLabel = QtWidgets.QLabel(\"Zoom factor:  [1.0]\")\n        self.zoomLabel.move(10, 30)\n        self.zoomLabel.setFixedWidth(200)\n        self.zoomLabel.setStyleSheet(label_style)\n        \n        self.descLabel = QtWidgets.QLabel(desc_text) \n        self.descLabel.move(10, 200)\n        self.descLabel.setStyleSheet(light_label_style)\n        self.descLabel.setFixedWidth(self.width())\n        self.descLabel.setAlignment(QtCore.Qt.AlignHCenter | QtCore.Qt.AlignBottom)\n       \n        self.resetButton = QtWidgets.QPushButton(\"Reset Orientation\")\n        self.resetButton.move(10, 70)\n        self.resetButton.clicked.connect(self.reset)\n        \n        self.addWidget(self.rotationLabel)\n        self.addWidget(self.zoomLabel)\n        self.addWidget(self.descLabel)\n        self.addWidget(self.resetButton)\n        \n        self.glInit = False\n        self.shader = None\n        \n    def reset(self):\n        self.xRot = 35.0\n        self.yRot = 25.0\n        self.zoom = 1.0\n        self.rotationLabel.setText(\"Rotation:  [35.0, 25.0]\")        \n        self.zoomLabel.setText(\"Zoom factor:  [1.0]\")\n        self.update()\n        \n    def wheelEvent(self, event):\n        \"\"\"Called when the mouse wheel is rotated. Increases or decreases\n           the zoom factor based on the mouse wheel.\"\"\"\n           \n        QtWidgets.QGraphicsScene.wheelEvent(self, event)\n        \n        if event.isAccepted():\n            return\n            \n        self.zoom -= event.delta() / 2000.0\n        if self.zoom < 0.1:\n            self.zoom = 0.1\n            \n        self.zoomLabel.setText(\"Zoom factor:  [\" + str(self.zoom) + \"]\")\n        self.update()\n        \n    def mousePressEvent(self, event):\n        \"\"\" Called when a mouse button is pressed. Stores the mouse pos.\"\"\"\n        \n        QtWidgets.QGraphicsScene.mousePressEvent(self, event)\n        \n        if event.buttons() == QtCore.Qt.LeftButton:\n            self.lastPos = event.scenePos()\n        \n    def mouseMoveEvent(self, event):\n        \"\"\"Called when the mouse moves. Rotates the viewport\"\"\"\n        \n        QtWidgets.QGraphicsScene.mouseMoveEvent(self, event)\n        \n        if event.isAccepted():\n            return\n            \n        if event.buttons() == QtCore.Qt.LeftButton:\n            pos = event.scenePos()\n            if self.lastPos is None:\n                self.lastPos = pos\n            else:\n                deltaX = pos.x() - self.lastPos.x()\n                deltaY = pos.y() - self.lastPos.y()\n                self.lastPos = pos\n                \n                self.yRot += deltaX\n                self.xRot += deltaY\n                \n                if self.xRot > 90:\n                    self.xRot = 90\n                elif self.xRot < -90:\n                    self.xRot = -90\n                    \n                if self.yRot > 180:\n                    self.yRot -= 360\n                elif self.yRot < -180:\n                    self.yRot += 360\n                    \n                self.rotationLabel.setText(\"Rotation:  [\" + str(self.xRot) +\n                                           \", \" + str(self.yRot) + \"]\")\n                self.update()\n                \n    def initGL(self):\n        \"\"\" Initializes OpenGL resources if they have not already been created\"\"\"\n        if self.glInit:\n            return\n            \n        self.glInit = True\n\n        verts = float_array(box_verts)\n        \n        self.vbo = glGenBuffers(1)\n        glBindBuffer(GL_ARRAY_BUFFER, self.vbo)\n        glBufferData(GL_ARRAY_BUFFER, 432, verts, GL_STATIC_DRAW)\n        glBindBuffer(GL_ARRAY_BUFFER, 0)\n        \n        vertex_shader = shaders.compileShader(\"\"\"\n            #version 150\n            in vec3 v_position;\n            \n            uniform mat4 m_scale;\n            uniform mat4 m_rot;\n            uniform mat4 m_projection;\n            \n            void main()\n            {\n                mat4 mvp = m_projection * m_rot * m_scale;\n                gl_Position = mvp * vec4(v_position, 1.0);\n            }\n            \"\"\", GL_VERTEX_SHADER)\n        \n        fragment_shader = shaders.compileShader(\"\"\"\n            #version 150\n            \n            uniform float f_opacity;\n            void main()\n            {\n                gl_FragColor = vec4(0.9, 0.55, 0.3, f_opacity);\n            }\n            \"\"\", GL_FRAGMENT_SHADER)\n            \n        self.shader = shaders.compileProgram(vertex_shader, fragment_shader)\n\n        self.uniforms = {\n            'm_scale': glGetUniformLocation(self.shader, 'm_scale'),\n            'm_rot': glGetUniformLocation(self.shader, 'm_rot'),\n            'm_projection': glGetUniformLocation( self.shader, 'm_projection'),\n            'f_opacity': glGetUniformLocation( self.shader, 'f_opacity'),\n        }\n     \n    def setProjection(self):\n        \"\"\" Computes and sets the projection matrix based on view size/zoom\"\"\"\n        aspect = float(self.width())/float(self.height())\n        factor = 5 * self.zoom\n        \n        lr = 1.0 / (factor * aspect * 2.0);\n        bt = 1.0 / (factor * 2.0);\n        nf = 1.0 / (-1.0 - 100.0);\n        \n        ortho = [lr, 0,  0,         0,\n                 0,  bt, 0,         0,\n                 0,  0,  2.0 * nf,  0, \n                 0,  0,  99.0 * nf, 1]\n        p = float_array(ortho)\n                \n        glUniformMatrix4fv(self.uniforms[\"m_projection\"], 1, GL_FALSE, p)\n        \n    def drawBox(self, x_scale, y_scale, z_scale, opacity):\n        # Transform the box based on the view settings and scale        \n        ca = math.cos(0.0)\n        cb = math.cos(self.xRot/ 180.0 * 3.14159)\n        ch = math.cos(self.yRot/ 180.0 * 3.14159)\n\n        sa = math.sin(0.0)\n        sb = math.sin(self.xRot/ 180.0 * 3.14159)\n        sh = math.sin(self.yRot/ 180.0 * 3.14159)\n        \n        r = [ch*ca,  -ch*sa*cb + sh*sb,  ch*sa*sb + sh*cb,    0.0,\n             sa,     ca*cb,              -ca*sb,              0.0,\n             -sh*ca, sh*sa*cb + ch*sb,   (-sh*sa*sb + ch*cb), 0.0, \n             0.0,    0.0,                -3.0,                1.0]\n        rot = float_array(r)\n        \n        s = [x_scale, 0.0,     0.0,     0.0,\n             0.0,     y_scale, 0.0,     0.0,\n             0.0,     0.0,     z_scale, 0.0,\n             0.0,     0.0,     0.0,     1.0]\n        scale = float_array(s)\n                \n        glUniformMatrix4fv(self.uniforms[\"m_scale\"], 1, GL_FALSE, scale)\n        glUniformMatrix4fv(self.uniforms[\"m_rot\"], 1, GL_FALSE, rot)\n        \n        glUniform1fv(self.uniforms[\"f_opacity\"], 1, opacity)\n        \n        glBindBuffer(GL_ARRAY_BUFFER, self.vbo)\n        glEnableClientState(GL_VERTEX_ARRAY)\n        glVertexPointer(3, GL_FLOAT, 0, None)\n     \n        glDrawArrays(GL_TRIANGLES, 0, 36)\n        \n        glDisableClientState(GL_VERTEX_ARRAY)\n        glBindBuffer (GL_ARRAY_BUFFER, 0)\n        \n    def drawBackground(self, painter, rect):\n        \"\"\" Called when the scene should render it's background. Can use GL.\"\"\"\n        \n        QtWidgets.QGraphicsScene.drawBackground(self, painter, rect)\n        \n        # PyOpenGL is needed for this example\n        if not py_gl_found:\n            return\n            \n        # Init GL\n        self.initGL()\n        \n        # Update the label to match the size of the graphics scene\n        self.descLabel.setFixedWidth(self.width())\n        self.descLabel.setFixedHeight(self.height() - 230)\n        \n        # Clear the viewport\n        glClearColor(0.2, 0.28, 0.32, 1.0)\n        glClearDepth(1.0)\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)\n                                \n        # Enable blending and culling\n        glEnable(GL_BLEND)\n        glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA)\n        glEnable(GL_CULL_FACE)\n        \n        # Activate the shader for the box\n        shaders.glUseProgram(self.shader)\n        \n        # Set the projection matrix\n        self.setProjection()\n                        \n        # Draw the boxes\n        self.drawBox(0.50, 0.10, 0.25, 0.75)\n        self.drawBox(0.75, 0.25, 0.75, 0.45)\n        self.drawBox(1.75, 0.50, 1.75, 0.25)\n        self.drawBox(2.50, 1.50, 2.50, 0.10)\n        \n        # Unbind the shader\n        shaders.glUseProgram(0)\n        \n        # Restore the GL state\n        glDisable(GL_BLEND)\n        glDisable(GL_CULL_FACE)\n                \ndef onCreateInterface():\n    widget = CustomScene()\n    return widget\n]]></script>\n  </interface>\n</pythonPanelDocument>\n"]}], "title": ["Custom Graphics"], "summary": ["Custom OpenGL drawing in a Python Panel."], "examplefile": "/examples/python_panels/customgraphicsscene.pypanel"}