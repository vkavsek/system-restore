{"type": "root", "attrs": {}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Geometry attributes"], "extent": [0, 24]}, {"type": "summary", "indent": 0, "text": ["Describes how Houdini represents geometry using details, primitives, points, vertices, and attributes."], "extent": [24, 135]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Attributes"], "extent": [135, 152], "body": [{"type": "para", "indent": 0, "text": [{"type": "em", "text": ["Attributes"]}, " are named values stored on vertices, points, primitives, and objects. Point color, position, ", {"scheme": null, "value": "/shade/textures", "type": "link", "text": ["UV coordinates"], "fullpath": "/shade/textures"}, " , spline weight (", {"type": "code", "text": ["W"]}, "), and normal, for example, are stored as point attributes."], "extent": [152, 373]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["Houdini sets some point attributes that you can use in expressions. For example, you could set the per-point color based on the vertical position (", {"type": "code", "text": ["PY"]}, ") of the point."], "extent": [373, 543]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Certain attributes you can set manually and if they're present they will be used by Houdini. For example, the dynamics solvers and rendering engines will often use certain attributes on the geometry if they exist."], "extent": [543, 760]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You can also set your own custom attributes to be used by your node expressions, scripts, exporters, and so on."], "extent": [760, 875]}], "container": true}, {"type": "para", "indent": 0, "text": ["The surface nodes in the Attributes group of the tab menu set different types of attributes. You can also set or create arbitrary attributes using the ", {"scheme": "Node", "value": "/nodes/sop/attribute", "type": "link", "text": ["Attribute SOP"], "fullpath": "/nodes/sop/attribute"}, "."], "extent": [875, 1063]}, {"type": "para", "indent": 0, "text": ["To see the attributes on the geometry in a node, press ", {"keys": ["RMB"], "type": "keys", "text": null}, " on the node\u2019s tile in the network editor and choose ", {"type": "ui", "text": ["Spreadsheet"]}, " to open the ", {"scheme": null, "value": "/ref/panes/geosheet", "type": "link", "text": ["geometry spreadsheet"], "fullpath": "/ref/panes/geosheet"}, " for the node."], "extent": [1063, 1264]}, {"type": "para", "indent": 0, "text": [{"scheme": null, "value": "/particles", "type": "link", "text": ["Particles"], "fullpath": "/particles"}, "  also have attributes, and attributes are very important when geometry and particle systems interact. For example, particles ", {"scheme": null, "value": "/particles/emit", "type": "link", "text": ["emitted"], "fullpath": "/particles/emit"}, " from geometry inherit (by default) the attributes of the point from which they are emitted, and you can create interesting effects by transferring attributes between surfaces and particles using the ", {"scheme": "Node", "value": "/nodes/pop/attribtransfer", "type": "link", "text": ["Attribute Transfer POP"], "fullpath": "/nodes/pop/attribtransfer"}, "."], "extent": [1264, 1689]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Geometry components"], "extent": [1689, 1715], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 0, "text": [{"scheme": "Image", "value": "/images/model/geo_detail.svg", "type": "img", "text": ""}], "role": "item", "extent": [1715, 1758], "body": [{"type": "para", "indent": 4, "text": ["You can create/set attributes using the generic ", {"scheme": "Node", "value": "/nodes/sop/attribcreate", "type": "link", "text": ["Attribute Create"], "fullpath": "/nodes/sop/attribcreate"}, " surface node, or the ", {"scheme": "Node", "value": "/nodes/sop/vertex", "type": "link", "text": ["Vertex"], "fullpath": "/nodes/sop/vertex"}, ", ", {"scheme": "Node", "value": "/nodes/sop/point", "type": "link", "text": ["Point"], "fullpath": "/nodes/sop/point"}, ", ", {"scheme": "Node", "value": "/nodes/sop/primitive", "type": "link", "text": ["Primitive"], "fullpath": "/nodes/sop/primitive"}, " nodes. You can attach attributes to vertices, points, primitives (e.g. polygon faces), or the entire piece of geometry (called the ", {"type": "q", "text": ["detail"]}, " level)."], "extent": [1758, 2102]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [2102, 2112], "body": [{"type": "para", "indent": 8, "text": ["When you merge two or more branches in a geometry network, if a detail attribute with the same name exists in multiple branches, Houdini uses the value in the first branch. If the attribute is a string array, Houdini merges the arrays."], "extent": [2112, 2358]}], "container": true}], "container": true, "role": "item_group"}], "container": true}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Attribute precedence"], "extent": [2358, 2385], "body": [{"type": "para", "indent": 0, "text": ["When two components in the same geometry have an attribute with the same name, the attribute on the ", {"type": "q", "text": ["lower level"]}, " of geometry is used, so:"], "extent": [2385, 2526]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "strong", "text": ["Vertex"]}, " attributes, which override:"], "extent": [2526, 2566], "body": [{"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "strong", "text": ["Point"]}, " attributes, which override:"], "extent": [2566, 2609], "body": [{"type": "bullet_group", "body": [{"blevel": 10, "type": "bullet", "indent": 8, "text": [{"type": "strong", "text": ["Primitive"]}, " attributes, which override:"], "extent": [2609, 2660], "body": [{"type": "bullet_group", "body": [{"blevel": 14, "type": "bullet", "indent": 12, "text": [{"type": "strong", "text": ["Detail"]}, " (whole geometry) attributes"], "extent": [2660, 2713]}], "container": true}], "container": true}], "container": true}], "container": true}], "container": true}], "container": true}], "container": true}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Applying nodes based on attribute values"], "extent": [2713, 2760], "body": [{"type": "para", "indent": 0, "text": ["Most surface nodes have a ", {"type": "ui", "text": ["Group"]}, " field that lets you enter a named group or a pattern to select which components the node should apply to. This field recognizes special syntax that lets you select components by the value of an attribute. For example, in a ", {"scheme": "Node", "value": "/nodes/sop/point", "type": "link", "text": ["Point node"], "fullpath": "/nodes/sop/point"}, "'s ", {"type": "ui", "text": ["Group"]}, " field, ", {"type": "code", "text": ["@foo>5"]}, " selects all points whose ", {"type": "code", "text": ["foo"]}, " attribute is greater than ", {"type": "code", "text": ["5"]}, "."], "extent": [2760, 3139]}, {"type": "para", "indent": 0, "text": ["See the section on ", {"scheme": null, "value": "groups#manual", "type": "link", "text": ["manually specifying groups"], "fullpath": "/model/groups#manual", "fragment": "#manual"}, " for more information."], "extent": [3139, 3225]}]}, {"level": 2, "id": "dict", "container": true, "type": "h", "indent": 0, "text": ["Dictionary attributes"], "extent": [3225, 3260], "body": [{"type": "para", "indent": 0, "text": ["Since Houdini 18.5, SOP geometry supports dictionary attributes, an attribute type where each element (point, vertex, primitive/face, or the whole geometry/detail) can store a set of key/value pairs."], "extent": [3260, 3462]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["You could use a dictionary attribute to store complex ", {"type": "q", "text": ["blind"]}, " element data, such as game engine data, or data for a foreign geometry format that Houdini does not support natively."], "extent": [3462, 3645]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You could store metadata about geometry in a dictionary attribute on the detail."], "extent": [3645, 3729]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You could store the parameter values of the node that created different elements, for debugging. You could even store a node network as geometry by representing nodes with points and wires and parameters in a dictionary point attribute. See the ", {"scheme": "Node", "value": "/nodes/sop/attribfromparm", "type": "link", "text": ["Attribute From Parms SOP"], "fullpath": "/nodes/sop/attribfromparm"}, "."], "extent": [3729, 4029]}], "container": true}, {"type": "para", "indent": 0, "text": ["(You can also create a ", {"type": "em", "text": ["dictionary array"]}, " attribute, where the attribute value is an ", {"type": "em", "text": ["array"]}, " of dictionaries, rather than a single dictionary.)"], "extent": [4029, 4174]}, {"type": "para", "indent": 0, "text": ["Dictionary keys are strings. Dictionary values can be string, number, an array, or a (nested) dictionary. ", {"type": "strong", "text": ["Dictionary attributes essentially have the same data model as JSON"]}, ". In fact, UI such as the geometry spreadsheet displays the contents of a dictionary attribute like a JSON-encoded string."], "extent": [4174, 4472]}, {"type": "para", "indent": 0, "text": ["Currently, support for dictionary attributes is mostly in Python, VEX, VOPs. You can manipulate dictionary attributes on geometry using VEX snippets in an ", {"scheme": "Node", "value": "/nodes/sop/attribwrangle", "type": "link", "text": ["Attribute Wrangle"], "fullpath": "/nodes/sop/attribwrangle"}, ", or with a ", {"scheme": "Node", "value": "/nodes/sop/python", "type": "link", "text": ["Python SOP"], "fullpath": "/nodes/sop/python"}, ". There is also simple support for reading key values in parameter expressions."], "extent": [4472, 4790]}, {"type": "table", "thead": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["Language "], "role": "th", "extent": [4790, 4802], "container": true}, {"type": "cell", "indent": 4, "text": ["Support "], "role": "th", "extent": [4802, 4817]}], "divider": false}], "body": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["VEX/VOPs "], "role": "td", "extent": [4817, 4829], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["Use the ", {"scheme": null, "value": "/vex/attrib_suite", "type": "link", "text": ["standard VEX functions for reading attribute values"], "fullpath": "/vex/attrib_suite"}, " to get the entire dictionary as a VEX ", {"scheme": null, "value": "/vex/dicts", "type": "link", "text": ["dict type"], "fullpath": "/vex/dicts"}, "."], "extent": [4829, 4978]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["You can check for the existence of a key with ", {"scheme": "Vex", "value": "/vex/functions/hasdetailattrib", "type": "link", "text": "", "fallback_text": "hasdetailattrib()", "fullpath": "/vex/functions/hasdetailattrib"}, " using ", {"type": "code", "text": [{"type": "var", "text": ["attr_name"]}, ".", {"type": "var", "text": ["key"]}]}, " as the name."], "extent": [4978, 5096]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["You can bind with a dictionary attribute in a VEX snippet with ", {"type": "code", "text": ["d@foo"]}, " (or ", {"type": "code", "text": ["d[]@foo"]}, " for a dictionary array attribute)."], "extent": [5096, 5223]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["You can use ", {"type": "code", "text": ["[]"]}, " to index, however VEX has return type inference so you may need return casts to do this. (The dictionary entry is any-type, but must be resolved at compile time to a specific type.) Referring to a missing key returns a zero-value."], "extent": [5223, 5478]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["VEX/VOPs has functions for manipulating dictionaries, and several functions for working with arrays also work with ", {"type": "code", "text": ["dict"]}, " objects. For example, ", {"scheme": "Vex", "value": "/vex/functions/len", "type": "link", "text": "", "fallback_text": "len()", "fullpath": "/vex/functions/len"}, " on a ", {"type": "code", "text": ["dict"]}, " returns the number of items in the dictionary, and ", {"scheme": "Vex", "value": "/vex/functions/isvalidindex", "type": "link", "text": "", "fallback_text": "isvalidindex()", "fullpath": "/vex/functions/isvalidindex"}, " tells if a key is present in the dictionary."], "extent": [5478, 5766]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["The ", {"scheme": "Vex", "value": "/vex/functions/keys", "type": "link", "text": "", "fallback_text": "keys()", "fullpath": "/vex/functions/keys"}, " returns the dictionary keys as an array of strings. (It is not possible to have an equivalent function for values since arrays must be single type in VEX)."], "extent": [5766, 5944]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["The ", {"scheme": "Vex", "value": "/vex/functions/set", "type": "link", "text": "", "fallback_text": "set()", "fullpath": "/vex/functions/set"}, " function lets you build up a dictionary from alternating key and value arguments:"], "extent": [5944, 6047], "body": [{"type": "para", "indent": 8, "text": [{"type": "code", "text": ["dict foo = set( 'key1', 3.2, 'key2', 'stringvalue');"]}], "extent": [6047, 6111]}], "container": true}], "container": true}, {"type": "para", "indent": 4, "text": ["See the documentation for the ", {"scheme": null, "value": "/vex/dicts", "type": "link", "text": ["VEX dict type"], "fullpath": "/vex/dicts"}, " for more information on working with ", {"type": "code", "text": ["dict"]}, " types in VEX."], "extent": [6111, 6231]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["Python "], "role": "td", "extent": [6231, 6240], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["Use the standard ", {"scheme": "Hom", "value": "/hom/hou/Geometry", "type": "link", "text": "", "fallback_text": "hou.Geometry", "fullpath": "/hom/hou/Geometry"}, " methods (for example, ", {"scheme": "Hom", "value": "/hom/hou/Geometry#attribValue", "type": "link", "text": "", "fallback_text": "hou.Geometry.attribValue", "fullpath": "/hom/hou/Geometry#attribValue", "fragment": "#attribValue"}, " for detail attributes) to read a dictionary attribute. This will return the entire dictionary as a Python ", {"type": "code", "text": ["dict"]}, " containing Python types (", {"type": "code", "text": ["int"]}, ", ", {"type": "code", "text": ["float"]}, ", ", {"type": "code", "text": ["str"]}, ", ", {"type": "code", "text": ["list"]}, ", ", {"type": "code", "text": ["dict"]}, ")."], "extent": [6240, 6514]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["Since the attribute methods return a pure Python structure, once you read the attribute value you can use regular Python to manipulate the data. For example, ", {"type": "code", "text": ["len()"]}, " to get the number of items in the dictionary, ", {"type": "code", "text": ["dict[\"", {"type": "var", "text": ["key"]}, "\"]"]}, " to get the value associated with a key, and so on."], "extent": [6514, 6802]}], "container": true}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["Expressions "], "role": "td", "extent": [6802, 6816], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["You can read the value of a dictionary key in an expression with the standard functions reading attribute values (", {"scheme": "Exp", "value": "/expressions/detail", "type": "link", "text": "", "fallback_text": "detail()", "fullpath": "/expressions/detail"}, ", ", {"scheme": "Exp", "value": "/expressions/point", "type": "link", "text": "", "fallback_text": "point()", "fullpath": "/expressions/point"}, ", ", {"scheme": "Exp", "value": "/expressions/vertex", "type": "link", "text": "", "fallback_text": "vertex()", "fullpath": "/expressions/vertex"}, ", ", {"scheme": "Exp", "value": "/expressions/prim", "type": "link", "text": "", "fallback_text": "prim()", "fullpath": "/expressions/prim"}, "), using ", {"type": "code", "text": [{"type": "var", "text": ["attr_name"]}, ".", {"type": "var", "text": ["key"]}]}, " as the name."], "extent": [6816, 7034]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["If you use the string attribute functions (", {"scheme": "Exp", "value": "/expressions/details", "type": "link", "text": "", "fallback_text": "details()", "fullpath": "/expressions/details"}, ", ", {"scheme": "Exp", "value": "/expressions/points", "type": "link", "text": "", "fallback_text": "points()", "fullpath": "/expressions/points"}, ", ", {"scheme": "Exp", "value": "/expressions/vertexs", "type": "link", "text": "", "fallback_text": "vertexs()", "fullpath": "/expressions/vertexs"}, ", ", {"scheme": "Exp", "value": "/expressions/prims", "type": "link", "text": "", "fallback_text": "prims()", "fullpath": "/expressions/prims"}, ") to read the whole attribute value, it will return a JSON-encoded string. However, there are no JSON-parsing expression functions, and limited string manipulation functions, to deal with such a string in an expression."], "extent": [7034, 7359]}], "container": true}]}], "divider": false}]}, {"type": "tip_group", "body": [{"type": "tip", "indent": 0, "role": "item", "extent": [7359, 7364], "body": [{"type": "para", "indent": 4, "text": ["The ", {"scheme": "Node", "value": "/nodes/sop/attribcreate", "type": "link", "text": ["Attribute Create node"], "fullpath": "/nodes/sop/attribcreate"}, " only creates an empty dictionary attribute. The best way currently to actually set dictionary values in a geometry network is with a ", {"scheme": "Node", "value": "/nodes/sop/python", "type": "link", "text": ["Python SOP"], "fullpath": "/nodes/sop/python"}, " or ", {"scheme": "Node", "value": "/nodes/sop/attribwrangle", "type": "link", "text": ["Attribute Wrangle"], "fullpath": "/nodes/sop/attribwrangle"}, "."], "extent": [7364, 7629]}], "container": true}], "container": true, "role": "item_group"}]}, {"level": 2, "id": "intrinsic", "container": true, "type": "h", "indent": 0, "text": ["Intrinsic attributes"], "extent": [7629, 7668], "body": [{"type": "para", "indent": 0, "text": [{"type": "em", "text": ["Intrinsic attributes"]}, " are ", {"type": "em", "text": ["computed values"]}, " derived from the geometry that you can access as if they were attributes. For example:"], "extent": [7668, 7802]}, {"type": "box_group", "body": [{"ext": null, "type": "box", "indent": 0, "text": [" Examples of intrinsic attributes"], "role": "item", "extent": [7802, 7841], "body": [{"type": "table", "thead": [], "body": [{"type": "row", "body": [{"type": "cell", "indent": 4, "text": ["Detail "], "role": "td", "extent": [7841, 7854], "container": true}, {"type": "cell", "indent": 8, "text": [{"type": "code", "text": ["intrinsic:pointcount"]}, " "], "role": "td", "extent": [7854, 7887], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Number of points in the geometry"], "extent": [7887, 7933]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 4, "text": ["Detail/primitive "], "role": "td", "extent": [7933, 7956], "container": true}, {"type": "cell", "indent": 8, "text": [{"type": "code", "text": ["intrinsic:bounds"]}, " "], "role": "td", "extent": [7956, 7985], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Bounding box of the geometry"], "extent": [7985, 8027]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 4, "text": ["Primitive "], "role": "td", "extent": [8027, 8043], "container": true}, {"type": "cell", "indent": 8, "text": [{"type": "code", "text": ["intrinsic:measuredarea"]}, " "], "role": "td", "extent": [8043, 8078], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Surface area of the geometry."], "extent": [8078, 8121]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 4, "text": ["Primitive "], "role": "td", "extent": [8121, 8137], "container": true}, {"type": "cell", "indent": 8, "text": [{"type": "code", "text": ["intrinsic:memoryusage"]}, " "], "role": "td", "extent": [8137, 8171], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Amount of memory used by the primitive."], "extent": [8171, 8224]}]}], "divider": false}]}], "container": true}], "container": true, "role": "item_group"}, {"type": "task_group", "body": [{"ext": null, "type": "task", "indent": 0, "text": [" See what intrinsic attributes are available"], "role": "item", "extent": [8224, 8277], "body": [{"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["The command line utility ", {"type": "code", "text": ["ginfo -I"]}, " prints a list of all known intrinsic attributes."], "extent": [8277, 8373]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["You can show intrinsic attributes in the ", {"scheme": null, "value": "/ref/panes/geosheet", "type": "link", "text": ["geometry spreadsheet"], "fullpath": "/ref/panes/geosheet"}, ". By default they are not shown."], "extent": [8373, 8496], "body": [{"type": "para", "indent": 8, "text": ["If you are viewing geometry at a component level that has intrinsic attributes, you can use the ", {"type": "ui", "text": ["Intrinsics"]}, " menu to show all intrinsics or choose which intrinsics to show in the spreadsheet."], "extent": [8496, 8703]}], "container": true}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["The ", {"scheme": null, "value": "/basics/inspection", "type": "link", "text": ["Inspect tool"], "fullpath": "/basics/inspection"}, " can show which intrinsic attributes are available on the inspected geometry."], "extent": [8703, 8829]}], "container": true}], "container": true}, {"ext": null, "type": "task", "indent": 0, "text": [" Use intrinsic attributes"], "role": "item", "extent": [8829, 8862], "body": [{"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["In HScript expressions and VEX, use the attribute functions to read intrinsic attributes, for example:"], "extent": [8862, 8972], "body": [{"lang": "expr", "type": "pre", "indent": 8, "text": ["\n        prim(\"../volume1\", 0, \"intrinsic:bounds\", 0)\n        "], "extent": [8972, 9064]}, {"type": "para", "indent": 8, "text": ["(You can\u2019t use the ", {"type": "code", "text": ["@"]}, " attribute shortcut to read an intrinsic in VEX wrangle snippets. However, you can use ", {"scheme": "Vex", "value": "/vex/functions/primintrinsic", "type": "link", "text": "", "fallback_text": "primintrinsic()", "fullpath": "/vex/functions/primintrinsic"}, " and ", {"scheme": "Vex", "value": "/vex/functions/detailintrinsic", "type": "link", "text": "", "fallback_text": "detailintrinsic()", "fullpath": "/vex/functions/detailintrinsic"}, " to read the intrinsic directly instead of using the ", {"type": "code", "text": ["intrinsic:"]}, " prefix magic.)"], "extent": [9064, 9313]}], "container": true}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["In Python, you can access intrinsic attributes using ", {"scheme": "Hom", "value": "/hom/hou/Geometry#intrinsicNames", "type": "link", "text": "", "fallback_text": "hou.Geometry.intrinsicNames", "fullpath": "/hom/hou/Geometry#intrinsicNames", "fragment": "#intrinsicNames"}, ", ", {"scheme": "Hom", "value": "/hom/hou/Geometry#intrinsicValue", "type": "link", "text": [".intrinsicValue()"], "fullpath": "/hom/hou/Geometry#intrinsicValue", "fragment": "#intrinsicValue"}, ", and ", {"scheme": "Hom", "value": "/hom/hou/Geometry#intrinsicValueDict", "type": "link", "text": [".intrinsicValueDict()"], "fullpath": "/hom/hou/Geometry#intrinsicValueDict", "fragment": "#intrinsicValueDict"}, "."], "extent": [9313, 9526]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["In the ", {"scheme": null, "value": "groups#manual", "type": "link", "text": ["group syntax"], "fullpath": "/model/groups#manual", "fragment": "#manual"}, ", you can group based on intrinsic values. For example, ", {"type": "code", "text": ["@intrinsic:indexorder<100"]}], "extent": [9526, 9652]}], "container": true}], "container": true}], "container": true, "role": "item_group"}, {"type": "tip_group", "body": [{"type": "tip", "indent": 0, "role": "item", "extent": [9652, 9657], "body": [{"type": "para", "indent": 4, "text": ["Despite the name, some ", {"type": "q", "text": ["intrinsic"]}, " attributes can actually be written to, causing Houdini or Mantra to change some internal setting. For example, you can set the ", {"type": "code", "text": ["intrinsic:unexpandedfilename"]}, " intrinsic attribute on a packed primitive."], "extent": [9657, 9898]}], "container": true}, {"type": "tip", "indent": 0, "role": "item", "extent": [9898, 9903], "body": [{"type": "para", "indent": 4, "text": ["Bounding box intrinsic attributes, like ", {"type": "code", "text": ["intrinsic:bounds"]}, " or ", {"type": "code", "text": ["intrinsic:packedbounds"]}, " are returned in (xmin, xmax, ymin, ymax, zmin, zmax) order."], "extent": [9903, 10056]}], "container": true}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Higher and lower precision storage"], "extent": [10056, 10097], "body": [{"type": "para", "indent": 0, "text": ["You can choose the numeric precision of attributes you create with the ", {"scheme": "Node", "value": "/nodes/sop/attribcreate", "type": "link", "text": ["Attribute Create node"], "fullpath": "/nodes/sop/attribcreate"}, ", and/or convert attributes to higher precision types (at the cost of more memory) or lower precision types (to save memory) using the ", {"scheme": "Node", "value": "/nodes/sop/attribcast", "type": "link", "text": ["Attrib Cast surface node"], "fullpath": "/nodes/sop/attribcast"}, "."], "extent": [10097, 10398]}, {"type": "para", "indent": 0, "text": ["See ", {"scheme": "Node", "value": "/nodes/sop/attribcast", "type": "link", "text": ["the help for Attrib Cast"], "fullpath": "/nodes/sop/attribcast"}, " for information on the available storage types and limitations."], "extent": [10398, 10515]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Indexing and limit variables"], "extent": [10515, 10550], "body": [{"type": "para", "indent": 0, "text": ["You may see the following ", {"type": "q", "text": ["pseudo-attributes"]}, " in ", {"scheme": null, "value": "/vex/snippets", "type": "link", "text": ["VEX snippets"], "fullpath": "/vex/snippets"}, ". They represent the number of the current element being processed (for example, the point number), and the total number of elements in the geometry/list. See ", {"scheme": null, "value": "/vex/snippets#indexing", "type": "link", "text": ["indexing and limit variables in VEX snippets"], "fullpath": "/vex/snippets#indexing", "fragment": "#indexing"}, " for more information."], "extent": [10550, 10880]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["@elemnum"]}, ", ", {"type": "code", "text": ["@ptnum"]}, ", ", {"type": "code", "text": ["@primnum"]}, ", ", {"type": "code", "text": ["@vtxnum"]}], "extent": [10880, 10925], "body": [{"type": "para", "indent": 4, "text": ["Represent the number of the current element when a VEX snippet is run."], "extent": [10925, 11001]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["@numelem"]}, ", ", {"type": "code", "text": ["@numpt"]}, ", ", {"type": "code", "text": ["@numprim"]}, ", ", {"type": "code", "text": ["@numvtx"]}], "extent": [11001, 11046], "body": [{"type": "para", "indent": 4, "text": ["Represent the total number of elements in the geometry/list when a VEX snipped is run."], "extent": [11046, 11139]}], "container": true}], "container": true}]}, {"level": 1, "id": "attributes", "container": true, "type": "attributes_section", "indent": 0, "text": ["Common attributes"], "role": "section", "extent": [11139, 11169], "body": [{"type": "para", "indent": 0, "text": ["Each type of node will use certain attributes if they exist (or in some cases require them to exist), and may create/set attributes as part of their operation. See the documentation for individual nodes to see what attributes they use/set."], "extent": [11169, 11411]}, {"type": "para", "indent": 0, "text": ["The following lists a number of attributes that by convention are read/written by multiple node types."], "extent": [11411, 11516]}, {"level": 4, "type": "sep", "indent": 0, "text": [" Geometry attributes "], "extent": [11516, 11546]}, {"type": "attributes_item_group", "body": [{"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["P"]}], "extent": [11546, 11552], "body": [{"type": "para", "indent": 4, "text": ["Point position. The viewport uses this to lay out the points of the model in 3D space. You can overwrite this attribute to move the point."], "extent": [11590, 11734]}], "container": true, "attrs": {"on": "point", "type": "vector"}, "role": "item", "id": "p"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["N"]}], "extent": [11734, 11739], "body": [{"type": "para", "indent": 4, "text": ["Normal direction. You can overwrite this attribute to change the normal."], "extent": [11762, 11840]}], "container": true, "attrs": {"type": "vector"}, "role": "item", "id": "n"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["v"]}], "extent": [11840, 11845], "body": [{"type": "para", "indent": 4, "text": ["Velocity. The renderer uses this attribute to know where to add motion blur. This attribute is not computed automatically, but several nodes, especially particle DOPs, can set/use it. You can add velocity to points using the ", {"scheme": "Node", "value": "/nodes/sop/trail", "type": "link", "text": ["Trail SOP"], "fullpath": "/nodes/sop/trail"}, "."], "extent": [11868, 12126]}], "container": true, "attrs": {"type": "vector"}, "role": "item", "id": "v"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["id"]}], "extent": [12126, 12132], "body": [{"type": "para", "indent": 4, "text": ["A unique element ID. This is not the same as the element number (for example, the point number). This is an attribute you can, for example, assign to points to keep track of them even if the point numbers change (which can happen if the number of points changes). Particle DOPs often set/use this attribute."], "extent": [12152, 12465]}], "container": true, "attrs": {"type": "int"}, "role": "item", "id": "id"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["name"]}], "extent": [12465, 12473], "body": [{"type": "para", "indent": 4, "text": ["This is a value you can set on primitives, such as volumes or packed primitives, to be able to find them in code by name. Some nodes set/read this attribute."], "extent": [12496, 12663]}], "container": true, "attrs": {"type": "string"}, "role": "item", "id": "name"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["piece"]}], "extent": [12663, 12672], "body": [{"type": "para", "indent": 4, "text": ["Nodes the break up geometry into pieces will often set this attribute so you can tell which polygonal faces are part of the same piece. Faces in the same piece will share the same value in their ", {"type": "code", "text": ["piece"]}, " attribute. Other nodes may use this attribute to operate on pieces."], "extent": [12692, 12969]}], "container": true, "attrs": {"type": "int"}, "role": "item", "id": "piece"}], "container": true, "role": "item_group"}, {"level": 4, "type": "sep", "indent": 0, "text": [" Sizes and rotations "], "extent": [12969, 12999]}, {"type": "attributes_item_group", "body": [{"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["pscale"]}], "extent": [12999, 13010], "body": [{"type": "para", "indent": 4, "text": ["Uniform scaling factor. This is used in different ways in different places. For particle/point rendering, it controls the size of the particle/point (in world space units) at render time. For instancing, you can use it to uniformly scale the instanced geometry."], "extent": [13032, 13299]}], "container": true, "attrs": {"type": "float"}, "role": "item", "id": "pscale"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["scale"]}], "extent": [13299, 13308], "body": [{"type": "para", "indent": 4, "text": ["Whereas ", {"type": "code", "text": ["pscale"]}, " is a single uniform scaling factor in all axes, this attribute lets you scale non-uniformly along each axis separately. See ", {"scheme": null, "value": "#pscale", "type": "link", "text": ["the pscale attribute"], "fullpath": "/model/attributes#pscale", "fragment": "#pscale"}, " for more information."], "extent": [13331, 13530]}], "container": true, "attrs": {"type": "vector"}, "role": "item", "id": "scale"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["width"]}], "extent": [13530, 13539], "body": [{"type": "para", "indent": 4, "text": ["When rendering open curves, sets the line width (in world space units) at render time. If this attribute does not exist, Mantra renders the open curve a thin line instead of as a ribbon with thickness."], "extent": [13576, 13783]}], "container": true, "attrs": {"type": "float", "on": "point"}, "role": "item", "id": "width"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["lod"]}], "extent": [13783, 13790], "body": [{"type": "para", "indent": 4, "text": ["Level of detail. This may be used in instancing."], "extent": [13834, 13888]}], "container": true, "attrs": {"type": "float", "on": "detail, prim"}, "role": "item", "id": "lod"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["spritescale"]}], "extent": [13888, 13903], "body": [{"type": "para", "indent": 4, "text": ["When displaying particles using sprint images, this gives additional sprite scaling over ", {"type": "code", "text": ["pscale"]}, "."], "extent": [13965, 14069]}], "container": true, "attrs": {"type": "vector", "default": "(1, 1, 1)", "on": "point"}, "role": "item", "id": "spritescale"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["spriterot"]}], "extent": [14069, 14082], "body": [{"type": "para", "indent": 4, "text": ["When displaying particles using sprint images, this gives sprite rotation (around camera angle) in degrees."], "extent": [14135, 14249]}], "container": true, "attrs": {"type": "float", "default": "0", "on": "point"}, "role": "item", "id": "spriterot"}], "container": true, "role": "item_group"}, {"level": 4, "type": "sep", "indent": 0, "text": [" Viewport display attributes "], "extent": [14249, 14287]}, {"type": "attributes_item_group", "body": [{"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["gl_wireframe"]}], "extent": [14287, 14304], "body": [{"type": "para", "indent": 4, "text": ["If this detail attribute is 1, the geometry always appears as wireframe in the viewport."], "extent": [14356, 14450]}, {"type": "para", "indent": 4, "text": ["If this detail attribute is -1, the geometry always appears as shaded in\n    the viewport. For guide geometry, which are normally only drawn as\n    wireframe, this allows them to also be drawn as shaded when using any of\n    the shaded viewport modes."], "extent": [14450, 14707]}], "container": true, "attrs": {"type": "int", "default": "0", "on": "detail"}, "role": "item", "id": "gl_wireframe"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["gl_lit"]}], "extent": [14707, 14717], "body": [{"type": "para", "indent": 4, "text": ["If this detail attribute is not 0, the geometry always appears without lighting. This is currently ignored for guide geometry."], "extent": [14769, 14901]}], "container": true, "attrs": {"type": "int", "default": "0", "on": "detail"}, "role": "item", "id": "gl_lit"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["gl_showallpoints"]}], "extent": [14901, 14921], "body": [{"type": "para", "indent": 4, "text": ["If this detail attribute is not 0, all points will be rendered as sprites, even if they are connected to geometry.  Normally only unconnected points are rendered. This is currently ignored for guide geometry."], "extent": [14969, 15183]}], "container": true, "attrs": {"type": "int", "default": "0", "on": "detail"}, "role": "item", "id": "gl_showallpoints"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["gl_spherepoints"]}], "extent": [15183, 15202], "body": [{"type": "para", "indent": 4, "text": ["If this detail attribute is not 0, unconnected points will be drawn as spheres rather than as the render properties or as sprites.  The ", {"type": "code", "text": ["gl_showallpoints"]}, " can cause connected points to also draw this way."], "extent": [15250, 15460]}], "container": true, "attrs": {"type": "int", "default": "0", "on": "detail"}, "role": "item", "id": "gl_spherepoints"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["gl_xray"]}], "extent": [15460, 15471], "body": [{"type": "para", "indent": 4, "text": ["If this detail attribute is not 0, the geometry will be drawn in X-Ray mode (visible even when it is hidden behind other geometry)."], "extent": [15519, 15656]}], "container": true, "attrs": {"type": "int", "default": "0", "on": "detail"}, "role": "item", "id": "gl_xray"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["vm_cuspangle"]}], "extent": [15656, 15672], "body": [{"type": "para", "indent": 4, "text": ["Controls the cusp angle used for generating normals when the geometry doesn\u2019t have any.  180 will produce entirely smooth point normals."], "extent": [15723, 15865]}], "container": true, "attrs": {"type": "float", "default": "60", "on": "detail"}, "role": "item", "id": "vm_cuspangle"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["gl_spritetex"]}], "extent": [15865, 15881], "body": [{"type": "para", "indent": 4, "text": ["Specifies a texture for sprites. This is only valid on unconnected points, or if ", {"type": "code", "text": ["gl_showallpoints"]}, " is 1."], "extent": [15915, 16026]}], "container": true, "attrs": {"type": "string", "on": "point"}, "role": "item", "id": "gl_spritetex"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["gl_spriteblend"]}], "extent": [16026, 16044], "body": [{"type": "para", "indent": 4, "text": ["Enable blending when drawing sprites if 1. When 0, no depth sorting or blending occurs, greatly increasing draw performance of sprites. Disabling blending is good for opaque sprites, like vellum grains."], "extent": [16092, 16300]}], "container": true, "attrs": {"type": "int", "default": "1", "on": "detail"}, "role": "item", "id": "gl_spriteblend"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["gl_spritecutoff"]}], "extent": [16300, 16319], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "code", "text": ["gl_spriteblend"]}, " is 0, discard all pixels with an alpha value less than this cutoff value. 0 discards no pixels, while 1 only keeps fully opaque pixels. Values between 0.5-0.75 are generally good for opaque sprites with antialiased edges."], "extent": [16369, 16618]}], "container": true, "attrs": {"type": "float", "default": "0", "on": "detail"}, "role": "item", "id": "gl_spritecutoff"}], "container": true, "role": "item_group"}, {"level": 4, "type": "sep", "indent": 0, "text": [" Viewport volume display attributes "], "extent": [16618, 16663]}, {"type": "para", "indent": 0, "text": ["The following detail attributes control how the viewport renders volume\nprimitives. The viewport can display these primitives as fog, height fields, or\nisosurfaces (signed distance fields). To query this property, you can read the\n", {"type": "code", "text": ["volumevisualmode"]}, " primitive intrinsic attribute. The detail attributes listed\nin this section apply to fog volumes and some of them also affect viewport\ndisplay of height fields."], "extent": [16663, 17076]}, {"type": "para", "indent": 0, "text": ["A volume visualization set can have the following 4 components."], "extent": [17076, 17141]}, {"type": "table", "thead": [], "body": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["density"]}, " "], "role": "td", "extent": [17141, 17153], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["For fog, this component contains the optical thickness of the smoke. With\n    height fields, this main volume should store the elevation at each voxel."], "extent": [17153, 17310]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["cd"]}, " "], "role": "td", "extent": [17310, 17317], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["The color field. This component can be used with both fog (to color the\n    smoke) and height fields (to texture the terrain)."], "extent": [17317, 17449]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["emit"]}, " "], "role": "td", "extent": [17449, 17458], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["With fog, this component contains the intensity of emission (or internal\n    glowing). For height fields, this component acts like a visualization\n    stencil: the viewport only draws parts of the height field where the ", {"type": "code", "text": ["emit"]}, "\n    value is at least ", {"type": "code", "text": ["0.5"]}, "."], "extent": [17458, 17719]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["emitcd"]}, " "], "role": "td", "extent": [17719, 17730], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["This component can be used with fog volumes to color the internal emission."], "extent": [17730, 17811]}]}], "divider": false}]}, {"type": "para", "indent": 0, "text": ["The ", {"type": "code", "text": ["*"]}, " in attribute names in this section can be one of the above 4 strings.\nSee the help page for ", {"scheme": "Node", "value": "/nodes/sop/volumevisualization", "type": "link", "text": ["Volume Visualization SOP"], "fullpath": "/nodes/sop/volumevisualization"}, "\nfor more information; you can use this node to set or modify these attributes."], "extent": [17811, 18047]}, {"type": "attributes_item_group", "body": [{"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["volvis_*field"]}], "extent": [18047, 18064], "body": [{"type": "para", "indent": 4, "text": ["Name of the volume containing data for the respective component."], "extent": [18087, 18157]}], "container": true, "attrs": {"type": "string"}, "role": "item", "id": "volvis_-field"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["volvis_*range"]}], "extent": [18157, 18174], "body": [{"type": "para", "indent": 4, "text": ["Range of volume values that gets remapped to the 0..1 range."], "extent": [18215, 18281]}], "container": true, "attrs": {"type": "vector2", "default": "[0, 1]"}, "role": "item", "id": "volvis_-range"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["volvis_*ramp"]}], "extent": [18281, 18297], "body": [{"type": "para", "indent": 4, "text": ["This attribute should contain a string representation of the ramp that\n    remaps the respective volume values. If this is absent, no ramp is used to\n    remap the values."], "extent": [18316, 18493]}], "container": true, "attrs": {"type": "string"}, "role": "item", "id": "volvis_-ramp"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["volvis_*rampperiodic"]}], "extent": [18493, 18517], "body": [{"type": "para", "indent": 4, "text": ["This attribute flags how the ramp is applied to the remapped volume values.\n    When set to ", {"type": "code", "text": ["1"]}, ", the ramp is evaluated at the modulus of the volume\u2019s value\n    with ", {"type": "code", "text": ["1"]}, ". This can be useful to create a checkerboard or striped effect to\n    better see large ranges of values."], "extent": [18533, 18812]}], "container": true, "attrs": {"type": "int"}, "role": "item", "id": "volvis_-rampperiodic"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["volvis_maxres"]}], "extent": [18812, 18829], "body": [{"type": "para", "indent": 4, "text": ["This attribute limits the visualization resolution of volumes. When set to a\n    positive value and the volumes are high resolution, they are resampled to\n    this size before rendering."], "extent": [18862, 19054]}], "container": true, "attrs": {"type": "int", "default": "-1"}, "role": "item", "id": "volvis_maxres"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["volvis_emitscale"]}], "extent": [19054, 19074], "body": [{"type": "para", "indent": 4, "text": ["This attribute acts as a multiplier for emission intensity. Higher values\n    increase brightness of the internal glow (for example, of flames in a fire)."], "extent": [19112, 19272]}], "container": true, "attrs": {"type": "float", "default": "0"}, "role": "item", "id": "volvis_emitscale"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["volvis_shadowscale"]}], "extent": [19272, 19294], "body": [{"type": "para", "indent": 4, "text": ["Controls intensity of self-shadowing from all light sources. Larger values\n    of this attribute result in darker self-shadows."], "extent": [19328, 19461]}], "container": true, "attrs": {"type": "float", "default": "1"}, "role": "item", "id": "volvis_shadowscale"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["volvis_ambientshadows"]}], "extent": [19461, 19486], "body": [{"type": "para", "indent": 4, "text": ["Controls intensity of self-shadowing from ambient light sources. Note that\n    the default headlight is treated as an ambient source for fog volumes."], "extent": [19504, 19659]}, {"type": "para", "indent": 4, "text": ["The default value of this attribute is set by ", {"type": "ui", "text": ["Ambient Occlusion"]}, " under\n    ", {"scheme": null, "value": "/ref/windows/displayopts_3d#volumes", "type": "link", "text": ["viewport display options"], "fullpath": "/ref/windows/displayopts_3d#volumes", "fragment": "#volumes"}, "."], "extent": [19659, 19806]}], "container": true, "attrs": {"type": "float"}, "role": "item", "id": "volvis_ambientshadows"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["volvis_ambientmapsize"]}], "extent": [19806, 19831], "body": [{"type": "para", "indent": 4, "text": ["Controls size of the occlusion map texture when shading for ambient light\n    sources. Larger values (up to 1) are slower to shade, but produce higher\n    quality results."], "extent": [19867, 20044]}], "container": true, "attrs": {"type": "float", "default": "0.5"}, "role": "item", "id": "volvis_ambientmapsize"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["volvis_ambientsteprate"]}], "extent": [20044, 20070], "body": [{"type": "para", "indent": 4, "text": ["Specifies how often the density texture is sampled when calculating\n    self-shadowing from ambient light sources. Smaller values (down to 1) are\n    slower to shade, but produce higher quality results."], "extent": [20104, 20312]}], "container": true, "attrs": {"type": "float", "default": "4"}, "role": "item", "id": "volvis_ambientsteprate"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["volvis_shadowcolor"]}], "extent": [20312, 20334], "body": [{"type": "para", "indent": 4, "text": ["Controls the color of shadows cast by the smoke. The complements of these\n    values act like additional density multipliers for light of each color (red,\n    green, or blue)."], "extent": [20377, 20558]}], "container": true, "attrs": {"type": "vector", "default": "[1, 1, 1]"}, "role": "item", "id": "volvis_shadowcolor"}], "container": true, "role": "item_group"}, {"type": "para", "indent": 0, "text": ["The viewport can additionally approximate scattering of light within fog\nvolumes. This feature is experimental and may be changed or removed in future\nversions of Houdini."], "extent": [20558, 20731]}, {"type": "attributes_item_group", "body": [{"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["volvis_extinctionratio"]}], "extent": [20731, 20757], "body": [{"type": "para", "indent": 4, "text": ["Specifies what proportion of light is absorbed by the volume (as opposed to\n    being scattered out). Value of 1 signals that no scattering takes place. At\n    the other extreme, value of 0 suggests that all light that interacts with\n    the smoke is scattered."], "extent": [20791, 21058]}], "container": true, "attrs": {"type": "float", "default": "1"}, "role": "item", "id": "volvis_extinctionratio"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["volvis_scatteringiter"]}], "extent": [21058, 21083], "body": [{"type": "para", "indent": 4, "text": ["Scattering is approximated by an iterative process, and this attribute\n    stores the number of refinement iterations that are performed. Larger values\n    produce more accurate results, but also take longer to compute."], "extent": [21116, 21341]}], "container": true, "attrs": {"type": "int", "default": "25"}, "role": "item", "id": "volvis_scatteringiter"}], "container": true, "role": "item_group"}, {"type": "para", "indent": 0, "text": ["When working with fog volumes, you can force the viewport to instead draw its\nmotion vectors or normals. This behavior is also controlled through detail\nattributes."], "extent": [21341, 21507]}, {"type": "attributes_item_group", "body": [{"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["volvis_motionvec"]}], "extent": [21507, 21527], "body": [{"type": "para", "indent": 4, "text": ["The viewport will draw screen-space motion vectors for the fog when this\n    attribute is non-zero. To this end, the ", {"type": "code", "text": ["vel"]}, " vector volumes will be used to\n    read the velocities."], "extent": [21563, 21747]}], "container": true, "attrs": {"type": "int", "default": "0"}, "role": "item", "id": "volvis_motionvec"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["volvis_normals"]}], "extent": [21747, 21765], "body": [{"type": "para", "indent": 4, "text": ["The viewport will draw screen-space normals for the fog when this attribute\n    is non-zero. If both ", {"type": "code", "text": ["volvis_normals"]}, " and ", {"type": "code", "text": ["volvis_motionvec"]}, " are non-zero,\n    the viewport will draw the normals."], "extent": [21797, 21997]}], "container": true, "attrs": {"type": "int", "default": "0"}, "role": "item", "id": "volvis_normals"}], "container": true, "role": "item_group"}, {"level": 4, "type": "sep", "indent": 0, "text": [" Particle attributes "], "extent": [21997, 22027]}, {"type": "attributes_item_group", "body": [{"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["force"]}], "extent": [22027, 22037], "body": [{"type": "para", "indent": 4, "text": ["The ", {"type": "code", "text": ["force"]}, " attribute on the current point. This is set/used by some particle DOPs. It represents a change to the particle\u2019s position computed by adding up all the forces acting on the particle."], "extent": [22060, 22260]}], "container": true, "attrs": {"type": "vector"}, "role": "item", "id": "force"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["rest"]}], "extent": [22260, 22268], "body": [{"type": "para", "indent": 4, "text": ["Conventional name for an attribute containing each point\u2019s rest position, used by various nodes.\n    Some shaders can use this rather than ", {"type": "code", "text": ["P"]}, ", so procedural textures will stick even if you deform your geometry."], "extent": [22306, 22523]}], "container": true, "attrs": {"type": "vector", "on": "point"}, "role": "item", "id": "rest"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["torque"]}], "extent": [22523, 22533], "body": [{"type": "para", "indent": 4, "text": ["The ", {"type": "code", "text": ["torque"]}, " attribute on the current point. This is set/used by the ", {"scheme": "Node", "value": "/nodes/dop/poptorque", "type": "link", "text": ["Torque DOP"], "fullpath": "/nodes/dop/poptorque"}, " to spin particles."], "extent": [22556, 22681]}], "container": true, "attrs": {"type": "vector"}, "role": "item", "id": "torque"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["up"]}], "extent": [22681, 22687], "body": [{"type": "para", "indent": 4, "text": ["Represents the up vector of a particle\u2019s local space. This is used for instancing geometry onto a point. You can overwrite this attribute to change the particle\u2019s orientation."], "extent": [22710, 22891]}], "container": true, "attrs": {"type": "vector"}, "role": "item", "id": "up"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["accel"]}], "extent": [22891, 22900], "body": [{"type": "para", "indent": 4, "text": ["Obsolete, used by old POPs. The new DOP particle nodes use the ", {"type": "code", "text": ["force"]}, " attribute instead."], "extent": [22923, 23018]}], "container": true, "attrs": {"type": "vector"}, "role": "item", "id": "accel"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["backtrack"]}], "extent": [23018, 23031], "body": [{"type": "para", "indent": 4, "text": ["Obsolete. Used by old POPs to store the particle\u2019s previous position."], "extent": [23055, 23130]}], "container": true, "attrs": {"type": "vector4"}, "role": "item", "id": "backtrack"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["orient"]}], "extent": [23130, 23140], "body": [{"type": "para", "indent": 4, "text": ["Quaternion orientation of a particle. Allows fully specifying rotation, whereas ", {"type": "code", "text": ["up"]}, " only orients along a single axis. If this exists, it is used for instancing geometry onto a point."], "extent": [23164, 23353]}], "container": true, "attrs": {"type": "vector4"}, "role": "item", "id": "orient"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["rot"]}], "extent": [23353, 23360], "body": [{"type": "para", "indent": 4, "text": ["An additional offset-quaternion applied after all other attributes, used when instancing geometry onto a point."], "extent": [23384, 23501]}], "container": true, "attrs": {"type": "vector4"}, "role": "item", "id": "rot"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["nextid"]}], "extent": [23501, 23511], "body": [{"type": "para", "indent": 4, "text": ["Detail attribute storing the largest particle ID, allowing Houdini to create new particle ids efficiently."], "extent": [23531, 23643]}], "container": true, "attrs": {"type": "int"}, "role": "item", "id": "nextid"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["pstate"]}], "extent": [23643, 23653], "body": [{"type": "para", "indent": 4, "text": ["A bit field encoding different pieces of information about a particle\u2019s state (for example, whether it\u2019s alive, whether it\u2019s stopped, whether it collided in the previous frame, and so on). Various particle DOPs read and write this attribute."], "extent": [23673, 23924]}, {"type": "para", "indent": 4, "text": ["The ", {"type": "code", "text": ["pstate"]}, " value is the sum of the following flags:"], "extent": [23924, 23987]}, {"type": "table", "thead": [], "body": [{"type": "row", "body": [{"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["0x01"]}, " "], "role": "td", "extent": [23987, 24000], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Is a ", {"type": "q", "text": ["primary"]}, " particle (not birthed from an existing\n        particle)."], "extent": [24000, 24081]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["0x02"]}, " "], "role": "td", "extent": [24081, 24094], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Will die before the next frame."], "extent": [24094, 24134]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["0x04"]}, " "], "role": "td", "extent": [24134, 24147], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Stopped."], "extent": [24147, 24164]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["0x08"]}, " "], "role": "td", "extent": [24164, 24177], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Has collided."], "extent": [24177, 24199]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["0x10"]}, " "], "role": "td", "extent": [24199, 24212], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Stuck to static or moving geometry."], "extent": [24212, 24256]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["0x20"]}, " "], "role": "td", "extent": [24256, 24269], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Is associated with a rigid body dynamic simulation."], "extent": [24269, 24329]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["0x40"]}, " "], "role": "td", "extent": [24329, 24342], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Active."], "extent": [24342, 24358]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["0x80"]}, " "], "role": "td", "extent": [24358, 24371], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Motion is overridden by a CHOP."], "extent": [24371, 24413]}]}], "divider": false}]}], "container": true, "attrs": {"type": "int"}, "role": "item", "id": "pstate"}], "container": true, "role": "item_group"}, {"level": 4, "type": "sep", "indent": 0, "text": [" Shader overrides "], "extent": [24413, 24440]}, {"type": "para", "indent": 0, "text": ["Most shaders will use the override attributes to change how elements with these attributes are shaded."], "extent": [24440, 24545]}, {"type": "attributes_item_group", "body": [{"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["Cd"]}], "extent": [24545, 24551], "body": [{"type": "para", "indent": 4, "text": ["Diffuse color override. The viewport uses this to color OpenGL geometry."], "extent": [24574, 24652]}], "container": true, "attrs": {"type": "vector"}, "role": "item", "id": "cd"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["Alpha"]}], "extent": [24652, 24661], "body": [{"type": "para", "indent": 4, "text": ["Alpha transparency override. The viewport uses this to set the alpha of OpenGL geometry."], "extent": [24683, 24777]}], "container": true, "attrs": {"type": "float"}, "role": "item", "id": "alpha"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["Cs"]}], "extent": [24777, 24783], "body": [{"type": "para", "indent": 4, "text": ["Specular color override."], "extent": [24806, 24836]}], "container": true, "attrs": {"type": "vector"}, "role": "item", "id": "cs"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["Cr"]}], "extent": [24836, 24842], "body": [{"type": "para", "indent": 4, "text": ["Reflect color override."], "extent": [24865, 24894]}], "container": true, "attrs": {"type": "vector"}, "role": "item", "id": "cr"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["Ct"]}], "extent": [24894, 24900], "body": [{"type": "para", "indent": 4, "text": ["Transmit color override."], "extent": [24923, 24953]}], "container": true, "attrs": {"type": "vector"}, "role": "item", "id": "ct"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["Ce"]}], "extent": [24953, 24959], "body": [{"type": "para", "indent": 4, "text": ["Emission color override."], "extent": [24982, 25012]}], "container": true, "attrs": {"type": "vector"}, "role": "item", "id": "ce"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["rough"]}], "extent": [25012, 25021], "body": [{"type": "para", "indent": 4, "text": ["Roughness override."], "extent": [25039, 25064]}], "container": true, "attrs": {"type": "float"}, "role": "item", "id": "rough"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["fresnel"]}], "extent": [25064, 25075], "body": [{"type": "para", "indent": 4, "text": ["Fresnel coefficient override."], "extent": [25097, 25132]}], "container": true, "attrs": {"type": "float"}, "role": "item", "id": "fresnel"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["shadow"]}], "extent": [25132, 25142], "body": [{"type": "para", "indent": 4, "text": ["Shadow intensity override."], "extent": [25164, 25196]}], "container": true, "attrs": {"type": "float"}, "role": "item", "id": "shadow"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["sbias"]}], "extent": [25196, 25205], "body": [{"type": "para", "indent": 4, "text": ["Shadow bias override."], "extent": [25227, 25255]}], "container": true, "attrs": {"type": "float"}, "role": "item", "id": "sbias"}], "container": true, "role": "item_group"}, {"level": 4, "type": "sep", "indent": 0, "text": [" Rendering attributes "], "extent": [25255, 25286]}, {"type": "attributes_item_group", "body": [{"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["uv"]}], "extent": [25286, 25293], "body": [{"type": "para", "indent": 4, "text": ["The UV coordinates of the point/vertex. The first two elements of this vector contain the current U and V coordinates. Note that ", {"type": "code", "text": ["uv"]}, " is Houdini\u2019s conventional attribute name for storing texture coordinates. You can store texture coordinates in other attributes, so you can have multiple UV layouts on the same geometry. Most texture-related nodes have a field to let you specify the name of the UV attribute to use."], "extent": [25339, 25761]}], "container": true, "attrs": {"type": "vector", "on": "point, vertex"}, "role": "item", "id": "uv"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["material"]}], "extent": [25761, 25773], "body": [{"type": "para", "indent": 4, "text": ["The node path to the material to use to shade this primitive. Overrides the object\u2019s material."], "extent": [25796, 25896]}], "container": true, "attrs": {"type": "string"}, "role": "item", "id": "material"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["instance"]}], "extent": [25896, 25908], "body": [{"type": "para", "indent": 4, "text": ["The ", {"type": "code", "text": ["instance"]}, " attribute on the current point, containing a path to the geometry instanced on the point. This can be a file path to a geometry file, or an ", {"type": "code", "text": ["op:"]}, " path to a Geometry object or geometry node. You can overwrite this attribute to change the instanced geometry."], "extent": [25953, 26230]}], "container": true, "attrs": {"type": "string", "on": "detail, prim"}, "role": "item", "id": "instance"}, {"type": "attributes_item", "indent": 0, "text": [{"type": "code", "text": ["rishade"]}], "extent": [26230, 26241], "body": [{"type": "para", "indent": 4, "text": ["Detail/primitive. The name of a RenderMan shader."], "extent": [26286, 26342]}], "container": true, "attrs": {"type": "string", "on": "detail, prim"}, "role": "item", "id": "rishade"}], "container": true, "role": "item_group"}]}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [26342, 26351], "body": [{"type": "related_item_group", "body": [{"ext": null, "type": "related_item", "indent": 0, "text": [" ", {"scheme": null, "value": "/dopparticles/attributes", "type": "link", "text": "", "fullpath": "/dopparticles/attributes"}], "role": "item", "extent": [26351, 26382]}, {"ext": null, "type": "related_item", "indent": 0, "text": [" ", {"scheme": null, "value": "/crowds/attributes", "type": "link", "text": "", "fullpath": "/crowds/attributes"}], "role": "item", "extent": [26382, 26409]}], "container": true, "role": "item_group"}], "text": "Related"}], "title": ["Geometry attributes"], "summary": ["Describes how Houdini represents geometry using details, primitives, points, vertices, and attributes."]}