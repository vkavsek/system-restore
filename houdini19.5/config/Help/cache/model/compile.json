{"type": "root", "attrs": {}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Compiled blocks"], "extent": [0, 20]}, {"type": "summary", "indent": 0, "text": ["You can mark a chain of compilable SOPs as a compiled block which can execute much faster in parallel."], "extent": [20, 132]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Overview"], "extent": [132, 147], "body": [{"type": "para", "indent": 0, "text": ["In geometry networks, you can put a part of the network inside a ", {"type": "em", "text": ["compiled block"]}, " (if all the nodes inside are ", {"type": "q", "text": ["compilable"]}, "). In a way, this makes the block act as if they were one node."], "extent": [147, 336]}, {"type": "para", "indent": 0, "text": ["This imposes a number of restrictions on how the network can work, but can potentially deliver big benefits in the right circumstances."], "extent": [336, 473]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["The main benefit is multithreaded ", {"scheme": null, "value": "looping", "type": "link", "text": ["for-each loops"], "fullpath": "/model/looping"}, " where the network runs the same block of nodes over a large number of separate pieces. Compiled blocks let Houdini spread those iterations across multiple cores."], "extent": [473, 697]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Another benefit is more efficient use of OpenCL. Normally, even if a node processes geometry on the graphics card, the geometry must be copied back into main memory after each node, because any other node could potentially try to access it. In a compiled block, however, multiple OpenCL-based nodes can keep data on the graphics card as they process it without copying it back, increasing speed."], "extent": [697, 1096]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["In a normal network, each node theoretically makes a copy of the geometry it\u2019s working on. There are lots of optimizations to make this efficient in practice, but it still has a cost. In a compiled block the nodes can work in-place on the same geometry because external references are not allowed. This can give compiled blocks additional speedups."], "extent": [1096, 1449]}], "container": true}]}, {"level": 2, "id": "restrictions", "container": true, "type": "h", "indent": 0, "text": ["Restrictions"], "extent": [1449, 1483], "body": [{"type": "para", "indent": 0, "text": ["Unfortunately, to get these benefits, we had to limit some of the flexibility that makes working in Houdini dynamic and fluid."], "extent": [1483, 1612]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["Only ", {"type": "q", "text": ["compile-able"]}, " nodes"], "extent": [1612, 1639], "body": [{"type": "para", "indent": 4, "text": ["You can only used nodes that have been modified to allow compiling inside compiled blocks. You can ", {"scheme": null, "value": "#tips", "type": "link", "text": ["enable a badge in the network editor"], "fullpath": "/model/compile#tips", "fragment": "#tips"}, " to see which nodes can\u2019t be used in a compiled block."], "extent": [1639, 1846]}, {"type": "para", "indent": 4, "text": ["We are continuing to convert nodes based on perceived need. We will probably never get to all the hundreds of existing SOPs. If there\u2019s a node you want to use inside a compiled block that isn\u2019t converted yet, let us know."], "extent": [1846, 2073]}], "container": true}, {"type": "dt", "indent": 0, "text": ["No ", {"type": "code", "text": ["stamp()"]}, " expression"], "extent": [2073, 2098], "body": [{"type": "para", "indent": 4, "text": ["The ", {"scheme": "Exp", "value": "/expressions/stamp", "type": "link", "text": "", "fallback_text": "stamp()", "fullpath": "/expressions/stamp"}, " expression function is the ultimate spooky action at a distance. It relies on any node being able to force another node anywhere else in the network to cook. This complete freedom is not possible with compiled blocks."], "extent": [2098, 2337]}], "container": true}, {"type": "dt", "indent": 0, "text": ["No local variables, no per-component expressions"], "extent": [2337, 2387], "body": [{"type": "para", "indent": 4, "text": ["When a node is part of a compiled block, its algorithm is compiled into the block\u2019s operation, and its parameters are left behind. ", {"type": "em", "text": ["Expressions are not evaluated over each component in the geometry"]}, ". Only expressions that work statically ", {"type": "q", "text": ["ahead of time"]}, " on the entire geometry will work (for example, reading from a numbered input)."], "extent": [2387, 2729]}, {"type": "para", "indent": 4, "text": ["If you need to do something per-component (for example, move points based on the value of a point attribute), you must use a VEX-based node, such as ", {"scheme": "Node", "value": "/nodes/sop/attribwrangle", "type": "link", "text": ["Attribute Wrangle"], "fullpath": "/nodes/sop/attribwrangle"}, "."], "extent": [2729, 2931]}, {"type": "para", "indent": 4, "text": ["(Unlike, ", {"type": "code", "text": ["stamp()"]}, ", this restriction might be lifted someday, depending on how necessary it proves.)"], "extent": [2931, 3037]}], "container": true}, {"type": "dt", "indent": 0, "text": ["No internal geometry references by name"], "extent": [3037, 3078], "body": [{"type": "para", "indent": 4, "text": ["Normally, if you need information about another node, you can evaluate an expression and refer to that node by its path. For example, ", {"type": "code", "text": ["npoints(\"/obj/sphere1\")"]}, " to get the number of points in a node\u2019s geometry. This isn\u2019t very efficient, but it works. In a compiled block, you can\u2019t refer to the geometry in a node using the node path. To accomplish the same thing in a compiled block, you need to replace internal named references with references to ", {"scheme": null, "value": "#spare", "type": "link", "text": ["spare inputs"], "fullpath": "/model/compile#spare", "fragment": "#spare"}, "."], "extent": [3078, 3560]}, {"type": "para", "indent": 4, "text": ["You ", {"type": "em", "text": ["can"]}, " reference ", {"type": "em", "text": ["channel values"]}, " on nodes inside the block by path (for example, ", {"type": "code", "text": ["ch(\"../sphere1/tx\")"]}, "). You just can\u2019t read ", {"type": "em", "text": ["geometry"]}, ", as in a ", {"type": "code", "text": ["point"]}, " expression."], "extent": [3560, 3738]}, {"type": "para", "indent": 4, "text": ["You ", {"type": "em", "text": ["can"]}, " reference geometry ", {"type": "em", "text": ["outside"]}, " the compiled block, however all access to the exterior node will be serialized by a lock, so it will probably hurt performance in a threaded loop. In this case you would use a ", {"scheme": null, "value": "#spare", "type": "link", "text": ["spare input"], "fullpath": "/model/compile#spare", "fragment": "#spare"}, " instead."], "extent": [3738, 3992]}, {"type": "para", "indent": 4, "text": ["Nodes outside the block can reference geometry on nodes inside the block, but doing so cook the interior node (and any dependencies) normally, without any of the benefits of compilation."], "extent": [3992, 4184]}], "container": true}, {"type": "dt", "indent": 0, "text": ["Nodes can\u2019t read from their direct inputs"], "extent": [4184, 4227], "body": [{"type": "para", "indent": 4, "text": ["Expressions can\u2019t read data from/about the node\u2019s direct inputs (for example, ", {"type": "code", "text": ["point(0, \u2026)"]}, " or ", {"type": "code", "text": ["npoints(0)"]}, "). You have to use a ", {"scheme": null, "value": "#spare", "type": "link", "text": ["spare input"], "fullpath": "/model/compile#spare", "fragment": "#spare"}, " to reference the input node."], "extent": [4227, 4414]}, {"type": "para", "indent": 4, "text": ["This is another restriction that may be partially lifted in a future version of Houdini, at least for input 0."], "extent": [4414, 4530]}], "container": true}, {"type": "dt", "indent": 0, "text": ["Disabled/hidden parameters are not evaluated"], "extent": [4530, 4576], "body": [{"type": "para", "indent": 4, "text": ["This is true for all compile-able SOPs, even outside a compiled block. Previously, each SOP would determine which parameters to evaluate in its own cooking code. Now, the cook logic is divorced from parameter evaluation. This means that parameters need to be pre-evaluated. To avoid creating fake time dependency on disabled parameters (or making potentially expensive evaluations), the pre-evaluation skips disabled and hidden parameters."], "extent": [4576, 5021]}], "container": true}, {"type": "dt", "indent": 0, "text": ["Stop Condition not supported"], "extent": [5021, 5051], "body": [{"type": "para", "indent": 4, "text": ["The Stop Condition on For Each nodes isn\u2019t supported inside a compiled block."], "extent": [5051, 5134]}], "container": true}], "container": true}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [5134, 5140], "body": [{"type": "para", "indent": 4, "text": ["At this point in their development, in a production environment, you should probably resist the urge to try to add compiled blocks everywhere trying to gain maximum efficiency. The drawbacks mean the reward is often not worth the effort."], "extent": [5140, 5387]}, {"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["Target use of compiled blocks where they will give the most benefit: in iterations over large numbers of pieces."], "extent": [5387, 5511]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["You might want to get your network working and ", {"type": "q", "text": ["finalized"]}, ", and then based on profiling, try converting any ", {"type": "q", "text": ["slow"]}, " parts into compiled blocks."], "extent": [5511, 5662]}], "container": true}], "container": true}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["How to"], "extent": [5662, 5675], "body": [{"type": "para", "indent": 0, "text": ["Houdini will attempt to compile everything between one or more ", {"scheme": "Node", "value": "/nodes/sop/compile_begin", "type": "link", "text": ["Compile Block Begin nodes"], "fullpath": "/nodes/sop/compile_begin"}, " and a corresponding ", {"scheme": "Node", "value": "/nodes/sop/compile_end", "type": "link", "text": ["Compile Block End node"], "fullpath": "/nodes/sop/compile_end"}, "."], "extent": [5675, 5858]}, {"type": "task_group", "body": [{"ext": null, "type": "task", "indent": 0, "text": [" Create a compiled block"], "role": "item", "extent": [5858, 5890], "body": [{"type": "ord_group", "body": [{"blevel": 6, "type": "ord", "indent": 4, "text": ["In the network editor, open the ", {"keys": ["Tab"], "type": "keys", "text": null}, " menu and choose Compiled Block to create a pair of compiled block nodes."], "extent": [5890, 6010], "body": [{"type": "para", "indent": 8, "text": ["Houdini automatically creates a pair of Begin and End nodes wired together."], "extent": [6010, 6095]}], "container": true}, {"blevel": 6, "type": "ord", "indent": 4, "text": ["You can wire the block into your network, and wire the nodes to compile in between the begin and end nodes."], "extent": [6095, 6211]}], "container": true}], "container": true}], "container": true, "role": "item_group"}]}, {"level": 2, "id": "loops", "container": true, "type": "h", "indent": 0, "text": ["Compiled loops"], "extent": [6211, 6240], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["Put loops ", {"type": "em", "text": ["inside"]}, " the compiled block, rather than a compiled block inside a loop."], "extent": [6240, 6327]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["On the For-Each Block End node of the top-level loop, turn on ", {"type": "ui", "text": ["Multithread when compiled"]}, "."], "extent": [6327, 6423], "body": [{"type": "para", "indent": 4, "text": ["Turning on this checkbox tells Houdini to distribute the different iterations of this loop to different cores. You probably only want to do it on the outer loop to avoid an explosion of the number of distributed tasks."], "extent": [6423, 6648]}], "container": true}], "container": true}, {"level": 3, "id": "nesting", "container": true, "type": "h", "indent": 0, "text": ["Nesting blocks"], "extent": [6648, 6681], "body": [{"type": "para", "indent": 0, "text": ["When using compiled blocks and loops, you must be careful to properly encapsulate and nest each block with Begin/End nodes at the ", {"type": "q", "text": ["borders"]}, " of each block. Visually, in the network, wires crossing into a block should only be connected to block begin nodes."], "extent": [6681, 6939]}, {"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 0, "text": [{"scheme": "Image", "value": "/images/nodes/sop/compiledsops_broken_loop.jpg", "type": "link", "text": "", "fullpath": "/images/nodes/sop/compiledsops_broken_loop.jpg"}], "role": "item", "extent": [6939, 6999], "body": [{"type": "para", "indent": 4, "text": ["In this network, the wire to ", {"type": "code", "text": ["merge3"]}, " crosses a block boundary. This would be valid in a normal cook, where Houdini would just re-cook that path each iteration. The loops in a compiled block are compiled as a separate unit, however, so they have to stand on their own."], "extent": [6999, 7273]}], "container": true}, {"ext": null, "type": "fig", "indent": 0, "text": [{"scheme": "Image", "value": "/images/nodes/sop/compiledsops_fixed_loop.jpg", "type": "link", "text": "", "fullpath": "/images/nodes/sop/compiledsops_fixed_loop.jpg"}], "role": "item", "extent": [7273, 7332], "body": [{"type": "para", "indent": 4, "text": ["The fix is to insert a Block Begin node before the merge, to properly nest the compiled and looping blocks. Set the ", {"type": "ui", "text": ["Method"]}, " parameter on this Begin node to ", {"type": "q", "text": ["Fetch input"]}, "."], "extent": [7332, 7512]}], "container": true}], "container": true, "role": "item_group"}]}]}, {"level": 2, "id": "spare", "container": true, "type": "h", "indent": 0, "text": ["Spare inputs"], "extent": [7512, 7539], "body": [{"type": "para", "indent": 0, "text": ["As noted in the ", {"scheme": null, "value": "#restrictions", "type": "link", "text": ["restrictions"], "fullpath": "/model/compile#restrictions", "fragment": "#restrictions"}, " section, geometry expressions can\u2019t reference the node\u2019s direct inputs, or in named nodes."], "extent": [7539, 7677]}, {"type": "para", "indent": 0, "text": ["The rule is there can\u2019t be any ", {"type": "q", "text": ["surprises"]}, " (dynamic expressions) about what to cook. Any SOPs that need data from another SOP in the compiled block have to make this clear ", {"type": "q", "text": ["statically"]}, " ", {"type": "em", "text": ["before they cook"]}, ", not during the cook."], "extent": [7677, 7904]}, {"type": "para", "indent": 0, "text": ["(The case of VEX-based nodes such as ", {"scheme": "Node", "value": "/nodes/sop/attribwrangle", "type": "link", "text": ["Attribute Wrangle"], "fullpath": "/nodes/sop/attribwrangle"}, " and ", {"scheme": "Node", "value": "/nodes/sop/attribexpression", "type": "link", "text": ["Attribute Expression"], "fullpath": "/nodes/sop/attribexpression"}, " is a bit different. In a VEX node, ", {"type": "code", "text": ["point(0, \u2026)"]}, " will work in VEX because the VEX SOPs have always evaluated all their inputs as it is very inefficient to try and evaluate them on demand.)"], "extent": [7904, 8227]}, {"type": "para", "indent": 0, "text": ["The workaround for this is to add a ", {"type": "em", "text": ["spare input"]}, " to the node, and point that input to the node you want to reference. Then you can use the spare input\u2019s number where you would otherwise use a node path. Spare inputs are ", {"type": "em", "text": ["pre-cooked"]}, " before the compiled block runs. This allows multiple threads can refer to the pre-cooked geometry without having to worry about locking."], "extent": [8227, 8599]}, {"type": "tip_group", "body": [{"type": "tip", "indent": 0, "role": "item", "extent": [8599, 8604], "body": [{"type": "para", "indent": 4, "text": ["For expression functions that take a node path string as an argument (for example, ", {"type": "code", "text": ["npoints(\"/obj/sphere1\")"]}, "), you can substitute an integer instead to refer to an input (for example, ", {"type": "code", "text": ["npoints(-1)"]}, ")."], "extent": [8604, 8809]}], "container": true}], "container": true, "role": "item_group"}, {"type": "task_group", "body": [{"ext": null, "type": "task", "indent": 0, "text": [" Use a spare input to reference another node"], "role": "item", "extent": [8809, 8861], "body": [{"type": "ord_group", "body": [{"blevel": 6, "type": "ord", "indent": 4, "text": ["Select the compiled node in which you want to reference the geometry of another node."], "extent": [8861, 8958]}, {"blevel": 6, "type": "ord", "indent": 4, "text": ["In the parameter editor, click the ", {"scheme": "Smallicon", "value": "BUTTONS/gear", "type": "link", "text": "", "fullpath": "/model/BUTTONS/gear"}, " gear menu and choose ", {"type": "ui", "text": ["Add spare input"]}, "."], "extent": [8958, 9071], "body": [{"type": "para", "indent": 8, "text": ["Houdini adds a new parameter at the end of the node\u2019s interface representing the input."], "extent": [9071, 9172]}], "container": true}, {"blevel": 6, "type": "ord", "indent": 4, "text": ["In the ", {"type": "ui", "text": ["Spare input ", {"type": "var", "text": ["n"]}]}, " field, enter the path of the node you want to reference."], "extent": [9172, 9269]}, {"blevel": 6, "type": "ord", "indent": 4, "text": ["Hover over the ", {"type": "ui", "text": ["Spare input ", {"type": "var", "text": ["n"]}]}, " label to get a tooltip showing which number to use in geometry expressions to refer to the spare input (for example, ", {"type": "code", "text": ["npoints(-1)"]}, ")."], "extent": [9269, 9450], "body": [{"type": "para", "indent": 8, "text": ["(Spare input references count down, so while the first direct input is ", {"type": "code", "text": ["0"]}, " and the second direct input is ", {"type": "code", "text": ["1"]}, ", the first spare input is ", {"type": "code", "text": ["-1"]}, ", the second is ", {"type": "code", "text": ["-2"]}, ", and so on.)"], "extent": [9450, 9634]}], "container": true}], "container": true}], "container": true}], "container": true, "role": "item_group"}]}, {"level": 2, "id": "tips", "container": true, "type": "h", "indent": 0, "text": ["Tips and notes"], "extent": [9634, 9662], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["Spare inputs are also useful to refer to extra geometry inputs in a Wrangle node (beyond the four direct inputs Wrangle nodes come with)."], "extent": [9662, 9804]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["If you put the display flag on a node inside a compiled block, the network will cook normally (uncompiled) to that point. The display flag must be on or after the block end node for the block to compile."], "extent": [9804, 10011]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You can turn on a badge to see which nodes you ", {"type": "em", "text": ["cannot"]}, " use inside a compiled block."], "extent": [10011, 10099], "body": [{"type": "para", "indent": 4, "text": ["In the network editor, choose ", {"type": "ui", "text": ["View \u25b8 Display Options"]}, " or press ", {"keys": ["D"], "type": "keys", "text": null}, ". The set the pop-up menu for ", {"type": "ui", "text": ["Compilable SOP badge"]}, " to ", {"type": "q", "text": ["normal"]}, " or ", {"type": "q", "text": ["large"]}, ". Nodes that you ", {"type": "em", "text": ["cannot"]}, " use in a compiled block will be marked with the ", {"scheme": "Icon", "value": "NETVIEW/not_compilable_badge", "type": "link", "text": "", "fullpath": "/model/NETVIEW/not_compilable_badge"}, " badge."], "extent": [10099, 10370]}], "container": true}], "container": true}]}, {"level": 2, "id": "errors", "container": true, "type": "h", "indent": 0, "text": ["Troubleshooting"], "extent": [10370, 10401], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["No support for compiling this node type"], "extent": [10401, 10443], "body": [{"type": "para", "indent": 4, "text": ["Many SOP node types have not yet been converted to work in compiled blocks.  See the ", {"scheme": null, "value": "#tips", "type": "link", "text": ["tips"], "fullpath": "/model/compile#tips", "fragment": "#tips"}, " above for how to turn on a badge in the network editor showing which nodes are not compilable."], "extent": [10484, 10686]}, {"type": "para", "indent": 4, "text": ["If there\u2019s a node you need to use inside a compiled block that isn\u2019t supported yet, let us know. It will help us decide which nodes to focus on converting."], "extent": [10686, 10847]}], "container": true, "attrs": {"glyph": "fa-exclamation-triangle"}}, {"type": "dt", "indent": 0, "text": ["Attempt to internally reference a compiled node"], "extent": [10847, 10896], "body": [{"type": "para", "indent": 4, "text": ["You cannot reference nodes inside a compiled block by name. Use a spare input and refer to the node using the spare input number instead. See ", {"scheme": null, "value": "#spare", "type": "link", "text": ["spare inputs"], "fullpath": "/model/compile#spare", "fragment": "#spare"}, "."], "extent": [10937, 11107]}], "container": true, "attrs": {"glyph": "fa-exclamation-triangle"}}, {"type": "dt", "indent": 0, "text": ["Violation of strict nesting of blocks. Incompatible For Block Begin encountered while processing Block End. A Block Begin in Fetch Input mode may be needed"], "extent": [11107, 11264], "body": [{"type": "para", "indent": 4, "text": ["See ", {"scheme": null, "value": "#nesting", "type": "link", "text": ["nesting blocks"], "fullpath": "/model/compile#nesting", "fragment": "#nesting"}, ". Look at the nodes mentioned in the error message and see if they have wires crossing into a block that are connected to something other than a block/loop begin node."], "extent": [11305, 11511]}, {"type": "para", "indent": 4, "text": ["To fix this problem, add a loop/compiled block begin node to the incoming wire. For loop begin nodes, if you just want to use the input, set the ", {"type": "ui", "text": ["Method"]}, " to ", {"type": "q", "text": ["Fetch input"]}, "."], "extent": [11511, 11691]}], "container": true, "attrs": {"glyph": "fa-exclamation-triangle"}}], "container": true}]}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [11691, 11700], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": null, "value": "verbs", "type": "link", "text": "", "fullpath": "/model/verbs"}], "extent": [11700, 11712]}], "container": true}], "text": "Related"}], "title": ["Compiled blocks"], "summary": ["You can mark a chain of compilable SOPs as a compiled block which can execute much faster in parallel."]}