{"type": "root", "attrs": {"type": "node", "context": "chop", "internal": "channelwrangle", "icon": "CHOP/channelwrangle", "since": "16.0", "tags": "vex, util", "version": null, "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Channel Wrangle"], "extent": [112, 132]}, {"type": "summary", "indent": 0, "text": ["Runs a VEX snippet to modify channel data."], "extent": [132, 183]}, {"type": "para", "indent": 0, "text": ["This is a very powerful, low-level node that lets experts who are familiar with VEX tweak channel data and attributes using code."], "extent": [183, 314]}, {"type": "para", "indent": 0, "text": ["This node corresponds to the ", {"scheme": "Node", "value": "/nodes/chop/vopchop", "type": "link", "text": ["Channel VOP"], "fullpath": "/nodes/chop/vopchop"}, ", but uses a textual VEX snippet instead of a VOP network."], "extent": [314, 434]}, {"type": "para", "indent": 0, "text": ["This node runs the snippet for every channel (or group of channels depending on the ", {"type": "ui", "text": ["Iterate"]}, " parameter) in the input channels.\nThis node also runs over all the samples based on the first input channel range.\nThe snippet can edit the input channels by changing the bound parameters.\nIt can access information from other channels or geometry using VEX functions."], "extent": [434, 799]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["Press ", {"keys": ["MMB"], "type": "keys", "text": null}, " on the node to see any error output from the snippet."], "extent": [799, 870]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You can use the VEX function ", {"type": "code", "text": ["ch"]}, " to evaluate parameters.\n  The path is relative to this node (", {"type": "code", "text": ["ch(\"parm\")"]}, " will evaluate the parameter ", {"type": "code", "text": ["parm"]}, " on this node). This evaluation will be done at the current sample time if you don\u2019t supply an explicit time for vex functions."], "extent": [870, 1143]}], "container": true}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [1143, 1149], "body": [{"type": "para", "indent": 4, "text": ["If you create a ", {"type": "ui", "text": ["Transform VOP"]}, " node using the ", {"scheme": null, "value": "/basics/tabmenu", "type": "link", "text": ["Tab menu"], "fullpath": "/basics/tabmenu"}, ", it creates a Channel VOP and sets it to work with transform channels and constraints."], "extent": [1149, 1318]}], "container": true}], "container": true, "role": "item_group"}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Context"], "extent": [1318, 1332], "body": [{"type": "para", "indent": 0, "text": ["This node runs the VEX snippet in the ", {"type": "strong", "text": ["CHOP context"]}, " and the following global variables are available."], "extent": [1332, 1437]}, {"level": 1, "id": "globals", "container": true, "type": "globals_section", "indent": 0, "role": "section", "extent": [2575, 2586], "body": [{"type": "globals_item_group", "body": [{"ext": null, "type": "globals_item", "indent": 0, "text": ["V"], "role": "item", "extent": [2586, 2592], "body": [{"type": "para", "indent": 4, "text": ["Value of the current sample. This variable should be set to the new\n    value by the function. The variable is initialized to the value of\n    the first input\u2019s channels."], "extent": [2614, 2790]}], "container": true, "attrs": {"type": "float", "id": "V"}}, {"ext": null, "type": "globals_item", "indent": 0, "text": ["I"], "role": "item", "extent": [2790, 2795], "body": [{"type": "para", "indent": 4, "text": ["Index or sample number of the current channel.\n    Time dependent only in Current Frame mode."], "extent": [2828, 2927]}], "container": true, "attrs": {"type": "int", "mode": "r", "id": "I"}}, {"ext": null, "type": "globals_item", "indent": 0, "text": ["IN"], "role": "item", "extent": [2927, 2933], "body": [{"type": "para", "indent": 4, "text": ["Index or sample number of the current channel.\n    Non Time Dependent."], "extent": [2966, 3042]}], "container": true, "attrs": {"type": "int", "mode": "r", "id": "IN"}}, {"ext": null, "type": "globals_item", "indent": 0, "text": ["S"], "role": "item", "extent": [3042, 3047], "body": [{"type": "para", "indent": 4, "text": ["Index of the start of the current channel. This is the index of the\n    first sample."], "extent": [3080, 3171]}], "container": true, "attrs": {"type": "int", "mode": "r", "id": "S"}}, {"ext": null, "type": "globals_item", "indent": 0, "text": ["E"], "role": "item", "extent": [3171, 3176], "body": [{"type": "para", "indent": 4, "text": ["Index of the last sample (end sample)."], "extent": [3209, 3253]}], "container": true, "attrs": {"type": "int", "mode": "r", "id": "E"}}, {"ext": null, "type": "globals_item", "indent": 0, "text": ["SR"], "role": "item", "extent": [3253, 3259], "body": [{"type": "para", "indent": 4, "text": ["Sample rate for the current channel."], "extent": [3294, 3336]}], "container": true, "attrs": {"type": "float", "mode": "r", "id": "SR"}}, {"ext": null, "type": "globals_item", "indent": 0, "text": ["L"], "role": "item", "extent": [3336, 3341], "body": [{"type": "para", "indent": 4, "text": ["Length of the channel (total number of samples)."], "extent": [3374, 3428]}], "container": true, "attrs": {"type": "int", "mode": "r", "id": "L"}}, {"ext": null, "type": "globals_item", "indent": 0, "text": ["C"], "role": "item", "extent": [3428, 3433], "body": [{"type": "para", "indent": 4, "text": ["Channel number for the current channel. When processing multiple\n    channels, this is the index of the channel currently being\n    evaluated."], "extent": [3466, 3614]}], "container": true, "attrs": {"type": "int", "mode": "r", "id": "C"}}, {"ext": null, "type": "globals_item", "indent": 0, "text": ["NC"], "role": "item", "extent": [3614, 3620], "body": [{"type": "para", "indent": 4, "text": ["Total number of channels the CHOP will affect."], "extent": [3653, 3705]}], "container": true, "attrs": {"type": "int", "mode": "r", "id": "NC"}}, {"ext": null, "type": "globals_item", "indent": 0, "text": ["CN"], "role": "item", "extent": [3705, 3711], "body": [{"type": "para", "indent": 4, "text": ["Name of the current channel."], "extent": [3747, 3781]}], "container": true, "attrs": {"type": "string", "mode": "r", "id": "CN"}}, {"ext": null, "type": "globals_item", "indent": 0, "text": ["FF"], "role": "item", "extent": [3781, 3787], "body": [{"type": "para", "indent": 4, "text": ["Frame number as a float corresponding to the sample being evaluated.\n    Time dependent only in Current Frame mode."], "extent": [3822, 3943]}], "container": true, "attrs": {"type": "float", "mode": "r", "id": "FF"}}, {"ext": null, "type": "globals_item", "indent": 0, "text": ["FFN"], "role": "item", "extent": [3943, 3950], "body": [{"type": "para", "indent": 4, "text": ["Frame number as a float corresponding to the sample being evaluated.\n    Non Time Dependent."], "extent": [3985, 4083]}], "container": true, "attrs": {"type": "float", "mode": "r", "id": "FFN"}}, {"ext": null, "type": "globals_item", "indent": 0, "text": ["Frame"], "role": "item", "extent": [4083, 4092], "body": [{"type": "para", "indent": 4, "text": ["Frame number as a float corresponding to the evaluation time.\n    Forces Time Dependent."], "extent": [4127, 4225]}], "container": true, "attrs": {"type": "float", "mode": "r", "id": "Frame"}}, {"ext": null, "type": "globals_item", "indent": 0, "text": ["T"], "role": "item", "extent": [4225, 4230], "body": [{"type": "para", "indent": 4, "text": ["Time in seconds corresponding to the sample being evaluated.\n    Time dependent only in Current Frame mode."], "extent": [4265, 4378]}], "container": true, "attrs": {"type": "float", "mode": "r", "id": "T"}}, {"ext": null, "type": "globals_item", "indent": 0, "text": ["TN"], "role": "item", "extent": [4378, 4384], "body": [{"type": "para", "indent": 4, "text": ["Time in seconds corresponding to the sample being evaluated.\n    Non Time Dependent."], "extent": [4419, 4509]}], "container": true, "attrs": {"type": "float", "mode": "r", "id": "TN"}}, {"ext": null, "type": "globals_item", "indent": 0, "text": ["Time"], "role": "item", "extent": [4509, 4517], "body": [{"type": "para", "indent": 4, "text": ["Time in seconds corresponding to the evaluation time.\n    Forces Time Dependent."], "extent": [4552, 4639]}], "container": true, "attrs": {"type": "float", "mode": "r", "id": "Time"}}], "container": true, "role": "item_group"}], "text": "Globals"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Syntax"], "extent": [1476, 1489], "body": [{"type": "para", "indent": 0, "text": ["The ", {"type": "ui", "text": ["VEX snippet"]}, " parameter lets you enter a snippet of ", {"scheme": null, "value": "/vex/", "type": "link", "text": ["VEX code"], "fullpath": "/vex/index"}, " to run on the input geometry.\nSee ", {"scheme": null, "value": "/vex/snippets", "type": "link", "text": ["VEX snippets"], "fullpath": "/vex/snippets"}, " for basic information on the syntax available in the snippet parameter.\nSee ", {"scheme": null, "value": "/vex/", "type": "link", "text": ["the VEX chapter"], "fullpath": "/vex/index"}, " for general information on the VEX language."], "extent": [16, 299]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["VEX variables"], "extent": [1528, 1548], "body": [{"type": "para", "indent": 0, "text": ["You can create temporary VEX variables.\nNormal VEX variables do not have a ", {"type": "code", "text": ["@"]}, " prefix.\nFor example, the following code swaps ", {"type": "code", "text": ["px"]}, " and ", {"type": "code", "text": ["py"]}, "."], "extent": [1548, 1690]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\nfloat temp = @px;\n@px = @py;\n@py = temp;\n"], "extent": [1690, 1745]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["VEX structures for Constraints"], "extent": [1745, 1783], "body": [{"type": "para", "indent": 0, "text": ["CHOP contraints make use of VEX structures defined in ", {"type": "code", "text": ["$HFS/houdini/vex/include/chop_constraints.h"]}, "."], "extent": [287, 391]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["chopTRS"], "extent": [391, 407], "body": [{"type": "para", "indent": 0, "text": ["Holds transform channels within a structure."], "extent": [407, 454]}, {"lang": null, "type": "pre", "indent": 0, "text": ["\nstruct chopTRS\n{\n    vector t; // tx ty tz channels\n    vector r; // rx ry rz channels\n    vector s; // sx ry rz channels\n\n    void fromIdentity();\n    void fromMatrix(const matrix m; const vector pivot; const int trs; const int xyz);\n    void fromMatrix(const matrix m);\n}\n"], "extent": [454, 736]}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["chopConstraintContext"], "extent": [736, 768], "body": [{"type": "para", "indent": 0, "text": ["Holds the current evaluated transform channels within a structure.\nThis abstracts the global variables 'C' and 'I', so you don\u2019t have to worry about the current time and the current channel index."], "extent": [768, 967]}, {"lang": null, "type": "pre", "indent": 0, "text": ["\nstruct chopConstraintContext\n{\n    vector t; // tx ty tz channels\n    vector r; // rx ry rz channels\n    vector s; // sx sy sz channels\n\n    void init();\n    void init( vector t0; vector r0; vector s0; const string prefix0 );\n\n    void fromMatrix(const matrix m;\n                   const vector pivot; const int trs; const int xyz);\n\n    void fromMatrix(const matrix m);\n\n    chopTRS fetchInput( const int i );\n    float fetchInput( const int i; const string name; int result );\n    float fetchInput( const int i; const int index; int result );\n\n    matrix fetchInputMatrix( const int i );\n\n    int isConnected( const int i );\n    int numInputs();\n\n    // Evaluate a channel input by name\n    float chinput( int i; const string name; int ret );\n\n    // Evaluate a float parameter on the current CHOP node\n    float chf( const string parm );\n\n    // Evaluate an integer parameter on the current CHOP node\n    int chi( const string parm );\n\n    // Evaluate a vector parameter on the current CHOP node\n    vector chv( const string parm );\n}\n"], "extent": [967, 2013]}, {"type": "para", "indent": 0, "text": ["Here\u2019s an example of how to blend the translations of the 4 inputs."], "extent": [2013, 2083]}, {"lang": null, "type": "pre", "indent": 0, "text": ["\n// Declare the context\n// This is done automatically on transform wrangles\nchopConstraintContext c;\n\n// Fetch transform inputs\nchopTRS c0 = c->fetchInput(0);\nchopTRS c1 = c->fetchInput(1);\nchopTRS c2 = c->fetchInput(2);\nchopTRS c3 = c->fetchInput(3);\nmatrix m0 = c->fetchInputMatrix(0);\nmatrix m1 = c->fetchInputMatrix(1);\nmatrix m2 = c->fetchInputMatrix(2);\nmatrix m3 = c->fetchInputMatrix(3);\n\n// Compute transform\n@t = c0.t + c1.t + c2.t + c3.t;\n@t *= 0.25;\n@r = c0.r;\n@s = c0.s;\n\n"], "extent": [2083, 2575]}]}]}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [1827, 1839], "body": [{"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Code"], "extent": [1839, 1851], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Channel Names"], "extent": [1851, 1867], "body": [{"type": "para", "indent": 4, "text": ["Space separated names of the channels to create when the first input isn\u2019t connected.\n    Supports the same patterns as the ", {"type": "ui", "text": ["Scope"]}, " parameter."], "extent": [1886, 2036]}], "container": true, "attrs": {"id": "vex_name"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Channel Count"], "extent": [2036, 2051], "body": [{"type": "para", "indent": 4, "text": ["Repeats the ", {"type": "ui", "text": ["Channel Names"]}, " multiple times when the first input isn\u2019t connected."], "extent": [2071, 2159]}], "container": true, "attrs": {"id": "vex_count"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Iterate"], "extent": [2159, 2168], "body": [{"type": "para", "indent": 4, "text": ["How to iterate over channels and samples."], "extent": [2186, 2233]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Over Channels and Samples"], "extent": [2233, 2264], "body": [{"type": "para", "indent": 8, "text": ["Iterates over all the samples of a channel one channel at a time.\n        Use the ", {"type": "code", "text": ["V"]}, " global variable to read and write the current channel value."], "extent": [2264, 2420]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Over Samples and Channels"], "extent": [2420, 2451], "body": [{"type": "para", "indent": 8, "text": ["Iterates over channels one sample at a time.\n        Use the ", {"type": "code", "text": ["V"]}, " global variable to read and write the current channel value."], "extent": [2451, 2586]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Over Samples and Every Nth Channels"], "extent": [2586, 2627], "body": [{"type": "para", "indent": 8, "text": ["Iterates over channels one sample at a time, but you can evaluate a group of channels together.\n        Use the ", {"type": "ui", "text": ["Iterate Step"]}, " to define the size a channel group.\n        Use the ", {"type": "ui", "text": ["Iterate Names"]}, " with a ", {"type": "code", "text": ["@"]}, " prefix to read and write the current values."], "extent": [2627, 2891]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Over Samples and Every Translate/Rotate/Scale"], "extent": [2891, 2942], "body": [{"type": "para", "indent": 8, "text": ["Iterates over transform channels one sample at a time.\n        Access the translation vector using ", {"type": "code", "text": ["@t"]}, ", the rotation using ", {"type": "code", "text": ["@r"]}, " and the scale using ", {"type": "code", "text": ["@s"]}, ".\n        A ", {"type": "code", "text": ["struct chopConstraintContext"]}, " is also bound to the ", {"type": "code", "text": ["c"]}, " variable.\n        Use ", {"type": "code", "text": ["c->fetchInput(1)"]}, " to return the second input transform as a ", {"type": "code", "text": ["struct chopTRS"]}, ".\n        Use ", {"type": "code", "text": ["c->fetchInputMatrix(1)"]}, " to return the second input transform as a matrix."], "extent": [2942, 3360]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Over Clip"], "extent": [3360, 3375], "body": [{"type": "para", "indent": 8, "text": ["Runs the snippet a single time with ", {"type": "code", "text": ["C"]}, " and ", {"type": "code", "text": ["I"]}, " variables set to zero.\n        Use this to if you want to analyze all the channels using a snippet.\n        You can\u2019t write to the global variable ", {"type": "code", "text": ["V"]}, " or to any channel data.\n        You can read and write clip attributes using ", {"type": "code", "text": ["chattr"]}, " and ", {"type": "code", "text": ["chsetattr"]}, "."], "extent": [3375, 3686]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Over Channels"], "extent": [3686, 3705], "body": [{"type": "para", "indent": 8, "text": ["Runs the snippet one time per channel with the ", {"type": "code", "text": ["I"]}, " variable set to zero.\n        Use this to if you want to analyze channels individually using a snippet.\n        You can\u2019t write to the global variable ", {"type": "code", "text": ["V"]}, " or to any channel data.\n        You can read and write channel attributes using ", {"type": "code", "text": ["chattr"]}, " and ", {"type": "code", "text": ["chsetattr"]}, "."], "extent": [3705, 4026]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Over Sample"], "extent": [4026, 4043], "body": [{"type": "para", "indent": 8, "text": ["Runs the snippet one time per sample with the ", {"type": "code", "text": ["C"]}, " variable always set to zero.\n        Use this to if you want to analyze the all channel values for a single sample using a snippet.\n        You can\u2019t write to the global variable ", {"type": "code", "text": ["V"]}, " or to any channel data.\n        You can read and write sample attributes using ", {"type": "code", "text": ["chattr"]}, " and ", {"type": "code", "text": ["chsetattr"]}, "."], "extent": [4043, 4391]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "iterate"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Iterate Step"], "extent": [4391, 4405], "body": [{"type": "para", "indent": 4, "text": ["Sets the number of channels to regroup together when ", {"type": "ui", "text": ["Iterate"]}, " is set to ", {"type": "ui", "text": ["Every Nth Channels"]}, "."], "extent": [4428, 4532]}], "container": true, "attrs": {"id": "channel_step"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Iterate Names"], "extent": [4532, 4547], "body": [{"type": "para", "indent": 4, "text": ["A space separated string representing the bind names when ", {"type": "ui", "text": ["Iterate"]}, " is set to ", {"type": "ui", "text": ["Every Nth Channels"]}, ".\n    Use an iterate name prefixed by ", {"type": "code", "text": ["@"]}, " to read and write to a channel."], "extent": [4568, 4749]}], "container": true, "attrs": {"id": "bind_names"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["VEXpression"], "extent": [4749, 4762], "body": [{"type": "para", "indent": 4, "text": ["A snippet of VEX code that will manipulate the channels.\n    You can use ", {"type": "code", "text": ["@", {"type": "var", "text": ["channel_name"]}]}, " syntax to access bound channels or ", {"type": "code", "text": ["V"]}, " to write to the current channel sample."], "extent": [4780, 4957]}], "container": true, "attrs": {"id": "snippet"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Evaluation Node Path"], "extent": [4957, 4979], "body": [{"type": "para", "indent": 4, "text": ["VEX functions like ", {"type": "code", "text": ["ch()"]}, " usually evaluate with respect to this node.\n    Enter a node path here to override where the path search starts from.\n    This is useful for embedding in a digital asset, where you want searches\n    to start from the asset root."], "extent": [5001, 5261]}], "container": true, "attrs": {"id": "vex_cwdpath"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Enforce Prototypes"], "extent": [16, 36], "body": [{"type": "para", "indent": 4, "text": ["Requires that you declare ", {"type": "code", "text": ["@"]}, " bindings in snippets as prototypes before using them. This applies to both attributes (for example ", {"type": "code", "text": ["@Cd"]}, ") and ", {"type": "q", "text": ["convenience"]}, " bindings such as ", {"type": "code", "text": ["@ptnum"]}, " and ", {"type": "code", "text": ["@Frame"]}, ". For example:"], "extent": [36, 248]}, {"lang": "vex", "type": "pre", "indent": 4, "text": ["\n    // Declare bindings\n    int @ptnum;\n    float @Frame;\n    vector @Cd;\n\n    // Use bindings after declaration\n    int pointnum = @ptnum;\n    float red = @Cd[0] / @Frame;\n    "], "extent": [248, 447]}, {"type": "para", "indent": 4, "text": ["Automatic binding with the ", {"type": "code", "text": ["@"]}, " syntax can be convenient, but as your scene becomes more complex there is the risk that a typo in an ", {"type": "code", "text": ["@"]}, " binding will silently just bind a non-existent attribute."], "extent": [447, 646]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "id": "channel", "container": true, "type": "h", "indent": 0, "text": ["Channel"], "extent": [16, 40], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Align"], "extent": [40, 48], "body": [{"type": "para", "indent": 4, "text": ["The alignment option to use."], "extent": [48, 82]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Extend to Min/Max"], "extent": [82, 105], "body": [{"type": "para", "indent": 8, "text": ["Find the earliest start and latest end, and extend all\n        inputs to that range using the extend conditions."], "extent": [105, 226]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Stretch to Min/Max"], "extent": [226, 250], "body": [{"type": "para", "indent": 8, "text": ["Find the earliest start and latest end, and stretch every\n        channel\u2019s start and end to that range."], "extent": [250, 363]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Shift to Minimum"], "extent": [363, 385], "body": [{"type": "para", "indent": 8, "text": ["Find the earliest start and shift all channels so they all\n        start at that index. All channels are extended to the length\n        of the longest one."], "extent": [385, 549]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Shift to Maximum"], "extent": [549, 571], "body": [{"type": "para", "indent": 8, "text": ["Find the latest end and shift all channels so they all end\n        at that index. Extend all channels to the length of the\n        longest one."], "extent": [571, 723]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Shift to First Interval"], "extent": [723, 752], "body": [{"type": "para", "indent": 8, "text": ["Shift all channels to the start of the first channel and\n        sample all inputs using the first input\u2019s range."], "extent": [752, 874]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Trim to First Interval"], "extent": [874, 902], "body": [{"type": "para", "indent": 8, "text": ["Trim all channels to first channel\u2019s range."], "extent": [902, 954]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Stretch to First Interval"], "extent": [954, 985], "body": [{"type": "para", "indent": 8, "text": ["Stretch all channels to the first channel\u2019s range."], "extent": [985, 1044]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Trim to Smallest Interval"], "extent": [1044, 1075], "body": [{"type": "para", "indent": 8, "text": ["Trim all channels to the smallest start/end interval. The\n        start and end values may not come from the same channel."], "extent": [1075, 1206]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Stretch to Smallest Interval"], "extent": [1206, 1240], "body": [{"type": "para", "indent": 8, "text": ["Stretch all channels to the smallest start/end interval. The\n        start and end values may not come from the same channel."], "extent": [1240, 1375]}], "container": true}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Range"], "extent": [1375, 1382], "body": [{"type": "para", "indent": 4, "text": ["Specifies the range of data to generate."], "extent": [1382, 1428]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Use Full Animation Range"], "extent": [1428, 1458], "body": [{"type": "para", "indent": 8, "text": ["All of the animated range."], "extent": [1458, 1493]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Use Current Frame"], "extent": [1493, 1516], "body": [{"type": "para", "indent": 8, "text": ["Only the sample at the current frame."], "extent": [1516, 1562]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Use Start/End"], "extent": [1562, 1581], "body": [{"type": "para", "indent": 8, "text": ["The range is specified from the ", {"type": "ui", "text": ["Start"]}, " and ", {"type": "ui", "text": ["End"]}, "\n        parameters."], "extent": [1581, 1663]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Use Value Animation"], "extent": [1663, 1688], "body": [{"type": "para", "indent": 8, "text": ["The range is taken from range of keys available in the\n        evaluated Value parameters."], "extent": [1688, 1787]}], "container": true}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Start"], "extent": [1787, 1794], "body": [{"type": "para", "indent": 4, "text": ["The start time of the channel range."], "extent": [1817, 1859]}], "container": true, "attrs": {"channels": "/start"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["End"], "extent": [1859, 1864], "body": [{"type": "para", "indent": 4, "text": ["The end time of the channel range."], "extent": [1885, 1925]}], "container": true, "attrs": {"channels": "/end"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Sample Rate"], "extent": [1925, 1938], "body": [{"type": "para", "indent": 4, "text": ["The sample rate of the CHOP."], "extent": [1960, 1994]}], "container": true, "attrs": {"channels": "/rate"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Number of Threads"], "extent": [1994, 2013], "body": [{"type": "para", "indent": 4, "text": ["The number of separate threads to use to evaluate the channel samples.\n    The default is no threading."], "extent": [2013, 2122]}, {"type": "para", "indent": 4, "text": ["Since Houdini evaluates the VEX program for each sample in the input\n    geometry, it can benefit greatly from threading on a multi-processor\n    or multi-core machine when the CHOP nodes have many samples."], "extent": [2122, 2334]}], "container": true, "role": "item"}], "container": true}]}, {"level": 3, "id": "common", "container": true, "type": "h", "indent": 0, "text": ["Common"], "extent": [2334, 2356], "body": [{"type": "para", "indent": 0, "text": ["Some of these parameters may not be available on all CHOP nodes."], "extent": [2356, 2423]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Scope"], "extent": [2423, 2430], "body": [{"type": "para", "indent": 4, "text": ["To determine which channels get affected, some CHOPs have a scope string. Patterns can be used in the scope, for example ", {"type": "code", "text": ["*"]}, " (match all), and ", {"type": "code", "text": ["?"]}, " (match single character). "], "extent": [2430, 2612]}, {"type": "para", "indent": 4, "text": ["The following are examples of possible channel name matching options:"], "extent": [2612, 2691]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["chan2"]}], "extent": [2691, 2704], "body": [{"type": "para", "indent": 8, "text": ["Matches a single channel name."], "extent": [2704, 2748]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["chan3 tx ty tz"]}], "extent": [2748, 2770], "body": [{"type": "para", "indent": 8, "text": ["Matches four channel names, separated by spaces."], "extent": [2770, 2832]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["chan*"]}], "extent": [2832, 2845], "body": [{"type": "para", "indent": 8, "text": ["Matches each channel that starts with ", {"type": "code", "text": ["chan"]}, "."], "extent": [2845, 2908]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["*foot*"]}], "extent": [2908, 2922], "body": [{"type": "para", "indent": 8, "text": ["Matches each channel that has ", {"type": "code", "text": ["foot"]}, " in it."], "extent": [2922, 2979]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["t?"]}], "extent": [2979, 2989], "body": [{"type": "para", "indent": 8, "text": ["The ", {"type": "code", "text": ["?"]}, " matches a single character. ", {"type": "code", "text": ["t?"]}, " matches two-character channels starting with t.  "], "extent": [2989, 3093]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["r[xyz]"]}], "extent": [3093, 3107], "body": [{"type": "para", "indent": 8, "text": ["Matches channels ", {"type": "code", "text": ["rx"]}, ", ", {"type": "code", "text": ["ry"]}, " and ", {"type": "code", "text": ["rz"]}, "."], "extent": [3107, 3162]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["blend[3-7:2]"]}], "extent": [3162, 3182], "body": [{"type": "para", "indent": 8, "text": ["Matches number ranges giving ", {"type": "code", "text": ["blend3"]}, ", ", {"type": "code", "text": ["blend5"]}, ", and ", {"type": "code", "text": ["blend7"]}, "."], "extent": [3182, 3262]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["blend[2-3,5,13]"]}], "extent": [3262, 3285], "body": [{"type": "para", "indent": 8, "text": ["Matches channels ", {"type": "code", "text": ["blend2"]}, ", ", {"type": "code", "text": ["blend3"]}, ", ", {"type": "code", "text": ["blend5"]}, ", ", {"type": "code", "text": ["blend13"]}, "."], "extent": [3285, 3356]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["t[xyz]"]}], "extent": [3356, 3370], "body": [{"type": "para", "indent": 8, "text": [{"type": "code", "text": ["[xyz]"]}, "matches three characters, giving channels ", {"type": "code", "text": ["tx"]}, ", ", {"type": "code", "text": ["ty"]}, " and ", {"type": "code", "text": ["tz"]}, "."], "extent": [3370, 3458]}], "container": true}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Sample Rate Match"], "extent": [3458, 3477], "body": [{"type": "para", "indent": 4, "text": ["The Sample Rate Match Options handle cases where multiple input CHOPs\u2019 sample rates are different."], "extent": [3477, 3585]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Resample At First Input\u2019s Rate"], "extent": [3585, 3621], "body": [{"type": "para", "indent": 8, "text": ["Use rate of first input to resample others."], "extent": [3621, 3682]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Resample At Maximum Rate"], "extent": [3682, 3712], "body": [{"type": "para", "indent": 8, "text": ["Resample to highest sample rate."], "extent": [3712, 3758]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Resample At Minimum Rate"], "extent": [3758, 3788], "body": [{"type": "para", "indent": 8, "text": ["Resample to the lowest sample rate."], "extent": [3788, 3841]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Error if Rates Differ"], "extent": [3841, 3868], "body": [{"type": "para", "indent": 8, "text": ["Does not accept conflicting sample rates."], "extent": [3868, 3923]}], "container": true}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Units"], "extent": [3923, 3930], "body": [{"type": "para", "indent": 4, "text": ["The units for which time parameters are specified."], "extent": [3930, 3990]}, {"type": "para", "indent": 4, "text": ["For example, you can specify the amount of time a lag should last for in seconds (default), frames (at the Houdini FPS), or samples (in the CHOP\u2019s sample rate)."], "extent": [3990, 4160]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [4160, 4170], "body": [{"type": "para", "indent": 8, "text": ["When you change the Units parameter, it does not convert the existing parameters to the new units."], "extent": [4170, 4282]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Time Slice"], "extent": [4282, 4294], "body": [{"type": "para", "indent": 4, "text": ["Time Slicing is a feature which boosts cooking performance and reduces memory usage. Traditionally, CHOPs calculate the channel over its entire frame range. If the channel does need to be evaluated every frame, then cooking the entire range of the channel is unnecessary. It is more efficient to calculate only the fraction of the channel that is needed. This fraction is known as a Time Slice."], "extent": [4294, 4694]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Unload"], "extent": [4694, 4702], "body": [{"type": "para", "indent": 4, "text": ["Causes the memory consumed by a CHOP to be released after it is cooked and the data passed to the next CHOP."], "extent": [4702, 4816]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Export Prefix"], "extent": [4816, 4836], "body": [{"type": "para", "indent": 4, "text": ["The Export prefix is prepended to CHOP channel names to determine where to export to. "], "extent": [4836, 4932]}, {"type": "para", "indent": 4, "text": ["For example, if the CHOP channel was named ", {"type": "code", "text": ["geo1:tx"]}, ", and the prefix was ", {"type": "code", "text": ["/obj"]}, ", the channel would be exported to ", {"type": "code", "text": ["/obj/geo1/tx"]}, "."], "extent": [4932, 5071]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [5071, 5081], "body": [{"type": "para", "indent": 8, "text": ["You can leave the ", {"type": "ui", "text": ["Export Prefix"]}, " blank, but then your CHOP track names need to be absolute paths, such as ", {"type": "code", "text": ["obj:geo1:tx"]}, "."], "extent": [5081, 5214]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Graph Color"], "extent": [5214, 5227], "body": [{"type": "para", "indent": 4, "text": ["Every CHOP has this option. Each CHOP gets a default color assigned for display in the Graph port, but you can override the color in the Common page under Graph Color. There are 36 RGB color combinations in the Palette."], "extent": [5227, 5452]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Graph Color Step"], "extent": [5452, 5470], "body": [{"type": "para", "indent": 4, "text": ["When the graph displays the animation curves and a CHOP has two or more channels, this defines the difference in color from one channel to the next, giving a rainbow spectrum of colors."], "extent": [5470, 5661]}], "container": true, "role": "item"}], "container": true}]}]}], "text": "Parameters"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [5348, 5357], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/chop/vopchop", "type": "link", "text": "", "fullpath": "/nodes/chop/vopchop"}], "extent": [5357, 5380]}], "container": true}], "text": "Related"}], "title": ["Channel Wrangle"], "summary": ["Runs a VEX snippet to modify channel data."], "included": ["/nodes/chop/common", "/nodes/sop/wrangle_syntax", "/vex/_enforce_prototypes", "/vex/contexts/chop"]}