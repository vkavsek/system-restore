{"type": "root", "attrs": {"type": "node", "context": "chop", "internal": "pipein", "icon": "CHOP/pipein", "version": null, "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Pipe In"], "extent": [65, 77]}, {"type": "summary", "indent": 0, "text": ["Pipes data from custom devices into a CHOP, without needing the Houdini Developers' Kit or knowledge of Houdini internals."], "extent": [77, 208]}, {"type": "para", "indent": 0, "text": ["You can use a ", {"type": "q", "text": ["named pipe"]}, " or ", {"type": "q", "text": ["FIFO"]}, " (first in, first out) on Linux and Mac OS X (see ", {"type": "code", "text": ["man -S 7 pipe"]}, ") or a network connection (for remote connections) on Windows, Linux, and Mac OS X. "], "extent": [208, 395]}, {"type": "para", "indent": 0, "text": ["You need a program that gets values from the input device, and outputs them\ninto a file specified in Filename or a Network port. Your custom program writes\nformatted messages into the file or port, and the Pipe In CHOP reads it,\ncreating the channels specified in the messages."], "extent": [395, 674]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Networking into Houdini"], "extent": [674, 704], "body": [{"type": "para", "indent": 0, "text": ["You can receive network data from another server (e.g. from a\nHoudini ", {"scheme": null, "value": "pipeout", "type": "link", "text": ["Pipe Out CHOP"], "fullpath": "/nodes/chop/pipeout"}, " running remotely). A connection must be\nestablished between the server and the Pipe In CHOP before data is\nsent. Do this by changing the Source from Pipe to Network). You must\nsupply the Server Address and Port from which to receive incoming\ndata to a channel. The server should be listening for connections on\nthe port that this CHOP is using."], "extent": [704, 1145]}, {"type": "para", "indent": 0, "text": ["To setup a link between two Houdini processes, one process should\nhave a ", {"scheme": null, "value": "pipeout", "type": "link", "text": ["Pipe Out CHOP"], "fullpath": "/nodes/chop/pipeout"}, " active (thus listening for connections) on an\narbitrary port (i.e. port #5010). The second Houdini uses a Pipe In\nCHOP with the network address set to the name of the machine that\nthe first Houdini process is running on. The network port should be\nset to the same port as the server (in this case, 5010). The port\nnumber can be any number between 5000 and 10000, as long as it is\nconsistent between the Pipe In and ", {"scheme": null, "value": "pipeout", "type": "link", "text": ["Pipe Out"], "fullpath": "/nodes/chop/pipeout"}, " CHOPs. For more than one\nconnection, use distinct port numbers. Pipe In/Out CHOPs with\nmatching port numbers on different machines should automatically\nsense one another."], "extent": [1145, 1848]}, {"type": "para", "indent": 0, "text": ["If you just want to send data from a local process to Houdini, set the server address to ", {"type": "code", "text": ["localhost"]}, "."], "extent": [1848, 1951]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Programming the Pipe In CHOP"], "extent": [1951, 1986], "body": [{"type": "para", "indent": 0, "text": ["The Pipe In chop is designed to allow you to program an interface to\nchops that do not require a Houdini Developers Kit."], "extent": [1986, 2109]}, {"type": "para", "indent": 0, "text": ["The Pipe In CHOP allows Houdini to read information in a special\nformats described here from a FIFO (First In, First Out) file and\ncreate CHOP channels. As long as the correct formats are used,\nHoudini will be able to get data from any source including devices\nsuch as a joystick, microphone or PuppetWorks' hardware."], "extent": [2109, 2428]}, {"type": "para", "indent": 0, "text": ["The Pipe In CHOP has two parameters and parses three command\nformats. The first parameter specifies which file to read from and\nthe second toggles between active (reading) and inactive (discards\ndata) modes. The formats supported allow the following\nfunctionality: upload the most current sample data, upload all\nsample data and create a full waveform, and upload the channel\nnames."], "extent": [2428, 2812]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Using the Pipe In CHOP"], "extent": [2812, 2843], "body": [{"type": "para", "indent": 0, "text": ["In order to read information with this chop, a separate\napplication has to be developed to write to a FIFO in the proper\nformat. The following sections describe and give sample code\n(written in C) for opening a file and writing values that will\nbe accepted by the Pipe In CHOP."], "extent": [2843, 3123]}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Opening a Fifo File"], "extent": [3123, 3151], "body": [{"type": "para", "indent": 0, "text": ["To create a file that the Pipe In CHOP will read from, use the\nfollowing code to open a new FIFO called FIFO_NAME. Define\nFIFO_NAME to be the desired file name to create. The output\nstream that is used for writing will block until a reader is\nconnected to the file."], "extent": [3151, 3419]}, {"lang": null, "type": "pre", "indent": 0, "text": ["\n#include    <sys/types.h>\n#include    <sys/stat.h>\n#include    <stdio.h>\nmode_t       prev_mask;\nFILE        *output = 0;\n/* Create a new fifo */\nprev_mask = umask(0);\nmkfifo (FIFO_NAME, 0666);\numask(prev_mask);\n/* Open the file for writing */\nfprintf(stderr,\n\"Awaiting reader of FIFO %s\\n\\r\", FIFO_NAME);\noutput = fopen(FIFO_NAME, \"wb\");\n"], "extent": [3419, 3766]}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Writing To The File"], "extent": [3766, 3795], "body": [{"type": "para", "indent": 0, "text": ["The Pipe In chop reads information from the FIFO in eight-byte\nbig endian chunks of data called tokens, so it is necessary to\nwrite to the file in the same format. There is also a method in\nplace for sending an escape character in case a reset is required\nin the middle of parsing a command."], "extent": [3795, 4089]}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [4089, 4095], "body": [{"type": "para", "indent": 4, "text": ["In versions prior to Houdini 12, 4 byte tokens were used instead of 8\n    byte tokens."], "extent": [4095, 4187]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 0, "text": ["The reset character is an integer value of ", {"type": "code", "text": ["170"]}, ". When this byte\nis received, followed by a byte with a value of zero, the\ncurrent parsing is reset. In order to send a value of ", {"type": "code", "text": ["170"]}, "\nwithout the command being reset, two bytes with a 170 value must\nbe sent consecutively so that the Pipe In CHOP will disregard\nthe first value."], "extent": [4187, 4515]}, {"lang": null, "type": "pre", "indent": 0, "text": ["\n#define ESCAPE_CHARACTER        170\nvoid\nwrite_byte(char b, FILE *output)\n{\n    /* Prepend escape character */\n    if (b == ESCAPE_CHARACTER)\n      fputc(ESCAPE_CHARACTER, output); \n      fputc(b, output);\n}\nvoid\nwrite_values(const char *p, int size, FILE *output)\n{\n    int          i;\n    for(i=0; i<size; i++)\n      write_byte(p[i], output);\n}\nvoid\nsend_reset(FILE *output)\n{\n    fputc(ESCAPE_CHARACTER, output);\n    fputc(0, output);\n    fputc(ESCAPE_CHARACTER, output);\n    fputc(0, output);\n    fputc(ESCAPE_CHARACTER, output);\n    fputc(0, output);\n    fputc(ESCAPE_CHARACTER, output);\n    fputc(0, output);\n    fflush(output);\n}\n"], "extent": [4515, 5160]}, {"type": "para", "indent": 0, "text": ["Using these functions, any 8 bytes of data (e.g. 00000001, 3.141,\nChan, \u2026) can be sent to the file. To send a reset signal, four\nescape sequences are written to pad to 8 bytes. It is a good idea\nto send a reset signal before the command and flush the FIFO at\nthe end of a command."], "extent": [5160, 5445]}, {"lang": null, "type": "pre", "indent": 0, "text": ["\nint64       token;\ndouble            sample;\nsend_reset(output); \n/* Send a command here */\nwrite_values((char *)&token, sizeof(token), output);\nwrite_values((char *)&sample, sizeof(sample), output);\nfflush(output);\n"], "extent": [5445, 5669]}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [5669, 5676], "body": [{"type": "para", "indent": 4, "text": ["An escape character (170) can be sent, followed by any\n    other character, to stop the current command parsing and\n    begin again.  If the 170-170 sequence is sent, the first\n    character is ignored and the value is sent normally."], "extent": [5676, 5915]}], "container": true}], "container": true, "role": "item_group"}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Command Type #1: Current Values"], "extent": [5915, 5955], "body": [{"type": "para", "indent": 0, "text": ["The first type of command that the Pipe In CHOP will read is\nused to get the most recent channel data. It has a default\nsample rate of 30 samples per second, CHOP length of 1, and a\nstart position of ", {"type": "code", "text": ["0"]}, ". This command allows the number of channels\nto be set and the samples associated with those channels to be\nread."], "extent": [5955, 6274]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["(int64) 1"], "extent": [6274, 6285], "body": [{"type": "para", "indent": 4, "text": ["Command Type."], "extent": [6285, 6303]}], "container": true}, {"type": "dt", "indent": 0, "text": ["(int64)"], "extent": [6303, 6312], "body": [{"type": "para", "indent": 4, "text": ["Number of Channels."], "extent": [6312, 6336]}], "container": true}, {"type": "dt", "indent": 0, "text": ["(double)"], "extent": [6336, 6346], "body": [{"type": "para", "indent": 4, "text": ["Sample Data, one sample for each channel."], "extent": [6346, 6393]}], "container": true}], "container": true}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Command Type #2: Upload"], "extent": [6393, 6425], "body": [{"type": "para", "indent": 0, "text": ["The second type of command that can be parsed is used to upload\na full set of samples to create a waveform. The sample rate,\ntrack length, start position, number of channels, and samples\nfor each channel to fill the track length must be provided. The\nchannel samples must be interleaved so that all the channels for\none index are filled before moving forward to the next index."], "extent": [6425, 6805]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["(int64) 2"], "extent": [6805, 6816], "body": [{"type": "para", "indent": 4, "text": ["Command Type."], "extent": [6816, 6834]}], "container": true}, {"type": "dt", "indent": 0, "text": ["(int64)"], "extent": [6834, 6843], "body": [{"type": "para", "indent": 4, "text": ["Track Length."], "extent": [6843, 6861]}], "container": true}, {"type": "dt", "indent": 0, "text": ["(double)"], "extent": [6861, 6871], "body": [{"type": "para", "indent": 4, "text": ["Sample Rate."], "extent": [6871, 6888]}], "container": true}, {"type": "dt", "indent": 0, "text": ["(double)"], "extent": [6888, 6898], "body": [{"type": "para", "indent": 4, "text": ["Start Index."], "extent": [6898, 6915]}], "container": true}, {"type": "dt", "indent": 0, "text": ["(int64)"], "extent": [6915, 6924], "body": [{"type": "para", "indent": 4, "text": ["Number of Channels."], "extent": [6924, 6948]}], "container": true}, {"type": "dt", "indent": 0, "text": ["(double)"], "extent": [6948, 6958], "body": [{"type": "para", "indent": 4, "text": ["Sample Data, one sample for each channel for each index."], "extent": [6958, 7020]}], "container": true}], "container": true}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Command Type #3: Channel Names"], "extent": [7020, 7059], "body": [{"type": "para", "indent": 0, "text": ["This command allows the channels to be assigned names before\nthey are created. Since the names are usually strings, it is\nimportant to remember to write them as eight-byte tokens (padded\nwith zeroes at the end if necessary) so they will be parsed\ncorrectly. This format requires the number of names to be set,\nfollowed by the name length (in number of eight-byte tokens) and\nname data for each channel."], "extent": [7059, 7464]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["(int64) 3"], "extent": [7464, 7475], "body": [{"type": "para", "indent": 4, "text": ["Command Type"], "extent": [7475, 7492]}], "container": true}, {"type": "dt", "indent": 0, "text": ["(int64)"], "extent": [7492, 7501], "body": [{"type": "para", "indent": 4, "text": ["Number of Names"], "extent": [7501, 7522]}], "container": true}], "container": true}, {"type": "para", "indent": 0, "text": ["For each name, the following data is read:"], "extent": [7522, 7566]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["(int64)"], "extent": [7566, 7575], "body": [{"type": "para", "indent": 4, "text": ["Name Length, one per name"], "extent": [7575, 7605]}], "container": true}, {"type": "dt", "indent": 0, "text": ["(char*)"], "extent": [7605, 7614], "body": [{"type": "para", "indent": 4, "text": ["Name Chunks (char\\", {"scheme": null, "value": "8\\", "type": "link", "text": "", "fullpath": "/nodes/chop/8\\"}, " * ", {"type": "em", "text": ["Name Length"]}, ")"], "extent": [7614, 7659]}], "container": true}], "container": true}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Command Type #4: Disconnect"], "extent": [7659, 7695], "body": [{"type": "para", "indent": 0, "text": ["This command causes the Pipe In CHOP to disconnect the network connection. It\nis typically sent by the ", {"scheme": null, "value": "pipeout", "type": "link", "text": ["Pipe Out CHOP"], "fullpath": "/nodes/chop/pipeout"}, " when its Active parameter is\nturned off or if the node is bypassed."], "extent": [7695, 7892]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["(int64) 4"], "extent": [7892, 7903], "body": [{"type": "para", "indent": 4, "text": ["Command Type"], "extent": [7903, 7921]}], "container": true}], "container": true}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Additional commands"], "extent": [7921, 7949], "body": [{"lang": null, "type": "pre", "indent": 0, "text": ["\ndelay refresh\n    (int64)        5 - command type\n    (int64)        - seconds to delay\n\nscript\n    (int64)        6 - command type\n    (int64)        - Script Length\n    (char*)        - Script Chunks (char[8] * Script Length)\n"], "extent": [7949, 8186]}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Writing a Command"], "extent": [8186, 8213], "body": [{"type": "para", "indent": 0, "text": ["Using command type 1 as an example, the following function could\nbe used to send a command to the FIFO which will be read by the\nPipe In CHOP."], "extent": [8213, 8358]}, {"lang": null, "type": "pre", "indent": 0, "text": ["\nvoid\nsend_current_values(FILE *output, int num, double *samples)\n{\n    int64       token;\n    int         j;\n    send_reset(output);             /* just to be safe */\n    /* Command Type */\n    token = 1;\n    write_values((char *)&token, sizeof(token), output);\n    /* Number of Channels */\n    token = num;\n    write_values((char *)&token, sizeof(token), output);\n    /* Sample Values */\n    for(j=0; j<num; j++)\n      write_values((char *)&samples[j],\n        sizeof(samples[j]), output);\n      fflush(output);\n}\n"], "extent": [8358, 8881]}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Source Code Example"], "extent": [8881, 8908], "body": [{"type": "para", "indent": 0, "text": ["You can find a compilable example of a Pipe In application in:"], "extent": [8908, 8973]}, {"lang": null, "type": "pre", "indent": 0, "text": ["\n$HH/public/PPD.tar.Z\n"], "extent": [8973, 9002]}, {"type": "para", "indent": 0, "text": ["One device that is implemented using this protocol the Puppetworks device, and its driver can be installed via the proto_install application."], "extent": [9002, 9147]}]}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [9147, 9159], "body": [{"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["PipeIn"], "extent": [9159, 9173], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Source"], "extent": [9173, 9182], "body": [{"type": "para", "indent": 4, "text": ["Data can be piped in through a UNIX pipe or a Network port."], "extent": [9182, 9251]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Filename"], "extent": [9251, 9261], "body": [{"type": "para", "indent": 4, "text": ["The file that the device data will be read from. The file must\n    not be a regular file. It must be a ", {"type": "q", "text": ["named pipe"]}, " or ", {"type": "q", "text": ["FIFO"]}, ". In\n    UNIX, see ", {"type": "q", "text": ["mknod"]}, "."], "extent": [9261, 9423]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Server Address"], "extent": [9423, 9439], "body": [{"type": "para", "indent": 4, "text": ["The network address of the server computer. This address is a\n    standard WWW address, such as 'foo' or 'foo.bar.com'."], "extent": [9439, 9568]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Server Port"], "extent": [9568, 9581], "body": [{"type": "para", "indent": 4, "text": ["The network port of the server. The port is a number between\n    ", {"type": "code", "text": ["5000"]}, " and ", {"type": "code", "text": ["10000"]}, ", which both the server and the client use to\n    connect with."], "extent": [9581, 9737]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Active"], "extent": [9737, 9745], "body": [{"type": "para", "indent": 4, "text": ["While active, the CHOP receives information from the pipe or\n    server. When off, no updating occurs. Data sent by a server is\n    lost, but a pipe will store the data until active is turned on\n    again. If in Network mode, turning this parameter on initiates a\n    connection, and turning it off breaks the connection."], "extent": [9745, 10076]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Reset Channels"], "extent": [10076, 10092], "body": [{"type": "para", "indent": 4, "text": ["Clears all channels and data."], "extent": [10092, 10135]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "id": "common", "container": true, "type": "h", "indent": 0, "text": ["Common"], "extent": [2334, 2356], "body": [{"type": "para", "indent": 0, "text": ["Some of these parameters may not be available on all CHOP nodes."], "extent": [2356, 2423]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Scope"], "extent": [2423, 2430], "body": [{"type": "para", "indent": 4, "text": ["To determine which channels get affected, some CHOPs have a scope string. Patterns can be used in the scope, for example ", {"type": "code", "text": ["*"]}, " (match all), and ", {"type": "code", "text": ["?"]}, " (match single character). "], "extent": [2430, 2612]}, {"type": "para", "indent": 4, "text": ["The following are examples of possible channel name matching options:"], "extent": [2612, 2691]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["chan2"]}], "extent": [2691, 2704], "body": [{"type": "para", "indent": 8, "text": ["Matches a single channel name."], "extent": [2704, 2748]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["chan3 tx ty tz"]}], "extent": [2748, 2770], "body": [{"type": "para", "indent": 8, "text": ["Matches four channel names, separated by spaces."], "extent": [2770, 2832]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["chan*"]}], "extent": [2832, 2845], "body": [{"type": "para", "indent": 8, "text": ["Matches each channel that starts with ", {"type": "code", "text": ["chan"]}, "."], "extent": [2845, 2908]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["*foot*"]}], "extent": [2908, 2922], "body": [{"type": "para", "indent": 8, "text": ["Matches each channel that has ", {"type": "code", "text": ["foot"]}, " in it."], "extent": [2922, 2979]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["t?"]}], "extent": [2979, 2989], "body": [{"type": "para", "indent": 8, "text": ["The ", {"type": "code", "text": ["?"]}, " matches a single character. ", {"type": "code", "text": ["t?"]}, " matches two-character channels starting with t.  "], "extent": [2989, 3093]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["r[xyz]"]}], "extent": [3093, 3107], "body": [{"type": "para", "indent": 8, "text": ["Matches channels ", {"type": "code", "text": ["rx"]}, ", ", {"type": "code", "text": ["ry"]}, " and ", {"type": "code", "text": ["rz"]}, "."], "extent": [3107, 3162]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["blend[3-7:2]"]}], "extent": [3162, 3182], "body": [{"type": "para", "indent": 8, "text": ["Matches number ranges giving ", {"type": "code", "text": ["blend3"]}, ", ", {"type": "code", "text": ["blend5"]}, ", and ", {"type": "code", "text": ["blend7"]}, "."], "extent": [3182, 3262]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["blend[2-3,5,13]"]}], "extent": [3262, 3285], "body": [{"type": "para", "indent": 8, "text": ["Matches channels ", {"type": "code", "text": ["blend2"]}, ", ", {"type": "code", "text": ["blend3"]}, ", ", {"type": "code", "text": ["blend5"]}, ", ", {"type": "code", "text": ["blend13"]}, "."], "extent": [3285, 3356]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["t[xyz]"]}], "extent": [3356, 3370], "body": [{"type": "para", "indent": 8, "text": [{"type": "code", "text": ["[xyz]"]}, "matches three characters, giving channels ", {"type": "code", "text": ["tx"]}, ", ", {"type": "code", "text": ["ty"]}, " and ", {"type": "code", "text": ["tz"]}, "."], "extent": [3370, 3458]}], "container": true}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Sample Rate Match"], "extent": [3458, 3477], "body": [{"type": "para", "indent": 4, "text": ["The Sample Rate Match Options handle cases where multiple input CHOPs\u2019 sample rates are different."], "extent": [3477, 3585]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Resample At First Input\u2019s Rate"], "extent": [3585, 3621], "body": [{"type": "para", "indent": 8, "text": ["Use rate of first input to resample others."], "extent": [3621, 3682]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Resample At Maximum Rate"], "extent": [3682, 3712], "body": [{"type": "para", "indent": 8, "text": ["Resample to highest sample rate."], "extent": [3712, 3758]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Resample At Minimum Rate"], "extent": [3758, 3788], "body": [{"type": "para", "indent": 8, "text": ["Resample to the lowest sample rate."], "extent": [3788, 3841]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Error if Rates Differ"], "extent": [3841, 3868], "body": [{"type": "para", "indent": 8, "text": ["Does not accept conflicting sample rates."], "extent": [3868, 3923]}], "container": true}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Units"], "extent": [3923, 3930], "body": [{"type": "para", "indent": 4, "text": ["The units for which time parameters are specified."], "extent": [3930, 3990]}, {"type": "para", "indent": 4, "text": ["For example, you can specify the amount of time a lag should last for in seconds (default), frames (at the Houdini FPS), or samples (in the CHOP\u2019s sample rate)."], "extent": [3990, 4160]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [4160, 4170], "body": [{"type": "para", "indent": 8, "text": ["When you change the Units parameter, it does not convert the existing parameters to the new units."], "extent": [4170, 4282]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Time Slice"], "extent": [4282, 4294], "body": [{"type": "para", "indent": 4, "text": ["Time Slicing is a feature which boosts cooking performance and reduces memory usage. Traditionally, CHOPs calculate the channel over its entire frame range. If the channel does need to be evaluated every frame, then cooking the entire range of the channel is unnecessary. It is more efficient to calculate only the fraction of the channel that is needed. This fraction is known as a Time Slice."], "extent": [4294, 4694]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Unload"], "extent": [4694, 4702], "body": [{"type": "para", "indent": 4, "text": ["Causes the memory consumed by a CHOP to be released after it is cooked and the data passed to the next CHOP."], "extent": [4702, 4816]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Export Prefix"], "extent": [4816, 4836], "body": [{"type": "para", "indent": 4, "text": ["The Export prefix is prepended to CHOP channel names to determine where to export to. "], "extent": [4836, 4932]}, {"type": "para", "indent": 4, "text": ["For example, if the CHOP channel was named ", {"type": "code", "text": ["geo1:tx"]}, ", and the prefix was ", {"type": "code", "text": ["/obj"]}, ", the channel would be exported to ", {"type": "code", "text": ["/obj/geo1/tx"]}, "."], "extent": [4932, 5071]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [5071, 5081], "body": [{"type": "para", "indent": 8, "text": ["You can leave the ", {"type": "ui", "text": ["Export Prefix"]}, " blank, but then your CHOP track names need to be absolute paths, such as ", {"type": "code", "text": ["obj:geo1:tx"]}, "."], "extent": [5081, 5214]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Graph Color"], "extent": [5214, 5227], "body": [{"type": "para", "indent": 4, "text": ["Every CHOP has this option. Each CHOP gets a default color assigned for display in the Graph port, but you can override the color in the Common page under Graph Color. There are 36 RGB color combinations in the Palette."], "extent": [5227, 5452]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Graph Color Step"], "extent": [5452, 5470], "body": [{"type": "para", "indent": 4, "text": ["When the graph displays the animation curves and a CHOP has two or more channels, this defines the difference in color from one channel to the next, giving a rainbow spectrum of colors."], "extent": [5470, 5661]}], "container": true, "role": "item"}], "container": true}]}]}], "text": "Parameters"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [10160, 10169], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/chop/audioin", "type": "link", "text": "", "fullpath": "/nodes/chop/audioin"}], "extent": [10169, 10192]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/chop/midiin", "type": "link", "text": "", "fullpath": "/nodes/chop/midiin"}], "extent": [10192, 10213]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/chop/pipeout", "type": "link", "text": "", "fullpath": "/nodes/chop/pipeout"}], "extent": [10213, 10236]}], "container": true}], "text": "Related"}], "title": ["Pipe In"], "summary": ["Pipes data from custom devices into a CHOP, without needing the Houdini Developers' Kit or knowledge of Houdini internals."], "included": ["/nodes/chop/common"]}