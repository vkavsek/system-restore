{"type": "root", "attrs": {"type": "node", "context": "dop", "internal": "femsolidobject", "Version": "2.0", "icon": "DOP/solidobject", "tags": "fem", "version": "2.0", "since": "14.0", "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["FEM Solid Object"], "extent": [0, 21]}, {"type": "summary", "indent": 0, "text": ["Creates a simulated FEM solid from geometry."], "extent": [150, 202]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Overview"], "extent": [202, 217], "body": [{"type": "para", "indent": 0, "text": ["The Solid Object DOP creates a Solid Object inside the DOP simulation. It creates a new object and attaches the subdata required for it to be a properly conforming Solid Object. Solid Objects can be simulated using the FEM Solver."], "extent": [217, 450]}, {"type": "para", "indent": 0, "text": ["Solid objects are different than rigid bodies. Solid objects are flexible, which makes it possible for them to deform, and can be used to simulate materials such as flesh, wood, and concrete. Solid objects are also able to break dynamically during a simulation, based on the deformation that happens during the simulation."], "extent": [450, 774]}, {"type": "para", "indent": 0, "text": ["You can use a tetrahedral mesh in SOPs to create your solid object. Your solid geometry should satisfy ", {"scheme": null, "value": "/finiteelements/geometry", "type": "link", "text": ["guidelines"], "fullpath": "/finiteelements/geometry"}, " that ensure a fast-running and good looking simulation."], "extent": [774, 972]}, {"type": "para", "indent": 0, "text": ["See ", {"scheme": null, "value": "/finiteelements/", "type": "link", "text": ["the section on solid simulation"], "fullpath": "/finiteelements/index"}, " for more information."], "extent": [972, 1050]}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [1050, 1056], "body": [{"type": "para", "indent": 4, "text": ["Once you convert geometry to a solid object, you can only transform, rotate, and scale it at the first frame."], "extent": [1056, 1172]}], "container": true}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Solid Object shelf tool"], "extent": [1172, 1202], "body": [{"type": "task_group", "body": [{"ext": null, "type": "task", "indent": 0, "text": [" Create a hard solid object"], "role": "item", "extent": [1202, 1238], "body": [{"type": "ord_group", "body": [{"blevel": 6, "type": "ord", "indent": 4, "text": ["Select the geometry to convert to a solid object."], "extent": [1238, 1294]}, {"blevel": 6, "type": "ord", "indent": 4, "text": ["On the ", {"type": "ui", "text": ["Solid"]}, " tab, click the ", {"scheme": "Icon", "value": "DOP/femsolidobject", "type": "link", "text": "", "fullpath": "/nodes/dop/DOP/femsolidobject"}, " Solid Object tool."], "extent": [1294, 1379]}], "container": true}], "container": true}], "container": true, "role": "item_group"}]}, {"level": 2, "id": "organicmass", "container": true, "type": "h", "indent": 0, "text": ["Organic Mass shelf tool"], "extent": [1379, 1423], "body": [{"type": "summary", "indent": 0, "text": ["Creates a solid finite element (FEM) object that is pliant and elastic, similar to muscle and fat."], "extent": [1423, 1530]}, {"type": "task_group", "body": [{"ext": null, "type": "task", "indent": 0, "text": [" Create a squishy solid object"], "role": "item", "extent": [1530, 1568], "body": [{"type": "ord_group", "body": [{"blevel": 6, "type": "ord", "indent": 4, "text": ["Select the geometry to convert to an organic mass."], "extent": [1568, 1625]}, {"blevel": 6, "type": "ord", "indent": 4, "text": ["On the ", {"type": "ui", "text": ["Solid"]}, " tab, click the ", {"scheme": "Icon", "value": "SHELF/squid", "type": "link", "text": "", "fullpath": "/nodes/dop/SHELF/squid"}, " Organic Mass tool."], "extent": [1625, 1703]}], "container": true}], "container": true}], "container": true, "role": "item_group"}]}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [1703, 1715], "body": [{"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Model"], "extent": [1715, 1728], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Stiffness Multiplier"], "extent": [16, 38], "body": [{"type": "para", "indent": 4, "text": ["This is a multiplier for all the internal stiffnesses of this object."], "extent": [62, 137]}], "container": true, "attrs": {"id": "stiffness"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Damping Ratio"], "extent": [137, 152], "body": [{"type": "para", "indent": 4, "text": ["This controls how quickly the object stops deforming."], "extent": [179, 238]}], "container": true, "attrs": {"id": "dampingratio"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Mass Density"], "extent": [238, 252], "body": [{"type": "para", "indent": 4, "text": ["This is the amount of mass per volume."], "extent": [278, 323]}], "container": true, "attrs": {"id": "massdensity"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Material Model"], "extent": [16, 32], "body": [{"type": "para", "indent": 4, "text": ["Choose the model that determines how the material resists deformation. The Neo-Hookean material model is useful for simulating biological tissues (e.g., muscles and fat), and requires the ", {"type": "ui", "text": ["Solve Method"]}, " on the ", {"scheme": "Node", "value": "/nodes/dop/femsolver", "type": "link", "text": ["FEM Solver"], "fullpath": "/nodes/dop/femsolver"}, " to be set to ", {"type": "ui", "text": ["GNL"]}, "."], "extent": [56, 327]}], "container": true, "attrs": {"id": "materialmodel"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Shape Stiffness"], "extent": [327, 344], "body": [{"type": "para", "indent": 4, "text": ["This determines how strongly the object resists local changes in shape."], "extent": [369, 446]}], "container": true, "attrs": {"id": "shapestiffness"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Volume Stiffness"], "extent": [446, 464], "body": [{"type": "para", "indent": 4, "text": ["This determines how strongly the object resists local changes in volume."], "extent": [490, 567]}], "container": true, "attrs": {"id": "volumestiffness"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Repulsion"], "extent": [1800, 1811], "body": [{"type": "para", "indent": 4, "text": ["This controls the strength of the contact forces in the normal direction; try increasing this if you get visible interpenetrations between objects in your simulation"], "extent": [1811, 1982]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Friction"], "extent": [1982, 1992], "body": [{"type": "para", "indent": 4, "text": ["This controls the strength of friction forces at contacts"], "extent": [1992, 2055]}], "container": true, "role": "item"}], "container": true}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Deformation"], "extent": [2055, 2073], "body": [{"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Initial"], "extent": [2073, 2091], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Initial State"], "extent": [16, 31], "body": [{"type": "para", "indent": 4, "text": ["The path to the SOP node with the initial connectivity, position and velocity."], "extent": [56, 140]}], "container": true, "attrs": {"channels": "/soppath"}, "role": "item"}], "container": true}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Rest"], "extent": [2129, 2142], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Rest Shape"], "extent": [16, 28], "body": [{"type": "para", "indent": 4, "text": ["The path to the SOP node that defines the rest shape."], "extent": [66, 125]}], "container": true, "attrs": {"channels": "/restgeometrypath"}, "role": "item"}], "container": true}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Target"], "extent": [2177, 2192], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Target Deformation"], "extent": [16, 36], "body": [{"type": "para", "indent": 4, "text": ["The path to the SOP node with target deformation."], "extent": [76, 132]}], "container": true, "attrs": {"channels": "/targetgeometrypath"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Target Strength"], "extent": [132, 149], "body": [{"type": "para", "indent": 4, "text": ["Strength density of the distributed soft-constraint force field that tries to match the target position."], "extent": [185, 295]}], "container": true, "attrs": {"channels": "/targetstrength"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Target Damping"], "extent": [295, 311], "body": [{"type": "para", "indent": 4, "text": ["Damping density of the distributed soft-constraint force field that tries to match the target velocity."], "extent": [346, 456]}], "container": true, "attrs": {"channels": "/targetdamping"}, "role": "item"}], "container": true}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Embedding"], "extent": [2229, 2247], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Enable Embedding"], "extent": [0, 18], "body": [{"type": "para", "indent": 4, "text": ["Turns on/off the use of embedded geometry."], "extent": [51, 99]}], "container": true, "attrs": {"channels": "/enableembedding"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Embedded Geometry"], "extent": [99, 118], "body": [{"type": "para", "indent": 4, "text": ["This geometry is embedded into and deformed along with the simulated tetrahedral mesh."], "extent": [152, 244]}], "container": true, "attrs": {"channels": "/embeddedgeometry"}, "role": "item"}], "container": true}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Collisions"], "extent": [2285, 2302], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Collide with other objects of different solver"], "extent": [16, 64], "body": [{"type": "para", "indent": 4, "text": ["If enabled, the geometry in this object will collide with all DOP objects that belong to a different solver DOP node. Examples, are ", {"scheme": "Node", "value": "/nodes/dop/staticobject", "type": "link", "text": ["Static Objects"], "fullpath": "/nodes/dop/staticobject"}, ", ", {"scheme": "Node", "value": "/nodes/dop/rbdobject", "type": "link", "text": ["RBD Objects"], "fullpath": "/nodes/dop/rbdobject"}, ", and the ", {"scheme": "Node", "value": "/nodes/dop/groundplane", "type": "link", "text": ["Ground Plane"], "fullpath": "/nodes/dop/groundplane"}, ". When the ", {"type": "ui", "text": ["Collision Detection"]}, " parameter on the Static Object is set to ", {"type": "ui", "text": ["Use Volume Collisions"]}, ", then the polygon vertices will be tested for collision against the signed distance field (SDF) of the Static Object. When ", {"type": "ui", "text": ["Collision Detection"]}, " is set to ", {"type": "ui", "text": ["Use Surface Collisions"]}, ", then geometry-based continuous collision detection is used. The geometry-based collisions collide points against polygons, and edges against edges."], "extent": [93, 786]}, {"type": "para", "indent": 4, "text": ["When surface-based collisions are used, only polygons and tetrahedrons in the ", {"scheme": "Node", "value": "/nodes/dop/staticobject", "type": "link", "text": ["Static Object"], "fullpath": "/nodes/dop/staticobject"}, " are considered. Other types of primitives, for example spheres, are be ignored. The geometry of the external objects (e.g. Static Object) is treated as being one-sided; only the outsides of the polygons, determined by the winding order, oppose collisions."], "extent": [786, 1163]}, {"type": "para", "indent": 4, "text": ["When volume-based collisions are enabled, only points will be colliding against the volumes, not the interiors of polygons and tetrahedrons. When colliding against small volumes, this may mean that you need to increase the number of points on your mesh to get accurate collision results."], "extent": [1163, 1456]}], "container": true, "attrs": {"id": "collideindependent"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Collide with other objects of same solver"], "extent": [1456, 1499], "body": [{"type": "para", "indent": 4, "text": ["When enabled, this object will collide with other objects that have the same solver. These collisions are handled using continuous collision detection, based on the geometry (polygons and/or tetrahedrons). For collisions between objects on the same solver, the polygons are treated as two-sided. Both sides of the polygons collide. The surface of a tetrahedral mesh only collides on one side: the outside."], "extent": [1528, 1939]}], "container": true, "attrs": {"id": "collidecodependent"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Collide distinct connected components of this object"], "extent": [1939, 1993], "body": [{"type": "para", "indent": 4, "text": ["If disabled, no two tetrahedrons within this object can collide with each other."], "extent": [2015, 2104]}], "container": true, "attrs": {"id": "collideself"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Self-collide each connected component"], "extent": [2104, 2144], "body": [{"type": "para", "indent": 4, "text": ["If disabled, no two tetrahedrons that belong on the same connected component may collide with each other."], "extent": [2175, 2286]}], "container": true, "attrs": {"id": "collideselfcomponent"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Self-collide within each fracture part (defined by fracturepart primitive attribute)"], "extent": [2286, 2372], "body": [{"type": "para", "indent": 4, "text": ["This option only has an effect when fracturing is enabled on the solver. If disabled, no two tetrahedrons that belong on the same fracture part may collide with each other. Fracture parts are controlled by the integer-valued ", {"type": "code", "text": ["fracturepart"]}, " primitive attribute."], "extent": [2406, 2673]}], "container": true, "attrs": {"id": "collideselffracturepart"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["External"], "extent": [2599, 2616], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Division Method"], "extent": [3647, 3664], "body": [{"type": "para", "indent": 4, "text": ["If ", {"type": "ui", "text": ["Non Square"]}, " is chosen, the specified size is divided into the given number\n    of divisions of voxels.  However, the sides of these voxels may not be\n    equal, possibly leading to distorted simulations."], "extent": [3692, 3907]}, {"type": "para", "indent": 4, "text": ["When an axis is specified, that axis is considered authoritative\n    for determining the number of divisions.  The chosen axis' size\n    will be divided by the uniform divisions to yield the voxel\n    size.  The divisions for the other axes will then be adjusted to\n    the closest integer multiple that fits in the required size."], "extent": [3907, 4247]}, {"type": "para", "indent": 4, "text": ["Finally, the size along non-chosen axes will be changed to\n    represent uniform voxel sizes.  If the ", {"type": "ui", "text": ["Max Axis"]}, " option is chosen,\n    the maximum sized axis is used."], "extent": [4247, 4421]}, {"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["By Size"]}, " is chosen, the ", {"type": "ui", "text": ["Division Size"]}, " will be used to\n    compute the number of voxels that fit in the given sized box."], "extent": [4421, 4562]}], "container": true, "attrs": {"id": "sdf_uniformvoxels"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Uniform Divisions"], "extent": [4741, 4760], "body": [{"type": "para", "indent": 4, "text": ["The resolution of the key axis on the voxel grid.  This allows you\n    to control the overall resolution with one parameter and still\n    preserve uniform voxels.  The ", {"type": "ui", "text": ["Uniform Voxels"]}, " option specifies\n    which axis should be used as the reference. It is usually safest\n    to use the maximum axis."], "extent": [4789, 5100]}], "container": true, "attrs": {"id": "sdf_uniformdiv"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Tolerance"], "extent": [8820, 8831], "body": [{"type": "para", "indent": 4, "text": ["This specifies the tolerance used for ray intersections\n    when computing the SDF. This value is multiplied by the size\n    of the geometry and is scale invariant."], "extent": [8853, 9027]}], "container": true, "attrs": {"id": "sdf_tol"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Sign Sweep Threshold"], "extent": [7441, 7463], "body": [{"type": "para", "indent": 4, "text": ["After the fix signs process is complete there can still be\n    inconsistent areas in the SDF.  Large blocks can become\n    stabilized and stick out of the SDF.  A second sign sweep pass\n    can be performed to try to eliminate these blocks."], "extent": [7492, 7738]}, {"type": "para", "indent": 4, "text": ["The sign sweep threshold governs how big of a jump has to\n    occur for a sign transition to be considered inconsistent.  If\n    the values of the sdf change by more than this threshold times\n    the width of the cell, it is considered an invalid sign\n    transition.  The original geometry is then ray intersected to\n    determine inside/outside and the result used to determine\n    which sign is correct.  The correct sign is then propagated\n    forward through the model."], "extent": [7738, 8222]}], "container": true, "attrs": {"id": "sdf_sweepalpha"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Max Sign Sweep Count"], "extent": [8222, 8244], "body": [{"type": "para", "indent": 4, "text": ["The sign sweeps are repeated until no signs are flipped (ie,\n    all transitions are within the threshold) or this maximum is\n    reached.  Too low of a sign sweep threshold may prevent the\n    process from converging.  Otherwise, it tends to converge very\n    quickly."], "extent": [8273, 8548]}], "container": true, "attrs": {"id": "sdf_sweepcount"}, "role": "item"}], "container": true, "role": "item_group"}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Fracturing"], "extent": [2865, 2882], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Enable Fracturing"], "extent": [2882, 2902], "body": [{"type": "para", "indent": 4, "text": ["Allows fracturing for this object. The solver must also have fracturing enabled."], "extent": [2935, 3021]}], "container": true, "attrs": {"channels": "enablefracturing"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Fracture Threshold"], "extent": [3021, 3041], "body": [{"type": "para", "indent": 4, "text": ["The relative amount of stress in any direction above which dynamic fracturing will occur."], "extent": [3075, 3171]}], "container": true, "attrs": {"channels": "fracturethreshold"}, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Drag"], "extent": [3171, 3182], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Normal Drag"], "extent": [15, 28], "body": [{"type": "para", "indent": 4, "text": ["The component of drag in the directions normal to the surface.  Increasing this will make the object go along with any wind that blows against it. For realistic wind interaction, the Normal Drag should be chosen larger (about 10 times larger) than the tangent drag."], "extent": [56, 327]}], "container": true, "attrs": {"channels": "/normaldrag"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Tangent Drag"], "extent": [327, 341], "body": [{"type": "para", "indent": 4, "text": ["The component of drag in the direction tangent to the surface.  Increasing\n    this will make the object go along with any wind that blows tangent to the\n    object."], "extent": [370, 541]}], "container": true, "attrs": {"channels": "/tangentdrag"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["External Velocity Field"], "extent": [541, 566], "body": [{"type": "para", "indent": 4, "text": ["The name of the external velocity fields on affectors that the object will\n    respond to. The default is ", {"type": "code", "text": ["vel"]}, ", which will make the object react to fluids\n    and smoke when the ", {"type": "ui", "text": ["Tangent Drag"]}, " and the ", {"type": "ui", "text": ["Normal Drag"]}, " have been\n    chosen sufficiently large. The ", {"type": "ui", "text": ["Tangent Drag"]}, " and ", {"type": "ui", "text": ["Normal Drag"]}, " forces\n    are computed by comparing the object\u2019s velocity with the external velocity."], "extent": [605, 999]}], "container": true, "attrs": {"channels": "/externalvelocityfield"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["External Velocity Offset"], "extent": [999, 1025], "body": [{"type": "para", "indent": 4, "text": ["This offset is added to any velocity that\u2019s read from the velocity field.\n    When there\u2019s no velocity field, then the offset can be used to create a\n    wind force which has constant velocity everywhere. This wind effect is\n    more realistic and more accurate than the wind that is generated by DOP\n    Forces."], "extent": [1065, 1382]}], "container": true, "attrs": {"channels": "/externalvelocityoffset"}, "role": "item"}], "container": true}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Attributes"], "extent": [3223, 3240], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Create Quality Attributes"], "extent": [0, 27], "body": [{"type": "para", "indent": 4, "text": ["This creates a primitive attribute 'quality' on the simulated geometry. The worst quality is 0, the best quality is 1. The better the quality of the primitives, the better the performance and stability of the solve will be."], "extent": [61, 290]}], "container": true, "attrs": {"id": "createqualityattributes"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Create Energy Attributes"], "extent": [290, 316], "body": [{"type": "para", "indent": 4, "text": ["This toggle allow the object to generate attributes that indicate the density of kinetic energy and potential energy. In addition, an attribute that indicates the density of the rate of energy loss is generated."], "extent": [349, 566]}], "container": true, "attrs": {"id": "createenergyattributes"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Create Force Attributes"], "extent": [566, 591], "body": [{"type": "para", "indent": 4, "text": ["This toggle allows force attributes to be generated."], "extent": [623, 681]}], "container": true, "attrs": {"id": "createforceattributes"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Create Collision Attributes"], "extent": [681, 710], "body": [], "container": true, "attrs": {"id": "createcollisionattributes"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Create Fracture Attributes"], "extent": [746, 774], "body": [], "container": true, "attrs": {"id": "createfractureattributes"}, "role": "item"}], "container": true}]}, {"level": 2, "id": "visualization", "container": true, "type": "h", "indent": 0, "text": ["Visualization"], "extent": [3291, 3327], "body": []}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Creation"], "extent": [3327, 3344], "body": [{"type": "include_group", "body": [{"ext": "standard_objcreation_parms", "type": "include", "indent": 4, "role": "item", "extent": [3344, 3392]}], "container": true, "role": "item_group"}]}, {"level": 2, "id": "attrib", "container": true, "type": "h", "indent": 0, "text": ["Attributes"], "extent": [3392, 3418], "body": [{"type": "include_group", "body": [{"ext": "standard_clothobject_attribs", "type": "include", "indent": 4, "role": "item", "extent": [3418, 3464]}], "container": true, "role": "item_group"}]}], "text": "Parameters"}, {"level": 1, "id": "locals", "container": true, "type": "locals_section", "indent": 0, "role": "section", "extent": [3464, 3472], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["ST"], "extent": [16, 20], "body": [{"type": "para", "indent": 4, "text": ["This value is the simulation time for which the node is being\n    evaluated. "], "extent": [20, 107]}, {"type": "para", "indent": 4, "text": ["This value may not be equal to the current Houdini time\n    represented by the variable T, depending on the settings of the ", {"scheme": "Node", "value": "/nodes/obj/dopnet", "type": "link", "text": ["DOP\n    Network"], "fullpath": "/nodes/obj/dopnet"}, " ", {"type": "ui", "text": ["Offset Time"]}, " and ", {"type": "ui", "text": ["Time Scale"]}, "\n    parameters. "], "extent": [107, 326]}, {"type": "para", "indent": 4, "text": ["This value is guaranteed to have a value of zero at the\n    start of a simulation, so when testing for the first timestep of a\n    simulation, it is best to use a test like ", {"type": "code", "text": ["$ST == 0"]}, " rather than\n    ", {"type": "code", "text": ["$T == 0"]}, " or ", {"type": "code", "text": ["$FF == 1"]}, "."], "extent": [326, 555]}], "container": true}, {"type": "dt", "indent": 0, "text": ["SF"], "extent": [555, 559], "body": [{"type": "para", "indent": 4, "text": ["This value is the simulation frame (or more accurately, the\n    simulation time step number) for which the node is being evaluated."], "extent": [559, 700]}, {"type": "para", "indent": 4, "text": ["This value may not be equal to the current Houdini frame number\n    represented by the variable F, depending on the settings of the ", {"scheme": "Node", "value": "/nodes/obj/dopnet", "type": "link", "text": ["DOP\n    Network"], "fullpath": "/nodes/obj/dopnet"}, " parameters. Instead, this value is equal to\n    the simulation time (ST) divided by the simulation timestep size\n    (TIMESTEP)."], "extent": [700, 999]}], "container": true}, {"type": "dt", "indent": 0, "text": ["TIMESTEP"], "extent": [999, 1009], "body": [{"type": "para", "indent": 4, "text": ["This value is the size of a simulation timestep. This value is\n    useful to scale values that are expressed in units per second, but\n    are applied on each timestep."], "extent": [1009, 1181]}], "container": true}, {"type": "dt", "indent": 0, "text": ["SFPS"], "extent": [1181, 1187], "body": [{"type": "para", "indent": 4, "text": ["This value is the inverse of the TIMESTEP value. It is the number\n    of timesteps per second of simulation time."], "extent": [1187, 1305]}], "container": true}, {"type": "dt", "indent": 0, "text": ["SNOBJ"], "extent": [1305, 1312], "body": [{"type": "para", "indent": 4, "text": ["This is the number of objects in the simulation. For nodes that\n    create objects such as the ", {"scheme": "Node", "value": "/nodes/dop/emptyobject", "type": "link", "text": ["Empty Object"], "fullpath": "/nodes/dop/emptyobject"}, " node,\n    this value will increase for each object that is evaluated. "], "extent": [1312, 1523]}, {"type": "para", "indent": 4, "text": ["A good way to guarantee unique object names is to use an expression\n    like ", {"type": "code", "text": ["object_$SNOBJ"]}, "."], "extent": [1523, 1621]}], "container": true}, {"type": "dt", "indent": 0, "text": ["NOBJ"], "extent": [1621, 1627], "body": [{"type": "para", "indent": 4, "text": ["This value is the number of objects that will be evaluated by the\n    current node during this timestep. This value will often be\n    different from SNOBJ, as many nodes do not process all the objects\n    in a simulation. "], "extent": [1627, 1859]}, {"type": "para", "indent": 4, "text": ["This value may return 0 if the node does not\n    process each object sequentially (such as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group\n    DOP"], "fullpath": "/nodes/dop/group"}, ")."], "extent": [1859, 1991]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OBJ"], "extent": [1991, 1996], "body": [{"type": "para", "indent": 4, "text": ["This value is the index of the specific object being processed by\n    the node. This value will always run from zero to NOBJ-1 in a given\n    timestep. This value does not identify the current object within the\n    simulation like OBJID or OBJNAME, just the object\u2019s position in the\n    current order of processing. "], "extent": [1996, 2322]}, {"type": "para", "indent": 4, "text": ["This value is useful for generating a\n    random number for each object, or simply splitting the objects into\n    two or more groups to be processed in different ways. This value\n    will be -1 if the node does not process objects sequentially (such\n    as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group DOP"], "fullpath": "/nodes/dop/group"}, ")."], "extent": [2322, 2616]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OBJID"], "extent": [2616, 2623], "body": [{"type": "para", "indent": 4, "text": ["This is the unique object identifier for the object being\n    processed. Every object is assigned an integer value that is unique\n    among all objects in the simulation for all time. Even if an object\n    is deleted, its identifier is never reused. "], "extent": [2623, 2883]}, {"type": "para", "indent": 4, "text": ["The object identifier\n    can always be used to uniquely identify a given object. This makes\n    this variable very useful in situations where each object needs to\n    be treated differently. It can be used to produce a unique random\n    number for each object, for example. "], "extent": [2883, 3168]}, {"type": "para", "indent": 4, "text": ["This value is also the best way\n    to look up information on an object using the dopfield expression\n    function. This value will be -1 if the node does not process objects\n    sequentially (such as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group DOP"], "fullpath": "/nodes/dop/group"}, ")."], "extent": [3168, 3406]}], "container": true}, {"type": "dt", "indent": 0, "text": ["ALLOBJIDS"], "extent": [3406, 3417], "body": [{"type": "para", "indent": 4, "text": ["This string contains a space separated list of the unique object\n    identifiers for every object being processed by the current node."], "extent": [3417, 3556]}], "container": true}, {"type": "dt", "indent": 0, "text": ["ALLOBJNAMES"], "extent": [3556, 3569], "body": [{"type": "para", "indent": 4, "text": ["This string contains a space separated list of the names of every\n    object being processed by the current node."], "extent": [3569, 3687]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OBJCT"], "extent": [3687, 3694], "body": [{"type": "para", "indent": 4, "text": ["This value is the simulation time (see variable ST) at which the\n    current object was created. "], "extent": [3694, 3801]}, {"type": "para", "indent": 4, "text": ["Therefore, to check if an object was created\n    on the current timestep, the expression ", {"type": "code", "text": ["$ST == $OBJCT"]}, " should\n    always be used. This value will be zero if the node does not process\n    objects sequentially (such as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group DOP"], "fullpath": "/nodes/dop/group"}, ")."], "extent": [3801, 4057]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OBJCF"], "extent": [4057, 4064], "body": [{"type": "para", "indent": 4, "text": ["This value is the simulation frame (see variable SF) at which the\n    current object was created. "], "extent": [4064, 4172]}, {"type": "para", "indent": 4, "text": ["This value is equivalent to using the\n    dopsttoframe expression on the OBJCT variable. This value will be\n    zero if the node does not process objects sequentially (such as the\n    ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group DOP"], "fullpath": "/nodes/dop/group"}, ")."], "extent": [4172, 4389]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OBJNAME"], "extent": [4389, 4398], "body": [{"type": "para", "indent": 4, "text": ["This is a string value containing the name of the object being\n    processed. "], "extent": [4398, 4486]}, {"type": "para", "indent": 4, "text": ["Object names are not guaranteed to be unique within a\n    simulation. However, if you name your objects carefully so that they\n    are unique, the object name can be a much easier way to identify an\n    object than the unique object identifier, OBJID. "], "extent": [4486, 4748]}, {"type": "para", "indent": 4, "text": ["The object name can\n    also be used to treat a number of similar objects (with the same\n    name) as a virtual group. If there are 20 objects named ", {"type": "q", "text": ["myobject"]}, ",\n    specifying ", {"type": "code", "text": ["strcmp($OBJNAME, \"myobject\") == 0"]}, " in the activation field\n    of a DOP will cause that DOP to operate only on those 20 objects. This\n    value will be the empty string if the node does not process objects\n    sequentially (such as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group DOP"], "fullpath": "/nodes/dop/group"}, ")."], "extent": [4748, 5194]}], "container": true}, {"type": "dt", "indent": 0, "text": ["DOPNET"], "extent": [5194, 5202], "body": [{"type": "para", "indent": 4, "text": ["This is a string value containing the full path of the current DOP\n    Network. This value is most useful in DOP subnet digital assets\n    where you want to know the path to the DOP Network that contains the\n    node."], "extent": [5202, 5425]}], "container": true}], "container": true}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [5425, 5431], "body": [{"type": "para", "indent": 4, "text": ["Most dynamics nodes have local variables with the same names as the\n    node\u2019s parameters. For example, in a ", {"scheme": "Node", "value": "/nodes/dop/position", "type": "link", "text": ["Position node"], "fullpath": "/nodes/dop/position"}, ",\n    you could write the expression:"], "extent": [5431, 5620]}, {"lang": null, "type": "pre", "indent": 4, "text": ["\n    $tx + 0.1\n    "], "extent": [5620, 5650]}, {"type": "para", "indent": 4, "text": ["\u2026to make the object move 0.1 units along the X axis at each timestep."], "extent": [5650, 5730]}], "container": true}], "container": true, "role": "item_group"}], "text": "Locals"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [3501, 3510], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/dop/femsolidconfigureobject", "type": "link", "text": "", "fullpath": "/nodes/dop/femsolidconfigureobject"}], "extent": [3510, 3548]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/dop/femsolver", "type": "link", "text": "", "fullpath": "/nodes/dop/femsolver"}], "extent": [3548, 3572]}], "container": true}], "text": "Related"}], "title": ["FEM Solid Object"], "summary": ["Creates a simulated FEM solid from geometry."], "included": ["/nodes/dop/standard_embedding_parms", "/nodes/dop/standard_febody_parms", "/nodes/dop/standard_feinitial_parms", "/nodes/dop/standard_feoutputattributes_parms", "/nodes/dop/standard_ferest_parms", "/nodes/dop/standard_fesolid_parms", "/nodes/dop/standard_fetarget_parms", "/nodes/dop/standard_locals", "/nodes/dop/standard_rbdvolume_parms", "/nodes/dop/standard_softbodydrag_parms", "/nodes/dop/standard_solidcollision_parms"]}