{"type": "root", "attrs": {"type": "node", "context": "dop", "internal": "geometrywrangle", "icon": "DOP/geometrywrangle", "tags": "volumes", "since": "13.0", "version": null, "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Geometry Wrangle"], "extent": [0, 21]}, {"type": "summary", "indent": 0, "text": ["Runs a VEX snippet to modify attribute values."], "extent": [131, 185]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Overview"], "extent": [185, 200], "body": [{"type": "para", "indent": 0, "text": ["This is a very powerful, low-level node that lets experts who are\nfamiliar with VEX tweak attributes using code."], "extent": [200, 315]}, {"type": "para", "indent": 0, "text": ["This node corresponds to the ", {"scheme": "Node", "value": "/nodes/dop/geometryvop", "type": "link", "text": ["Geometry VOP DOP"], "fullpath": "/nodes/dop/geometryvop"}, ",\nbut uses a textual VEX snippet instead of a VOP network."], "extent": [315, 443]}, {"type": "para", "indent": 0, "text": ["This node ", {"type": "em", "text": ["runs the snippet on the detail or every point/primitive/vertex"]}, "\n(depending on the ", {"type": "ui", "text": ["Run Over"]}, " parameter) in the input geometry.\nThe snippet can edit the input geometry by changing attributes.\nIt can access information from other geometry using attributes and VEX functions."], "extent": [443, 730]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["Press ", {"keys": ["MMB"], "type": "keys", "text": null}, " on the node to see any error output from the snippet."], "extent": [730, 801]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You can use the VEX function ", {"type": "code", "text": ["ch"]}, " to evaluate parameters.\n  The path is relative to this node (", {"type": "code", "text": ["ch(\"parm\")"]}, " will evaluate the parameter ", {"type": "code", "text": ["parm"]}, " on this node).\n  This evaluation will be done at the current time."], "extent": [801, 1014]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Unlike the ", {"scheme": "Node", "value": "/nodes/sop/attribcreate", "type": "link", "text": ["Attrib Create SOP"], "fullpath": "/nodes/sop/attribcreate"}, ", this does not use local variables.\n  Further, all backtick expressions and ", {"type": "code", "text": ["$F"]}, " variables will be evaluated at frame 1,\n  not the current time.\n  Use ", {"type": "code", "text": ["@Frame"]}, ", ", {"type": "code", "text": ["@Time"]}, ", or ", {"type": "code", "text": ["@TimeInc"]}, " instead."], "extent": [1014, 1264]}], "container": true}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Context"], "extent": [1264, 1278], "body": [{"type": "para", "indent": 0, "text": ["This node runs the snippet in the ", {"type": "strong", "text": ["CVEX context"]}, "."], "extent": [1278, 1331]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Syntax"], "extent": [1331, 1344], "body": [{"type": "para", "indent": 0, "text": ["The ", {"type": "ui", "text": ["VEX snippet"]}, " parameter lets you enter a snippet of ", {"scheme": null, "value": "/vex/", "type": "link", "text": ["VEX code"], "fullpath": "/vex/index"}, " to run on the input geometry.\nSee ", {"scheme": null, "value": "/vex/snippets", "type": "link", "text": ["VEX snippets"], "fullpath": "/vex/snippets"}, " for basic information on the syntax available in the snippet parameter.\nSee ", {"scheme": null, "value": "/vex/", "type": "link", "text": ["the VEX chapter"], "fullpath": "/vex/index"}, " for general information on the VEX language."], "extent": [16, 299]}]}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [1383, 1395], "body": [{"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Code"], "extent": [1395, 1407], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Group"], "extent": [1407, 1415], "body": [{"type": "para", "indent": 8, "text": ["A subset of points in the input geometry to run the program on.\n        Leave this blank to affect all points in the input.\n        The type of group must match the ", {"type": "ui", "text": ["Run Over"]}, " parameter."], "extent": [1415, 1613]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Run Over"], "extent": [16, 26], "body": [{"type": "para", "indent": 4, "text": ["Apply the VEX code to each component of this type (points, primitives/faces, or vertices. Or choose ", {"type": "ui", "text": ["Detail"]}, " to run the code only once. For each component, the code runs with attributes bound to variables starting with ", {"type": "code", "text": ["@"]}, " (for example ", {"type": "code", "text": ["@Cd"]}, ") for reading and writing."], "extent": [42, 317]}, {"type": "para", "indent": 4, "text": ["If you choose ", {"type": "code", "text": ["Numbers"]}, ", Houdini runs the code for certain number of iterations instead of over components. In this mode the code only has read-only detail-level attributes bound to ", {"type": "code", "text": ["@"]}, " variables."], "extent": [317, 519]}], "container": true, "attrs": {"id": "class"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Number Count"], "extent": [519, 533], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Run Over"]}, " is ", {"type": "ui", "text": ["Numbers"]}, ", the number of iterations to run the code. In each iteration, ", {"type": "code", "text": ["@numelem"]}, " is bound to this total count, and ", {"type": "code", "text": ["@elemnum"]}, " is bound to the iteration number, from ", {"type": "code", "text": ["0"]}, " to ", {"type": "code", "text": ["@numelem - 1"]}, ". "], "extent": [556, 775]}, {"type": "para", "indent": 4, "text": ["In this mode the code only has read-only detail-level attributes bound to ", {"type": "code", "text": ["@"]}, " variables."], "extent": [775, 869]}], "container": true, "attrs": {"id": "vex_numcount"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Thread Job Size"], "extent": [869, 886], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Run Over"]}, " is ", {"type": "ui", "text": ["Numbers"]}, ", this is the number of iterations to run per separate thread. If this number is greater than or equal the ", {"type": "ui", "text": ["Number count"]}, ", all iterations will run serially in a single thread. If this is ", {"type": "code", "text": ["1"]}, ", each iteration will run in a separate thread. In between, the node will group the iterations into batches of this size, and run each batch in parallel on separate threads."], "extent": [914, 1316]}], "container": true, "attrs": {"id": "vex_threadjobsize"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["VEXpression"], "extent": [2337, 2350], "body": [{"type": "para", "indent": 4, "text": ["A snippet of VEX code that will manipulate the point attributes.\n    You can use ", {"type": "code", "text": ["@", {"type": "var", "text": ["variable_name"]}]}, " syntax to access geometry attributes."], "extent": [2368, 2513]}], "container": true, "attrs": {"id": "snippet"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Attributes to Create"], "extent": [1688, 1710], "body": [{"type": "para", "indent": 8, "text": ["Only create attributes if their names match this pattern.\n        The default pattern allows any attribute to be created."], "extent": [1710, 1849]}, {"type": "para", "indent": 8, "text": ["You can restrict the created attributes by replacing the ", {"type": "code", "text": ["*"]}, " with a list of allowed names."], "extent": [1849, 1949]}, {"type": "para", "indent": 8, "text": ["Bound attributes, such as ", {"type": "code", "text": ["vtxnum"]}, ", cannot be created and will be ignored."], "extent": [1949, 2033]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Enforce Prototypes"], "extent": [16, 36], "body": [{"type": "para", "indent": 4, "text": ["Requires that you declare ", {"type": "code", "text": ["@"]}, " bindings in snippets as prototypes before using them. This applies to both attributes (for example ", {"type": "code", "text": ["@Cd"]}, ") and ", {"type": "q", "text": ["convenience"]}, " bindings such as ", {"type": "code", "text": ["@ptnum"]}, " and ", {"type": "code", "text": ["@Frame"]}, ". For example:"], "extent": [36, 248]}, {"lang": "vex", "type": "pre", "indent": 4, "text": ["\n    // Declare bindings\n    int @ptnum;\n    float @Frame;\n    vector @Cd;\n\n    // Use bindings after declaration\n    int pointnum = @ptnum;\n    float red = @Cd[0] / @Frame;\n    "], "extent": [248, 447]}, {"type": "para", "indent": 4, "text": ["Automatic binding with the ", {"type": "code", "text": ["@"]}, " syntax can be convenient, but as your scene becomes more complex there is the risk that a typo in an ", {"type": "code", "text": ["@"]}, " binding will silently just bind a non-existent attribute."], "extent": [447, 646]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Use Timestep"], "extent": [15, 29], "body": [{"type": "para", "indent": 4, "text": ["Determines if the current solver timestep will be used to apply\n    this node.  "], "extent": [29, 119]}, {"type": "para", "indent": 4, "text": ["If set, the current timestep size will be multiplied\n    by the scale and used for the time increment for this operation.\n    Otherwise, the time scale will specify an absolute fictitious time\n    to integrate by."], "extent": [119, 338]}, {"type": "para", "indent": 4, "text": ["By disabling the link between the actual real time and the\n    microsolver time, you can perform operations in a separate,\n    fictitious, time."], "extent": [338, 487]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Time Scale"], "extent": [487, 499], "body": [{"type": "para", "indent": 4, "text": ["The timestep used for this microsolver will be scaled by this\n    amount.  This allows one to achieve non-realistic effects, such as\n    parts of the simulation operating at different speeds than other\n    parts.  "], "extent": [499, 723]}, {"type": "para", "indent": 4, "text": ["Similarly, it is useful if a solver needs to be evaluated\n    independently of the main timestep."], "extent": [723, 825]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Data Bindings"], "extent": [2102, 2122], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Geometry"], "extent": [2122, 2133], "body": [{"type": "para", "indent": 8, "text": ["The list of the geometry on the object to process."], "extent": [2133, 2193]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Evaluation Node Path"], "extent": [2193, 2215], "body": [{"type": "para", "indent": 8, "text": ["VEX functions like ", {"type": "code", "text": ["ch()"]}, " usually evaluate with respect to this node.\n        Providing a path here can override where the path search starts\n        from.  This is useful for embedding in a digital asset where you\n        would like the top level digital asset to be the search root."], "extent": [2215, 2513]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Time Scale"], "extent": [2513, 2525], "body": [{"type": "para", "indent": 8, "text": ["An overall scale applied to the actual timestep."], "extent": [2525, 2583]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Export Parameters"], "extent": [2583, 2602], "body": [{"type": "para", "indent": 8, "text": ["When a VEX parameter is exported, the bound attribute will be\n        created if it doesn\u2019t exist.  This pattern can be used to override\n        the export option on the VEX shader to avoid writing to or creating\n        certain attributes.  The pattern matches the VEX parameter, not\n        the bound attribute.  The attribute will still be bound for\n        reading."], "extent": [2602, 2981]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Autobind by Name"], "extent": [2981, 2999], "body": [{"type": "para", "indent": 8, "text": ["Will use the name of the attribute to determine which\n        attribute binds with which parameter.  "], "extent": [2999, 3110]}, {"type": "para", "indent": 8, "text": ["Integer attributes will bind to integer parameters.  Float\n        attributes will bind to float, vector, point, matrix, or matrix4\n        depending on their tuple size.  String attributes will bind to\n        strings."], "extent": [3110, 3339]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Attribute Name, VEX Parameter"], "extent": [3339, 3370], "body": [{"type": "para", "indent": 8, "text": ["Manually specifies the bindings of each attribute.  "], "extent": [3370, 3432]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Field Name, VEX Parameter"], "extent": [3432, 3459], "body": [{"type": "para", "indent": 8, "text": ["Optionally binds Scalar, Vector, Matrix, or Index fields from this\n        object to the CVEX function.  They will be sampled at the current ", {"type": "code", "text": ["P"]}, "\n        location of each element."], "extent": [3459, 3647]}, {"type": "para", "indent": 8, "text": ["You can then access these with the @ syntax referring to the given Parameter."], "extent": [3647, 3734]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Autobind Groups by Name"], "extent": [3734, 3759], "body": [{"type": "para", "indent": 8, "text": ["Automatically bind any groups to the integer parameter prefixed with ", {"type": "code", "text": ["group_"]}, "."], "extent": [3759, 3847]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Group Name, VEX Parameter"], "extent": [3847, 3874], "body": [{"type": "para", "indent": 8, "text": ["Manually specifies the bindings of each group."], "extent": [3874, 3930]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Update Normals If Displaced"], "extent": [3930, 3959], "body": [{"type": "para", "indent": 8, "text": ["If points are being run over, and the ", {"type": "code", "text": ["P"]}, " attribute is written to,\n        but the ", {"type": "code", "text": ["N"]}, " attribute is not written to, any incoming normals will\n        become out of date.  When this option is set, vertex and point\n        normals will be updated when this occurs."], "extent": [3959, 4231]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["VEX Precision"], "extent": [3868, 3883], "body": [{"type": "para", "indent": 4, "text": ["VEX can evaluate at 32-bit or 64-bit precision.  64-bit provides\n    higher accuracy, especially for transforms."], "extent": [3906, 4028]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [4028, 4038], "body": [{"type": "para", "indent": 8, "text": ["Incoming attributes will preserve their original precision, so using 64-bit VEX on 32-bit positions will convert them to 64-bit, apply the operation, then convert back to 32-bit when writing out."], "extent": [4038, 4247]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 4, "text": ["The auto mode will switch between 32-bit and 64-bit depending on the preferred precision of the incoming geometry. When run in 64-bit precision, any created attributes will be 64-bit. When run in 32-bit any created attributes will be 32-bit. Use ", {"scheme": "Node", "value": "/nodes/sop/attribcast", "type": "link", "text": "", "fullpath": "/nodes/sop/attribcast"}, " to change the preferred precision."], "extent": [4247, 4556]}], "container": true, "attrs": {"id": "vex_precision"}, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Inputs"], "extent": [4279, 4292], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Input 1, 2, 3, 4"], "extent": [4292, 4311], "body": [{"type": "para", "indent": 8, "text": ["These control the four virtual inputs accessible inside of VOPs."], "extent": [4311, 4385]}, {"type": "para", "indent": 8, "text": ["They can be accessed with the OpInput1-4 wires from the VOP, or with\n        the ", {"type": "code", "text": ["@OpInput1-4"]}, " string parameters when using VEXpressions."], "extent": [4385, 4532]}, {"type": "para", "indent": 8, "text": ["They can also be accessed numerically as 0-3 with VEX functions\n        that take an input number."], "extent": [4532, 4640]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 8, "text": ["None"], "extent": [4640, 4654], "body": [{"type": "para", "indent": 12, "text": ["No geometry is wired to this input."], "extent": [4654, 4702]}], "container": true}, {"type": "dt", "indent": 8, "text": ["SOP"], "extent": [4702, 4715], "body": [{"type": "para", "indent": 12, "text": ["The SOP geometry will be cooked prior to running the VEX and\n            the result wired to this input."], "extent": [4715, 4832]}], "container": true}, {"type": "dt", "indent": 8, "text": ["DOP Data"], "extent": [4832, 4850], "body": [{"type": "para", "indent": 12, "text": ["Data in the current simulation to reference.  Specified as\n            an object/data, for example, ", {"type": "code", "text": ["pyro1/vel"]}, " to refer to the velocity\n            field of the ", {"type": "code", "text": ["pyro1"]}, " object (which will show up as three volume\n            primitives)."], "extent": [4850, 5100]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Myself"], "extent": [5100, 5116], "body": [{"type": "para", "indent": 12, "text": ["Referring to the geometry currently being processed is\n            special as you have to ensure a copy is made so the VEX\n            functions can refer to its original form.  This handles\n            that for you."], "extent": [5116, 5345]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Nth Context Geometry"], "extent": [5345, 5375], "body": [{"type": "para", "indent": 12, "text": ["These refer to the SOPs wired into the parent DOP Network itself."], "extent": [5375, 5453]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Myself (No Reads from Outputs)"], "extent": [5453, 5493], "body": [{"type": "para", "indent": 12, "text": ["Refers the currently processed geometry.  Does not make a copy\n            so it is up to the user to ensure no reads are made from\n            any attributes that are bound."], "extent": [5493, 5681]}], "container": true}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["SOP Path"], "extent": [5958, 5968], "body": [{"type": "para", "indent": 4, "text": ["Path to a SOP to wire in."], "extent": [5990, 6021]}], "container": true, "attrs": {"id": "bindgeoinput"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["DOP Data"], "extent": [6021, 6031], "body": [{"type": "para", "indent": 4, "text": ["Object/data path of a piece of DOP data in THIS simulation to wire in.\n    If ", {"type": "ui", "text": ["Use This Object\u2019s Data"]}, " is enabled, this specifies the data path for data attached to the currently solved object."], "extent": [6053, 6254]}], "container": true, "attrs": {"id": "binddopinput"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Use This Object\u2019s Data"], "extent": [6254, 6278], "body": [{"type": "para", "indent": 4, "text": ["When enabled, the ", {"type": "ui", "text": ["DOP Data"]}, " specifies the name of data attached to the currently solved object.\n    This is usually equivalent to ", {"type": "code", "text": ["$OBJID/DataName"]}, ", but using ", {"type": "code", "text": ["$OBJID"]}, " requires one to set the ", {"type": "ui", "text": ["Solver Per Object"]}, " toggle which prevents mutual affectors from working with solvers such as RBD.\n    If the referenced data is the geometry being currently processed, a copy is made (similar to the ", {"type": "ui", "text": ["Myself"]}, " binding option)."], "extent": [6302, 6731]}], "container": true, "attrs": {"id": "binddopuseself"}, "role": "item"}], "container": true, "role": "item_group"}]}], "text": "Parameters"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [5824, 5833], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/dop/geometryvop", "type": "link", "text": "", "fullpath": "/nodes/dop/geometryvop"}], "extent": [5833, 5859]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/dop/gasfieldvop", "type": "link", "text": "", "fullpath": "/nodes/dop/gasfieldvop"}], "extent": [5859, 5884]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/dop/gasfieldwrangle", "type": "link", "text": "", "fullpath": "/nodes/dop/gasfieldwrangle"}], "extent": [5884, 5913]}], "container": true}], "text": "Related"}], "title": ["Geometry Wrangle"], "summary": ["Runs a VEX snippet to modify attribute values."], "included": ["/nodes/dop/geometryvop", "/nodes/dop/standard_data_inputs", "/nodes/dop/standard_data_outputs", "/nodes/dop/standard_datagroup_parms", "/nodes/dop/standard_dataname_parms", "/nodes/dop/standard_dataop_parms", "/nodes/dop/standard_gas_timestep", "/nodes/dop/standard_solver_mutualparms", "/nodes/dop/standard_solver_parms", "/nodes/sop/_run_over", "/nodes/sop/pointwrangle", "/nodes/sop/wrangle_syntax", "/vex/_enforce_prototypes"]}