{"type": "root", "attrs": {"type": "node", "context": "dop", "internal": "popgrains", "icon": "DOP/sandsolver", "since": "13.5", "version": null, "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["POP Grains"], "extent": [83, 98]}, {"type": "summary", "indent": 0, "text": ["A POP node that applies sand grain interaction to particles."], "extent": [98, 168]}, {"type": "para", "indent": 0, "text": ["The POP Grains node treats the particles as small spheres and applies\ninteraction between them.  This allows for interpenetration prevention,\ncohesion, and even explicit constraints to be enforced."], "extent": [168, 367]}, {"type": "para", "indent": 0, "text": ["Unlike ", {"scheme": "Node", "value": "/nodes/dop/popinteract", "type": "link", "text": ["POP Interact"], "fullpath": "/nodes/dop/popinteract"}, ", which uses forces to prevent particles from penetrating, the POP Grains uses a Position Based Dynamics approach to directly move the particles apart.  This approach allows for a more stable enforcement of the constraints without the sort of explosions that very high forces would induce."], "extent": [367, 700]}, {"type": "para", "indent": 0, "text": ["This operator directly modifies the ", {"type": "code", "text": ["P"]}, " attribute to move the points and the ", {"type": "code", "text": ["v"]}, " attribute to reflect how they moved."], "extent": [700, 819]}, {"type": "para", "indent": 0, "text": ["Particles under control of POP Grains have the ", {"type": "code", "text": ["ispbd"]}, " attribute set to 1.  This causes them to not perform normal movement update in the ", {"scheme": "Node", "value": "/nodes/dop/popsolver", "type": "link", "text": ["POP Solver"], "fullpath": "/nodes/dop/popsolver"}, ", as the actual motion update is done in this node."], "extent": [819, 1041]}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [1041, 1047], "body": [{"type": "para", "indent": 4, "text": ["If insufficient substeps or constraint iterations are performed, the solver reacts by under-enforcing constraints.  This results in bouncy or collapsing behavior, as if the corresponding stiffness values were much lower.  Thus, if stiffness is higher than supported, increasing substeps or constraint iterations will change the look and make the simulation stiffer."], "extent": [1047, 1418]}, {"type": "para", "indent": 4, "text": ["An approximate maximum stiffness value is substeps times constraint iterations.  To increase stiffness beyond this, more substeps or constraint iterations are required."], "extent": [1418, 1592]}], "container": true}, {"type": "note", "indent": 0, "role": "item", "extent": [1592, 1598], "body": [{"type": "para", "indent": 4, "text": ["Weights are in the 0 to 1 range.  For the system to be guaranteed stable, the sum of all active weights should be 1. However, in practice, merely keeping each individual weight below one is effective and provides better behavior with fewer substeps."], "extent": [1598, 1853]}, {"type": "para", "indent": 4, "text": ["Weights over 1 can be used to accelerate convergence, but are likely to cause particles to explode or jitter."], "extent": [1853, 1968]}, {"type": "para", "indent": 4, "text": ["Controlling individual particle behavior through the weight attributes is faster than through the stiffness attributes, but is not scaled by timesteps nor iterations, so should usually only be done in an all-or-nothing manner.  If not, behavior will change significantly with changing substeps or iterations."], "extent": [1968, 2282]}], "container": true}, {"type": "note", "indent": 0, "role": "item", "extent": [2282, 2288], "body": [{"type": "para", "indent": 4, "text": ["Friction is proportional to particle overlap.  Thus smaller particles, with inherently smaller overlap, will have less friction effects."], "extent": [2288, 2430]}, {"type": "para", "indent": 4, "text": ["This also means if the particle-particle constraint isn\u2019t stiff, i.e. overlap is not resolved swiftly, friction will be considerably stronger."], "extent": [2430, 2578]}, {"type": "para", "indent": 4, "text": ["Increasing constraint iterations can also increase the effective friction."], "extent": [2578, 2658]}], "container": true}, {"type": "note", "indent": 0, "role": "item", "extent": [2658, 2664], "body": [{"type": "para", "indent": 4, "text": ["If particles are highly stacked, it can take many iterations to resolve the pile.  Too few iterations will result in the pile ", {"type": "q", "text": ["bouncing"]}, ".  This also prevents the friction from triggering a stable stack.  ", {"type": "q", "text": ["Stacking height"]}, " in this case refers to how many particles are on top of each other, not the actual physical size of the stack."], "extent": [2664, 3002]}], "container": true}], "container": true, "role": "item_group"}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [3002, 3014], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Activation"], "extent": [45, 61], "body": [{"type": "para", "indent": 8, "text": ["Turns this node on and off. The node is only active if this\n        value is greater than 0. This is useful to control the effect of\n        this node with an ", {"scheme": null, "value": "/expressions/", "type": "link", "text": ["expression"], "fullpath": "/expressions/index"}, "."], "extent": [61, 265]}, {"type": "note_group", "body": [{"type": "note", "indent": 8, "role": "item", "extent": [265, 279], "body": [{"type": "para", "indent": 12, "text": ["This is activation of the node as a whole. You can\u2019t use this parameter to deactivate the node for certain particles."], "extent": [279, 410]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Group"], "extent": [410, 421], "body": [{"type": "para", "indent": 8, "text": ["Only affect a group of points (created with, for example, a\n        ", {"scheme": "Node", "value": "/nodes/dop/popgroup", "type": "link", "text": ["Group POP"], "fullpath": "/nodes/dop/popgroup"}, " or ", {"scheme": "Node", "value": "/nodes/dop/popcollisiondetect", "type": "link", "text": ["Collision\n        Detection POP"], "fullpath": "/nodes/dop/popcollisiondetect"}, ") out of all the points in \n        the current stream."], "extent": [421, 648]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Particle Separation"], "extent": [3060, 3085], "body": [{"type": "para", "indent": 8, "text": ["For the purpose of scaling parameters, this is taken to be the\n        average diameter of all particles.  Normally it can be linked to the\n        particle creation code to provide a central control for scene scale."], "extent": [3085, 3311]}, {"type": "para", "indent": 8, "text": ["The actual ", {"type": "code", "text": ["pscale"]}, " attribute on particles trumps this value,\n        this is mostly used as a hint for normalizing things like mass-shock\n        scale."], "extent": [3311, 3474]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Constraint Iterations"], "extent": [3474, 3501], "body": [{"type": "para", "indent": 8, "text": ["How many times to attempt to enforce the constraints in a single\n        substep.  Since all particles are enforced simultaneously, this must be\n        around the diameter of the system - ie, the expected stacking height of\n        the particles."], "extent": [3501, 3758]}, {"type": "para", "indent": 8, "text": ["In each iteration, particles only inspect their immediate neighbors.\n        Thus, if you have a pile ten particles high, the top particle will\n        only learn about the ground plane after ten iterations, making\n        ten the minimum usable constraint iteration value. In practice\n        doubling this is often required."], "extent": [3758, 4094]}], "container": true, "role": "item"}], "container": true}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 4, "text": ["Behavior"], "extent": [4094, 4113], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Assume Uniform Radius"], "extent": [4113, 4141], "body": [{"type": "para", "indent": 8, "text": ["The ", {"type": "code", "text": ["pscale"]}, " attribute is used to determine the radius of each\n        particle.  If all particles have the same radius, faster acceleration\n        structures can be used to find neighbors."], "extent": [4141, 4341]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 4, "text": ["Friction"], "extent": [4341, 4362], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["With Colliders"], "extent": [4362, 4383], "body": [{"type": "para", "indent": 8, "text": ["Particle-collider friction is scaled by this amount.  A value of 0 will result in the particles not sticking, and a value of 1 will result in the particles trying to match velocity if contacting."], "extent": [4415, 4620]}, {"type": "para", "indent": 8, "text": ["Scale with the ", {"type": "code", "text": ["friction"]}, " point attribute."], "extent": [4620, 4672]}, {"type": "note_group", "body": [{"type": "note", "indent": 8, "role": "item", "extent": [4672, 4686], "body": [{"type": "para", "indent": 12, "text": ["This does not respect the friction parameter or friction attributes\n            on the collision object."], "extent": [4686, 4804]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "collisionfriction"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["With Particles"], "extent": [4804, 4824], "body": [{"type": "para", "indent": 8, "text": ["Particle-particle friction is scaled by this amount.  A value of 0 will result in the particles not sticking, and a value of 1 will result in the particles trying to match velocity if contacting."], "extent": [4855, 5060]}, {"type": "para", "indent": 8, "text": ["Scale with the ", {"type": "code", "text": ["friction"]}, " point attribute."], "extent": [5060, 5112]}], "container": true, "attrs": {"id": "particlefriction"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Accurate Friction"], "extent": [5112, 5135], "body": [{"type": "para", "indent": 8, "text": ["If set, friction is applied every iteration of the constraint loop.\n        This makes for a stronger and more accurate friction that is better\n        able to stack grains."], "extent": [5164, 5347]}], "container": true, "attrs": {"id": "jacobifriction"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Static Threshold"], "extent": [5347, 5369], "body": [{"type": "para", "indent": 8, "text": ["The speed-vs-collision depth ratio at which particles will try to come\n        fully to rest within a constraint iteration."], "extent": [5400, 5533]}, {"type": "para", "indent": 8, "text": ["Multiply the depth a particle has sunk into a neighboring particle by\n        the speed the particle is going.  If the result is less than this\n        threshold, the particle is brought to rest (relative to the other\n        particle)"], "extent": [5533, 5778]}], "container": true, "attrs": {"id": "static_threshold"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Scale Kinetic"], "extent": [5778, 5797], "body": [{"type": "para", "indent": 8, "text": ["When outside of the static threshold, the relative velocity is\n        canceled proportional to this and the collision depth.  Higher\n        numbers will cause particles to swiftly lose tangential relative\n        motion if overlapping."], "extent": [5825, 6072]}], "container": true, "attrs": {"id": "kinetic_scale"}, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 4, "text": ["Internal Collisions"], "extent": [6072, 6104], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Weight"], "extent": [6104, 6116], "body": [{"type": "para", "indent": 8, "text": ["A weighting for how much the particle collision forces are weighted.\n        A value of zero will disable particle collision."], "extent": [6146, 6281]}, {"type": "para", "indent": 8, "text": ["Scale with the ", {"type": "code", "text": ["repulsionweight"]}, " point attribute."], "extent": [6281, 6340]}], "container": true, "attrs": {"id": "replusionweight"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Stiffness"], "extent": [6340, 6355], "body": [{"type": "para", "indent": 8, "text": ["How strongly particles are kept apart.  Higher values result in\n        less bouncy repulsion."], "extent": [6388, 6492]}, {"type": "para", "indent": 8, "text": ["Scale with the ", {"type": "code", "text": ["repulsionstiffness"]}, " point attribute."], "extent": [6492, 6554]}, {"type": "para", "indent": 8, "text": ["OpenCL does not support the ", {"type": "code", "text": ["repulsionstiffness"]}, " attribute."], "extent": [6554, 6623]}], "container": true, "attrs": {"id": "repulsionstiffness"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Enable Mass-Shock Scaling"], "extent": [6623, 6654], "body": [{"type": "para", "indent": 8, "text": ["Artificially scales the mass of particles according to their position\n        with respect to gravity.  By making particles higher up lighter,\n        stacks of particles will converge faster and be more stable."], "extent": [6654, 6875]}, {"type": "para", "indent": 8, "text": ["The Global method will add a ", {"type": "code", "text": ["shockmass"]}, " attribute which stores\n        the virtual mass of all particles prior to iterating.  It requires\n        a properly set origin to avoid overflow."], "extent": [6875, 7072]}, {"type": "para", "indent": 8, "text": ["The Local method will compute a relative mass scale on a just-in-time\n        basis.  The extra computation time is often made up for by not having\n        to read the attribute values.  Because of the approximation of\n        the exponential used, the effective shock scaling power is clamped to\n        approximately seven."], "extent": [7072, 7407]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Shock Scaling Power"], "extent": [7407, 7432], "body": [{"type": "para", "indent": 8, "text": ["The amount of scaling to perform.  Higher numbers increase the\n        contrast between successive particles.  A value of 0 will\n        cause no ratio between particles, a value of 1 a 15% ratio\n        between two particles stacked vertically."], "extent": [7432, 7687]}, {"type": "para", "indent": 8, "text": ["Too high a number makes higher particles extremely light\n        and destabilizes the system."], "extent": [7687, 7790]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Shock Axis"], "extent": [7790, 7806], "body": [{"type": "para", "indent": 8, "text": ["The up-vector used to define a gradient of particle masses."], "extent": [7806, 7875]}, {"type": "para", "indent": 8, "text": ["Should be in the direction of stacking, so usually is\n        opposite to that of gravity."], "extent": [7875, 7975]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Shock Origin"], "extent": [7975, 7993], "body": [{"type": "para", "indent": 8, "text": ["The rough center of the sand system.  Due to limits of floating point\n        representation, particles too far from this origin will be clamped\n        to min/maximum mass values.  A lower scaling power allows\n        for a larger range."], "extent": [7993, 8241]}, {"type": "para", "indent": 8, "text": ["The default values give a range of +/-580 particle separations\n        in the shock axis direction."], "extent": [8241, 8350]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 4, "text": ["Clumping"], "extent": [8350, 8371], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Weight"], "extent": [8371, 8384], "body": [{"type": "para", "indent": 8, "text": ["A weighting for how much the particles will naturally stick together\n        when close.  A value of zero will disable particle clumping."], "extent": [8415, 8562]}, {"type": "para", "indent": 8, "text": ["Scale with the ", {"type": "code", "text": ["attractionweight"]}, " point attribute."], "extent": [8562, 8622]}], "container": true, "attrs": {"id": "attractionweight"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Stiffness"], "extent": [8622, 8637], "body": [{"type": "para", "indent": 8, "text": ["How strongly nearby particles stick to each other.  Higher values\n        result in a less bouncy adhesion."], "extent": [8671, 8788]}, {"type": "para", "indent": 8, "text": ["Scale with the ", {"type": "code", "text": ["attractionstiffness"]}, " point attribute."], "extent": [8788, 8851]}, {"type": "para", "indent": 8, "text": ["OpenCL does not support the ", {"type": "code", "text": ["attractionstiffness"]}, " attribute."], "extent": [8851, 8921]}], "container": true, "attrs": {"id": "attractionstiffness"}, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 4, "text": ["Explicit Constraints"], "extent": [8921, 8954], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Weight"], "extent": [8954, 8967], "body": [{"type": "para", "indent": 8, "text": ["If particles are connected by polylines (polygons of two points) they\n        will be forced to maintain the distance specified by the\n        ", {"type": "code", "text": ["restlength"]}, " attribute on the primitive."], "extent": [8998, 9191]}, {"type": "para", "indent": 8, "text": ["This controls the weighting given to that constraint, a value of zero will\n        disable the constraint.  Setting this to zero will speed up the simulation as it will not have to copy connectivity information into an attribute every substep."], "extent": [9191, 9444]}, {"type": "para", "indent": 8, "text": ["Scale, on a per-particle basis (not per constraint!) with the ", {"type": "code", "text": ["constraintweight"]}, " point attribute."], "extent": [9444, 9551]}, {"type": "para", "indent": 8, "text": ["OpenCL does not support the ", {"type": "code", "text": ["constraintweight"]}, " attribute."], "extent": [9551, 9618]}], "container": true, "attrs": {"id": "constraintweight"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Stiffness"], "extent": [9618, 9633], "body": [{"type": "para", "indent": 8, "text": ["If particles are connected by polylines (polygons of two points) they\n        will be forced to maintain the distance specified by the ", {"type": "code", "text": ["restlength"]}, " attribute on the primitive."], "extent": [9667, 9852]}, {"type": "para", "indent": 8, "text": ["This controls the stiffness given to that constraint, higher values will be less bouncy."], "extent": [9852, 9950]}, {"type": "para", "indent": 8, "text": ["Scale, on a per-particle basis (not per constraint!) with the ", {"type": "code", "text": ["constraintstiffness"]}, " point attribute."], "extent": [9950, 10060]}, {"type": "para", "indent": 8, "text": ["OpenCL does not support the ", {"type": "code", "text": ["constraintstiffness"]}, " attribute."], "extent": [10060, 10130]}], "container": true, "attrs": {"id": "constraintstiffness"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Collide Mutually Constrained Particles"], "extent": [10130, 10174], "body": [{"type": "para", "indent": 8, "text": ["If two particles have an explicit constraint between them, this option\n        will allow them to collide.  This is useful if working with breaking\n        constraints as it can ensure there isn\u2019t a sudden force when the\n        constraint breaks.  It requires that the initial particles be\n        separated, however, so does not work if packing density is greater than\n        one."], "extent": [10174, 10567]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Enable Rigid Shape Matching"], "extent": [10567, 10600], "body": [{"type": "para", "indent": 8, "text": ["Connected groups of particles will be identified and constrained\n        to a rigid transform.  This greatly improves the stiffness of\n        rigid components, but involves expensive SOP operations."], "extent": [10627, 10836]}, {"type": "para", "indent": 8, "text": ["OpenCL does not suppport shape matching."], "extent": [10836, 10886]}], "container": true, "attrs": {"id": "enablerigids"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Instantaneous Strain"], "extent": [10886, 10912], "body": [{"type": "para", "indent": 8, "text": ["The ", {"type": "code", "text": ["strain"]}, " primitive attribute is computed fresh every iteration and not allowed to accumulate."], "extent": [10912, 11019]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Strain Decay"], "extent": [11019, 11037], "body": [{"type": "para", "indent": 8, "text": ["The rate at which the ", {"type": "code", "text": ["strain"]}, " attribute on the primitives of the constraints decays over time."], "extent": [11037, 11142]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Break Constraints"], "extent": [11142, 11165], "body": [{"type": "para", "indent": 8, "text": ["If the strain exceeds the strength of the constraint times the ", {"type": "ui", "text": ["Break Threshold"]}, ", the constraint is removed from the simulation. This allows dynamic tearing of the constraints.  The ", {"type": "code", "text": ["strength"]}, " primitive attribute on the constraints is used."], "extent": [11165, 11417]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Break Threshold"], "extent": [11417, 11438], "body": [{"type": "para", "indent": 8, "text": ["A scale factor for the amount of strain to break the constraints, which can be applied globally.  In instantaneous mode, it is approximately the ratio of deformation allowed: 0.05 means a 5% deformation from rest length will trigger a break."], "extent": [11438, 11689]}, {"type": "para", "indent": 8, "text": ["Decreasing particle sizes will decrease bond lengths, and thereby affect the rate of breaking."], "extent": [11689, 11793]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Remove Strands"], "extent": [11793, 11813], "body": [{"type": "para", "indent": 8, "text": ["When simulating a solid with explicit constraints, it can often unravel into chains of particles.  These stop having strong force as they no longer have a rigid connection.  This option will destroy any constraint that is a simple chain constraint."], "extent": [11813, 12071]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 4, "text": ["Targets (Pins)"], "extent": [12071, 12098], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Weight"], "extent": [12098, 12111], "body": [{"type": "para", "indent": 8, "text": ["Particles are constrained to their ", {"type": "code", "text": ["targetP"]}, " location.  The weight\n        is controlled by this times the ", {"type": "code", "text": ["targetweight"]}, " attribute, allowing\n        per particle variation."], "extent": [12138, 12321]}, {"type": "note_group", "body": [{"type": "note", "indent": 8, "role": "item", "extent": [12321, 12335], "body": [{"type": "para", "indent": 16, "text": [{"type": "code", "text": ["targetP"]}, " is not in the original SOPs space when sourcing an object with a transform."], "extent": [12335, 12438]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 8, "text": ["Scale with the ", {"type": "code", "text": ["targetweight"]}, " point attribute."], "extent": [12438, 12494]}], "container": true, "attrs": {"id": "targetweight"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Stiffness"], "extent": [12494, 12509], "body": [{"type": "para", "indent": 8, "text": ["The stiffness with which particles are fixed to their ", {"type": "code", "text": ["targetP"]}, "\n        attribute."], "extent": [12539, 12631]}, {"type": "note_group", "body": [{"type": "note", "indent": 8, "role": "item", "extent": [12631, 12645], "body": [{"type": "para", "indent": 16, "text": [{"type": "code", "text": ["targetP"]}, " is not in the original SOPs space when sourcing an object with a transform."], "extent": [12645, 12748]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 8, "text": ["Scale with the ", {"type": "code", "text": ["targetstiffness"]}, " point attribute."], "extent": [12748, 12807]}, {"type": "note_group", "body": [{"type": "note", "indent": 8, "role": "item", "extent": [12807, 12821], "body": [{"type": "para", "indent": 12, "text": ["If no ", {"type": "code", "text": ["targetstiffness"]}, " point attribute is present, it is\n            treated as zero, ie, no pins will be performed."], "extent": [12821, 12952]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "targetstiffness"}, "role": "item"}], "container": true, "role": "item_group"}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 4, "text": ["Solver"], "extent": [12952, 12969], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Max Neighbors"], "extent": [12969, 12989], "body": [{"type": "para", "indent": 8, "text": ["The maximum number of particles that will be considered when searching for potential collisions over the substep. Capping this is useful to avoid excessive computations, if too many particles are created at one spot."], "extent": [12989, 13215]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Neighbor Query Scale"], "extent": [13215, 13241], "body": [{"type": "para", "indent": 8, "text": ["Potential intersection particles are any within this scaled distance\n        of the average of the two particles ", {"type": "code", "text": ["pscale"]}, " attribute.  This\n        is an overestimate because usually collisions are not updated\n        during the constraint iterations, so it needs to record not\n        just the currently colliding particles, but those that may\n        start to collide due to the earlier iterations."], "extent": [13241, 13650]}, {"type": "para", "indent": 8, "text": ["This also effects the range of the attraction force in clumping."], "extent": [13650, 13724]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Max Speed"], "extent": [13724, 13739], "body": [{"type": "para", "indent": 8, "text": ["A speed limit on the resulting velocity.  If a particle had\n        to perform a very large motion to follow the constraint, it\n        gains the velocity that corresponds to that motion.  This can\n        result in explosions if too much energy is imparted, so this\n        can be used to limit the velocity seen next frame.  However, it does\n        not actually control how far the particle will move in a frame, just the reported ", {"type": "code", "text": ["v"]}, " attribute."], "extent": [13739, 14197]}, {"type": "para", "indent": 8, "text": ["OpenCL does not support maximum speed constraints."], "extent": [14197, 14257]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Max Acceleration"], "extent": [14257, 14279], "body": [{"type": "para", "indent": 8, "text": ["Caps the change in ", {"type": "code", "text": ["v"]}, " attribute that can be performed as\n        a result of constraint enforcement.  This caps the amount of\n        energy that can be put into the system by constraints."], "extent": [14279, 14478]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Drift Threshold"], "extent": [14478, 14499], "body": [{"type": "para", "indent": 8, "text": ["If a particle is moving slower than this speed, it is reverted\n        to its previous position.  This avoids slow settling of stacks\n        that might be visually unappealing without actually deactivating\n        the particles.  This is measured as a velocity, so as substeps\n        increase force effects may fall within this threshold.  Particles\n        will then stop responding to forces."], "extent": [14499, 14905]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Velocity Blend"], "extent": [14905, 14925], "body": [{"type": "para", "indent": 8, "text": ["After constraint validation, velocity is defined to be the\n        difference between the new and old points.  Instead, velocity\n        blend can be used to blend this with the old velocity, again\n        minimizing the rate of change and smoothing out the velocity\n        history of the particle."], "extent": [14925, 15234]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Over Relaxation"], "extent": [15234, 15255], "body": [{"type": "para", "indent": 8, "text": ["Constraint averaging can slow down convergence.  By boosting this above\n        one, the collision constraint is increased.  Too high, however, and it\n        can become unstable."], "extent": [15255, 15444]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Use OpenCL"], "extent": [15444, 15460], "body": [{"type": "para", "indent": 8, "text": ["Run the constraint iteration on the configured OpenCL device."], "extent": [15460, 15531]}, {"type": "note_group", "body": [{"type": "note", "indent": 8, "role": "item", "extent": [15531, 15545], "body": [{"type": "para", "indent": 12, "text": ["The OpenCL code path only supports a subset of features,\n            but in exchange for a faster constraint iteration process."], "extent": [15545, 15686]}], "container": true}, {"type": "note", "indent": 8, "role": "item", "extent": [15686, 15700], "body": [{"type": "para", "indent": 12, "text": ["The OpenCL code path operates on all PBD particles, not\n            just the ones in this stream.  (This is only an issue\n            if you have more than one POP Grains node in your network)"], "extent": [15700, 15906]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Update Collisions During Iterations"], "extent": [15906, 15947], "body": [{"type": "para", "indent": 8, "text": ["A single collision per particle is determined, which gives a plane of\n        collision.  During the constraint iteration this is used, even though\n        the particle may run into another collision face during the iteration.\n        This option will recollide the particles for every iteration, at\n        significant cost."], "extent": [15947, 16282]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Update Neighbors During Iterations"], "extent": [16282, 16322], "body": [{"type": "para", "indent": 8, "text": ["Normally the potential colliders of a particle is computed once and\n        reused for the iterations.  This will recompute it each iteration, at\n        considerable cost."], "extent": [16322, 16504]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Final Collision Test"], "extent": [16504, 16530], "body": [{"type": "para", "indent": 8, "text": ["Because the constraint enforcement is only partial, particles may still\n        be passing through objects after the constraint loop.  This performs a\n        final collision pass to prevent any particles from leaking through\n        objects, and is essential for thin surfaces or moving objects."], "extent": [16530, 16836]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Add Impact Data"], "extent": [16836, 16857], "body": [{"type": "para", "indent": 8, "text": ["Enables the addition of Impact data onto the particles.  Normally\n        these are not added to save memory, and particle collision attributes\n        are more easily created by enabling the ", {"type": "ui", "text": ["Add Hit Attributes"]}, " parameter\n        on the ", {"scheme": "Node", "value": "/nodes/dop/popsolver", "type": "link", "text": ["POP Solver"], "fullpath": "/nodes/dop/popsolver"}, " DOP."], "extent": [16857, 17142]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Enable Collision Feedback"], "extent": [17142, 17173], "body": [{"type": "para", "indent": 8, "text": ["Enables the addition of Feedback impacts onto colliding objects,\n        which are required for two-way interaction."], "extent": [17173, 17298]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Disable Constraint Averaging"], "extent": [17298, 17332], "body": [{"type": "para", "indent": 8, "text": ["When multiple particles collide at the same time, by default the\n        constraints to separate them are averaged out.  This is effective\n        in ensuring stability, but does not preserver momentum.  Thus,\n        when combined with internal forces, such as clumping, bunches\n        of particles may accelerate under their own force.  Disabling\n        this averaging will avoid these ghost forces, but require that\n        the Friction With Particles, Internal Weight, and Clumping Weight\n        all be reduced to at least 0.5, and possibly farther for stability."], "extent": [17332, 17912]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}], "text": "Parameters"}, {"level": 1, "id": "inputs", "container": true, "type": "inputs_section", "indent": 0, "role": "section", "extent": [17912, 17920], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["First Input"], "extent": [15, 28], "body": [{"type": "para", "indent": 4, "text": ["This optional input has two purposes."], "extent": [28, 71]}, {"type": "para", "indent": 4, "text": ["First, if it is wired to other POP nodes, they will be executed prior to this node executing.  The chain of nodes will be processed in a top-down manner."], "extent": [71, 230]}, {"type": "para", "indent": 4, "text": ["Second, if the input chain has a stream generator (such as ", {"scheme": "Node", "value": "/nodes/dop/poplocation", "type": "link", "text": ["POP Location"], "fullpath": "/nodes/dop/poplocation"}, ",\n    ", {"scheme": "Node", "value": "/nodes/dop/popsource", "type": "link", "text": ["POP Source"], "fullpath": "/nodes/dop/popsource"}, ", or ", {"scheme": "Node", "value": "/nodes/dop/popstream", "type": "link", "text": ["POP Stream"], "fullpath": "/nodes/dop/popstream"}, "), this node will only operate on the particles in that stream."], "extent": [230, 465]}], "container": true}], "container": true}], "text": "Inputs"}, {"level": 1, "id": "outputs", "container": true, "type": "outputs_section", "indent": 0, "role": "section", "extent": [17955, 17964], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["First Output"], "extent": [15, 29], "body": [{"type": "para", "indent": 4, "text": ["The output of this node should be wired into a solver chain."], "extent": [29, 95]}, {"type": "para", "indent": 4, "text": ["Merge nodes can be used to combine multiple solver chains."], "extent": [95, 159]}, {"type": "para", "indent": 4, "text": ["The final wiring should go into one of the purple inputs of a full-solver, such as ", {"scheme": "Node", "value": "/nodes/dop/popsolver", "type": "link", "text": ["POP Solver"], "fullpath": "/nodes/dop/popsolver"}, " or ", {"scheme": "Node", "value": "/nodes/dop/flipsolver", "type": "link", "text": ["FLIP Solver"], "fullpath": "/nodes/dop/flipsolver"}, "."], "extent": [159, 316]}], "container": true}], "container": true}], "text": "Outputs"}, {"level": 1, "id": "locals", "container": true, "type": "locals_section", "indent": 0, "role": "section", "extent": [18000, 18008], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["channelname"], "extent": [16, 29], "body": [{"type": "para", "indent": 4, "text": ["This DOP node defines a local variable for each channel and\n    parameter on the Data Options page, with the same name as the\n    channel. So for example, the node may have channels for Position\n    (positionx, positiony, positionz) and a parameter for an object name\n    (objectname). "], "extent": [29, 325]}, {"type": "para", "indent": 4, "text": ["Then there will also be local variables with the names\n    positionx, positiony, positionz, and objectname. These variables\n    will evaluate to the previous value for that parameter. "], "extent": [325, 519]}, {"type": "para", "indent": 4, "text": ["This previous value is always stored as part of the data attached to the\n    object being processed. This is essentially a shortcut for a\n    dopfield expression like:"], "extent": [519, 692]}, {"lang": null, "type": "pre", "indent": 4, "text": ["\n    dopfield($DOPNET, $OBJID, dataName, \"Options\", 0, channelname)\n    "], "extent": [692, 775]}, {"type": "para", "indent": 4, "text": ["If the data does not already exist, then a value of zero or an\n    empty string will be returned."], "extent": [775, 883]}], "container": true}, {"type": "dt", "indent": 0, "text": ["DATACT"], "extent": [883, 891], "body": [{"type": "para", "indent": 4, "text": ["This value is the simulation time (see variable ST) at which the\n    current data was created. This value may not be the same as the\n    current simulation time if this node is modifying existing data,\n    rather than creating new data."], "extent": [891, 1132]}], "container": true}, {"type": "dt", "indent": 0, "text": ["DATACF"], "extent": [1132, 1140], "body": [{"type": "para", "indent": 4, "text": ["This value is the simulation frame (see variable SF) at which the\n    current data was created. This value may not be the same as the\n    current simulation frame if this node is modifying existing data,\n    rather than creating new data."], "extent": [1140, 1383]}], "container": true}, {"type": "dt", "indent": 0, "text": ["RELNAME"], "extent": [1383, 1392], "body": [{"type": "para", "indent": 4, "text": ["This value will be set only when data is being attached to a relationship\n    (such as when Constraint Anchor DOP is connected to the second, third, of\n    fourth inputs of a Constraint DOP). "], "extent": [1392, 1594]}, {"type": "para", "indent": 4, "text": ["In this case, this value is set to the\n    name of the relationship to which the data is being attached."], "extent": [1594, 1703]}], "container": true}, {"type": "dt", "indent": 0, "text": ["RELOBJIDS"], "extent": [1703, 1714], "body": [{"type": "para", "indent": 4, "text": ["This value will be set only when data is being attached to a relationship\n    (such as when Constraint Anchor DOP is connected to the second, third, of\n    fourth inputs of a Constraint DOP). "], "extent": [1714, 1916]}, {"type": "para", "indent": 4, "text": ["In this case, this value is set to a\n    string that is a space separated list of the object identifiers for all\n    the Affected Objects of the relationship to which the data is being\n    attached."], "extent": [1916, 2119]}], "container": true}, {"type": "dt", "indent": 0, "text": ["RELOBJNAMES"], "extent": [2119, 2132], "body": [{"type": "para", "indent": 4, "text": ["This value will be set only when data is being attached to a relationship\n    (such as when Constraint Anchor DOP is connected to the second, third, of\n    fourth inputs of a Constraint DOP). "], "extent": [2132, 2334]}, {"type": "para", "indent": 4, "text": ["In this case, this value is set to a\n    string that is a space separated list of the names of all the Affected\n    Objects of the relationship to which the data is being attached."], "extent": [2334, 2519]}], "container": true}, {"type": "dt", "indent": 0, "text": ["RELAFFOBJIDS"], "extent": [2519, 2533], "body": [{"type": "para", "indent": 4, "text": ["This value will be set only when data is being attached to a relationship\n    (such as when Constraint Anchor DOP is connected to the second, third, of\n    fourth inputs of a Constraint DOP). "], "extent": [2533, 2735]}, {"type": "para", "indent": 4, "text": ["In this case, this value is set to a\n    string that is a space separated list of the object identifiers for all\n    the Affector Objects of the relationship to which the data is being\n    attached."], "extent": [2735, 2938]}], "container": true}, {"type": "dt", "indent": 0, "text": ["RELAFFOBJNAMES"], "extent": [2938, 2954], "body": [{"type": "para", "indent": 4, "text": ["This value will be set only when data is being attached to a relationship\n    (such as when Constraint Anchor DOP is connected to the second, third, of\n    fourth inputs of a Constraint DOP). "], "extent": [2954, 3156]}, {"type": "para", "indent": 4, "text": ["In this case, this value is set to a\n    string that is a space separated list of the names of all the Affector\n    Objects of the relationship to which the data is being attached."], "extent": [3156, 3341]}], "container": true}, {"type": "dt", "indent": 0, "text": ["ST"], "extent": [16, 20], "body": [{"type": "para", "indent": 4, "text": ["This value is the simulation time for which the node is being\n    evaluated. "], "extent": [20, 107]}, {"type": "para", "indent": 4, "text": ["This value may not be equal to the current Houdini time\n    represented by the variable T, depending on the settings of the ", {"scheme": "Node", "value": "/nodes/obj/dopnet", "type": "link", "text": ["DOP\n    Network"], "fullpath": "/nodes/obj/dopnet"}, " ", {"type": "ui", "text": ["Offset Time"]}, " and ", {"type": "ui", "text": ["Time Scale"]}, "\n    parameters. "], "extent": [107, 326]}, {"type": "para", "indent": 4, "text": ["This value is guaranteed to have a value of zero at the\n    start of a simulation, so when testing for the first timestep of a\n    simulation, it is best to use a test like ", {"type": "code", "text": ["$ST == 0"]}, " rather than\n    ", {"type": "code", "text": ["$T == 0"]}, " or ", {"type": "code", "text": ["$FF == 1"]}, "."], "extent": [326, 555]}], "container": true}, {"type": "dt", "indent": 0, "text": ["SF"], "extent": [555, 559], "body": [{"type": "para", "indent": 4, "text": ["This value is the simulation frame (or more accurately, the\n    simulation time step number) for which the node is being evaluated."], "extent": [559, 700]}, {"type": "para", "indent": 4, "text": ["This value may not be equal to the current Houdini frame number\n    represented by the variable F, depending on the settings of the ", {"scheme": "Node", "value": "/nodes/obj/dopnet", "type": "link", "text": ["DOP\n    Network"], "fullpath": "/nodes/obj/dopnet"}, " parameters. Instead, this value is equal to\n    the simulation time (ST) divided by the simulation timestep size\n    (TIMESTEP)."], "extent": [700, 999]}], "container": true}, {"type": "dt", "indent": 0, "text": ["TIMESTEP"], "extent": [999, 1009], "body": [{"type": "para", "indent": 4, "text": ["This value is the size of a simulation timestep. This value is\n    useful to scale values that are expressed in units per second, but\n    are applied on each timestep."], "extent": [1009, 1181]}], "container": true}, {"type": "dt", "indent": 0, "text": ["SFPS"], "extent": [1181, 1187], "body": [{"type": "para", "indent": 4, "text": ["This value is the inverse of the TIMESTEP value. It is the number\n    of timesteps per second of simulation time."], "extent": [1187, 1305]}], "container": true}, {"type": "dt", "indent": 0, "text": ["SNOBJ"], "extent": [1305, 1312], "body": [{"type": "para", "indent": 4, "text": ["This is the number of objects in the simulation. For nodes that\n    create objects such as the ", {"scheme": "Node", "value": "/nodes/dop/emptyobject", "type": "link", "text": ["Empty Object"], "fullpath": "/nodes/dop/emptyobject"}, " node,\n    this value will increase for each object that is evaluated. "], "extent": [1312, 1523]}, {"type": "para", "indent": 4, "text": ["A good way to guarantee unique object names is to use an expression\n    like ", {"type": "code", "text": ["object_$SNOBJ"]}, "."], "extent": [1523, 1621]}], "container": true}, {"type": "dt", "indent": 0, "text": ["NOBJ"], "extent": [1621, 1627], "body": [{"type": "para", "indent": 4, "text": ["This value is the number of objects that will be evaluated by the\n    current node during this timestep. This value will often be\n    different from SNOBJ, as many nodes do not process all the objects\n    in a simulation. "], "extent": [1627, 1859]}, {"type": "para", "indent": 4, "text": ["This value may return 0 if the node does not\n    process each object sequentially (such as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group\n    DOP"], "fullpath": "/nodes/dop/group"}, ")."], "extent": [1859, 1991]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OBJ"], "extent": [1991, 1996], "body": [{"type": "para", "indent": 4, "text": ["This value is the index of the specific object being processed by\n    the node. This value will always run from zero to NOBJ-1 in a given\n    timestep. This value does not identify the current object within the\n    simulation like OBJID or OBJNAME, just the object\u2019s position in the\n    current order of processing. "], "extent": [1996, 2322]}, {"type": "para", "indent": 4, "text": ["This value is useful for generating a\n    random number for each object, or simply splitting the objects into\n    two or more groups to be processed in different ways. This value\n    will be -1 if the node does not process objects sequentially (such\n    as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group DOP"], "fullpath": "/nodes/dop/group"}, ")."], "extent": [2322, 2616]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OBJID"], "extent": [2616, 2623], "body": [{"type": "para", "indent": 4, "text": ["This is the unique object identifier for the object being\n    processed. Every object is assigned an integer value that is unique\n    among all objects in the simulation for all time. Even if an object\n    is deleted, its identifier is never reused. "], "extent": [2623, 2883]}, {"type": "para", "indent": 4, "text": ["The object identifier\n    can always be used to uniquely identify a given object. This makes\n    this variable very useful in situations where each object needs to\n    be treated differently. It can be used to produce a unique random\n    number for each object, for example. "], "extent": [2883, 3168]}, {"type": "para", "indent": 4, "text": ["This value is also the best way\n    to look up information on an object using the dopfield expression\n    function. This value will be -1 if the node does not process objects\n    sequentially (such as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group DOP"], "fullpath": "/nodes/dop/group"}, ")."], "extent": [3168, 3406]}], "container": true}, {"type": "dt", "indent": 0, "text": ["ALLOBJIDS"], "extent": [3406, 3417], "body": [{"type": "para", "indent": 4, "text": ["This string contains a space separated list of the unique object\n    identifiers for every object being processed by the current node."], "extent": [3417, 3556]}], "container": true}, {"type": "dt", "indent": 0, "text": ["ALLOBJNAMES"], "extent": [3556, 3569], "body": [{"type": "para", "indent": 4, "text": ["This string contains a space separated list of the names of every\n    object being processed by the current node."], "extent": [3569, 3687]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OBJCT"], "extent": [3687, 3694], "body": [{"type": "para", "indent": 4, "text": ["This value is the simulation time (see variable ST) at which the\n    current object was created. "], "extent": [3694, 3801]}, {"type": "para", "indent": 4, "text": ["Therefore, to check if an object was created\n    on the current timestep, the expression ", {"type": "code", "text": ["$ST == $OBJCT"]}, " should\n    always be used. This value will be zero if the node does not process\n    objects sequentially (such as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group DOP"], "fullpath": "/nodes/dop/group"}, ")."], "extent": [3801, 4057]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OBJCF"], "extent": [4057, 4064], "body": [{"type": "para", "indent": 4, "text": ["This value is the simulation frame (see variable SF) at which the\n    current object was created. "], "extent": [4064, 4172]}, {"type": "para", "indent": 4, "text": ["This value is equivalent to using the\n    dopsttoframe expression on the OBJCT variable. This value will be\n    zero if the node does not process objects sequentially (such as the\n    ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group DOP"], "fullpath": "/nodes/dop/group"}, ")."], "extent": [4172, 4389]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OBJNAME"], "extent": [4389, 4398], "body": [{"type": "para", "indent": 4, "text": ["This is a string value containing the name of the object being\n    processed. "], "extent": [4398, 4486]}, {"type": "para", "indent": 4, "text": ["Object names are not guaranteed to be unique within a\n    simulation. However, if you name your objects carefully so that they\n    are unique, the object name can be a much easier way to identify an\n    object than the unique object identifier, OBJID. "], "extent": [4486, 4748]}, {"type": "para", "indent": 4, "text": ["The object name can\n    also be used to treat a number of similar objects (with the same\n    name) as a virtual group. If there are 20 objects named ", {"type": "q", "text": ["myobject"]}, ",\n    specifying ", {"type": "code", "text": ["strcmp($OBJNAME, \"myobject\") == 0"]}, " in the activation field\n    of a DOP will cause that DOP to operate only on those 20 objects. This\n    value will be the empty string if the node does not process objects\n    sequentially (such as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group DOP"], "fullpath": "/nodes/dop/group"}, ")."], "extent": [4748, 5194]}], "container": true}, {"type": "dt", "indent": 0, "text": ["DOPNET"], "extent": [5194, 5202], "body": [{"type": "para", "indent": 4, "text": ["This is a string value containing the full path of the current DOP\n    Network. This value is most useful in DOP subnet digital assets\n    where you want to know the path to the DOP Network that contains the\n    node."], "extent": [5202, 5425]}], "container": true}], "container": true}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [5425, 5431], "body": [{"type": "para", "indent": 4, "text": ["Most dynamics nodes have local variables with the same names as the\n    node\u2019s parameters. For example, in a ", {"scheme": "Node", "value": "/nodes/dop/position", "type": "link", "text": ["Position node"], "fullpath": "/nodes/dop/position"}, ",\n    you could write the expression:"], "extent": [5431, 5620]}, {"lang": null, "type": "pre", "indent": 4, "text": ["\n    $tx + 0.1\n    "], "extent": [5620, 5650]}, {"type": "para", "indent": 4, "text": ["\u2026to make the object move 0.1 units along the X axis at each timestep."], "extent": [5650, 5730]}], "container": true}], "container": true, "role": "item_group"}], "text": "Locals"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [18077, 18086], "body": [{"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": [{"scheme": "Node", "value": "/nodes/dop/popsolver", "type": "link", "text": "", "fullpath": "/nodes/dop/popsolver"}], "extent": [18086, 18114]}], "container": true}], "text": "Related"}], "title": ["POP Grains"], "summary": ["A POP node that applies sand grain interaction to particles."], "included": ["/nodes/dop/standard_data_locals", "/nodes/dop/standard_locals", "/nodes/dop/standard_pop_inputs", "/nodes/dop/standard_pop_outputs", "/nodes/dop/standard_pop_parms"]}