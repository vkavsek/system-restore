{"type": "root", "attrs": {"type": "include"}, "body": [{"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Collisions"], "extent": [16, 33], "body": [{"level": 3, "id": "volume", "container": true, "type": "h", "indent": 0, "text": ["Volume"], "extent": [33, 58], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["Use Volume Based Collision Detection"], "extent": [58, 97], "body": [{"type": "para", "indent": 4, "text": ["Turning on this option causes the ", {"scheme": "Node", "value": "/nodes/dop/rbdsolver", "type": "link", "text": ["RBD solver"], "fullpath": "/nodes/dop/rbdsolver"}, " to use a volume\n    representation of this object for collision detection. "], "extent": [97, 248]}, {"type": "para", "indent": 4, "text": ["The volume representation results in very fast collision detection\n    and very robust results that are tolerant of temporary\n    interpenetrations. The disadvantage is that a volume\n    representation cannot be used to represent a flat object such as\n    a grid, or a hollow sphere. "], "extent": [248, 542]}, {"type": "para", "indent": 4, "text": ["When this toggle is turned off, the collision detection is geometry-based rather than volume-based. \n    In this case, the collision code will track the trajectories of moving objects over time to find out whether collisions occurred.\n    This allows more accurate results than volume-based collision detection.\n    For this to work, ", {"type": "ui", "text": ["Cache Simulation"]}, " must be enabled on the DOP network."], "extent": [542, 938]}], "container": true}, {"type": "dt", "indent": 0, "text": ["Collision Guide"], "extent": [938, 955], "body": [{"type": "para", "indent": 4, "text": ["The internal representation used for collision detection is\n    converted to visible geometry. This is useful for debugging\n    problems with collision detection."], "extent": [955, 1127]}, {"type": "para", "indent": 4, "text": ["This parameter controls the color of the guide geometry."], "extent": [1127, 1193]}], "container": true}, {"type": "dt", "indent": 0, "text": ["Mode"], "extent": [1193, 1200], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Ray Intersect"], "extent": [1200, 1219], "body": [{"type": "para", "indent": 8, "text": ["Use ray intersection with the geometry to create an\n        accurate volumetric representation of the geometry."], "extent": [1219, 1339]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Meta Balls"], "extent": [1339, 1355], "body": [{"type": "para", "indent": 8, "text": ["Instead of using rays to determine if points are inside or\n        outside, evaluate the metaball field.  "], "extent": [1355, 1479]}, {"type": "para", "indent": 8, "text": ["This should be used\n        with ", {"type": "ui", "text": ["Laser Scanning"]}, " turned off on geometry that consists\n        solely of metaballs."], "extent": [1479, 1605]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Implicit Box"], "extent": [1605, 1623], "body": [{"type": "para", "indent": 8, "text": ["Calculate the bounding box for the geometry, and create a volumetric representation that precisely fills that bounding box. This box is always axis aligned in the DOP object\u2019s local space, which is set by the position data."], "extent": [1623, 1864]}, {"type": "note_group", "body": [{"type": "note", "indent": 8, "role": "item", "extent": [1864, 1878], "body": [{"type": "para", "indent": 12, "text": [{"type": "ui", "text": ["Use Object Transform"]}, " bakes the object transform into the geometry\u2019s transform, leaving the ", {"type": "ui", "text": ["Position Data"]}, " in world space. Turning this off causes the object transform to be send to the ", {"type": "ui", "text": ["Position Data"]}, ", which causes the object\u2019s local space to be reoriented."], "extent": [1878, 2170]}], "container": true}], "container": true, "role": "item_group"}], "container": true}, {"type": "dt", "indent": 4, "text": ["Implicit Sphere"], "extent": [2170, 2191], "body": [{"type": "para", "indent": 8, "text": ["Calculate the bounding sphere for the geometry, and create\n        a volumetric representation that precisely fills that\n        bounding sphere."], "extent": [2191, 2345]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Implicit Plane"], "extent": [2345, 2365], "body": [{"type": "para", "indent": 8, "text": ["Calculate the bounding box for the geometry, and create a\n        volumetric representation that divides that box along its\n        smallest axis. Everything below that plane is considered\n        inside, and everything above is outside. "], "extent": [2365, 2621]}, {"type": "para", "indent": 8, "text": ["This mode is primarily useful for creating ground planes or immovable\n        walls."], "extent": [2621, 2715]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Minimum"], "extent": [2715, 2728], "body": [{"type": "para", "indent": 8, "text": ["Use the distance to the surface or curve.  If the Offset\n        Surface is 0, no volume will be made.  A positive offset\n        surface will create just that - an offset volume around\n        the object\u2019s surface.  This is useful for turning thin\n        objects or wires into actual solids."], "extent": [2728, 3030]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Volume Sample"], "extent": [3030, 3049], "body": [{"type": "para", "indent": 8, "text": ["The divisions are ignored in this mode, instead they are\n        computed from the first volume or VDB primitive in the geometry.\n        The computed divisions are chosen to match the voxel\n        size of the source volume.\n        The volume primitive is sampled raw and treated as a\n        signed distance field.  The assumption is that the source\n        is the output of an ", {"scheme": "Node", "value": "/nodes/sop/isooffset", "type": "link", "text": ["Iso Offset"], "fullpath": "/nodes/sop/isooffset"}, " or\n        ", {"scheme": "Node", "value": "/nodes/sop/vdbfrompolygons", "type": "link", "text": ["VDB From Polygons"], "fullpath": "/nodes/sop/vdbfrompolygons"}, " SOP.  If it isn\u2019t a true\n        signed distance fields, unusual things may happen with RBD\n        collisions."], "extent": [3049, 3647]}], "container": true}], "container": true}], "container": true}, {"type": "dt", "indent": 0, "text": ["Division Method"], "extent": [3647, 3664], "body": [{"type": "para", "indent": 4, "text": ["If ", {"type": "ui", "text": ["Non Square"]}, " is chosen, the specified size is divided into the given number\n    of divisions of voxels.  However, the sides of these voxels may not be\n    equal, possibly leading to distorted simulations."], "extent": [3692, 3907]}, {"type": "para", "indent": 4, "text": ["When an axis is specified, that axis is considered authoritative\n    for determining the number of divisions.  The chosen axis' size\n    will be divided by the uniform divisions to yield the voxel\n    size.  The divisions for the other axes will then be adjusted to\n    the closest integer multiple that fits in the required size."], "extent": [3907, 4247]}, {"type": "para", "indent": 4, "text": ["Finally, the size along non-chosen axes will be changed to\n    represent uniform voxel sizes.  If the ", {"type": "ui", "text": ["Max Axis"]}, " option is chosen,\n    the maximum sized axis is used."], "extent": [4247, 4421]}, {"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["By Size"]}, " is chosen, the ", {"type": "ui", "text": ["Division Size"]}, " will be used to\n    compute the number of voxels that fit in the given sized box."], "extent": [4421, 4562]}], "container": true, "attrs": {"id": "sdf_uniformvoxels"}}, {"type": "dt", "indent": 0, "text": ["Divisions"], "extent": [4562, 4573], "body": [{"type": "para", "indent": 4, "text": ["Controls the creation of the volumetric representation of this\n    object. This should be set fine enough to capture the desired\n    features of the geometry."], "extent": [4573, 4741]}], "container": true}, {"type": "dt", "indent": 0, "text": ["Uniform Divisions"], "extent": [4741, 4760], "body": [{"type": "para", "indent": 4, "text": ["The resolution of the key axis on the voxel grid.  This allows you\n    to control the overall resolution with one parameter and still\n    preserve uniform voxels.  The ", {"type": "ui", "text": ["Uniform Voxels"]}, " option specifies\n    which axis should be used as the reference. It is usually safest\n    to use the maximum axis."], "extent": [4789, 5100]}], "container": true, "attrs": {"id": "sdf_uniformdiv"}}, {"type": "dt", "indent": 0, "text": ["Division Size"], "extent": [5100, 5115], "body": [{"type": "para", "indent": 4, "text": ["The explicit size of the voxels.  The number of voxels will be\n    computed by fitting an integer number of voxels of this size into\n    the given bounds."], "extent": [5115, 5279]}], "container": true}, {"type": "dt", "indent": 0, "text": ["Laser Scan"], "extent": [5279, 5291], "body": [{"type": "para", "indent": 4, "text": ["In laser scan mode the volumetric representation is built by\n    sending rays along the primary axes. Only the closest and\n    farthest intersections are used. The space between these two\n    points is classified as inside, and the rest outside."], "extent": [5291, 5542]}, {"type": "para", "indent": 4, "text": ["The laser scan mode will work even with geometry which has\n    poorly defined normals, self intersects, or is not fully\n    watertight. The disadvantage is that interior features can\u2019t be\n    represented as they are not detected."], "extent": [5542, 5777]}, {"type": "para", "indent": 4, "text": ["When laser scanning is turned off, the volumetric\n    representation is still built by sending rays along the primary\n    axes. All intersections are found, however. Each pair of\n    intersections is tested to see if the segment is inside or\n    outside. This relies on the normal of the geometry being well\n    defined (i.e., manifold, no self intersections), and the\n    geometry being watertight. Complicated shapes with holes can be\n    accurately represented, however."], "extent": [5777, 6256]}], "container": true}, {"type": "dt", "indent": 0, "text": ["Fix Signs"], "extent": [6256, 6267], "body": [{"type": "para", "indent": 4, "text": ["Even with the best made geometry, numerical imprecision can\n    result in incorrect sign choices. This option will cause the\n    volumetric representation to be post-processed to look for\n    inconsistent signs. These are then made consistent, usually\n    plugging leaks and filling holes."], "extent": [6267, 6562]}, {"type": "para", "indent": 4, "text": ["This takes time, and can be turned off in cases where the\n    volumetric representation is known to generate without problems."], "extent": [6562, 6694]}], "container": true}, {"type": "dt", "indent": 0, "text": ["Force Bounds"], "extent": [6694, 6708], "body": [{"type": "para", "indent": 4, "text": ["The ", {"type": "ui", "text": ["Fix Signs"]}, " method alone will smooth out, and usually\n    eliminate, sign inversions. However, it is possible for regions\n    of wrong-sign to become stabilized at the boundary of the\n    volumetric representation. This option will force all voxels on\n    the boundary to be marked as exterior. The ", {"type": "ui", "text": ["Fix Signs"]}, " method\n    will be much less likely to stabilize incorrectly then."], "extent": [6708, 7103]}], "container": true}, {"type": "dt", "indent": 0, "text": ["Invert Sign"], "extent": [7103, 7116], "body": [{"type": "para", "indent": 4, "text": ["If you want a hollow box, one method is to build one box inside\n    the other and not use ", {"type": "ui", "text": ["Laser Scanning"]}, ". A more robust method\n    is to just specify the inner box and use sign inversion. This\n    treats everything outside of the box as inside, allowing the\n    more robust ", {"type": "ui", "text": ["Laser Scanning"]}, " method to be used."], "extent": [7116, 7441]}], "container": true}, {"type": "dt", "indent": 0, "text": ["Sign Sweep Threshold"], "extent": [7441, 7463], "body": [{"type": "para", "indent": 4, "text": ["After the fix signs process is complete there can still be\n    inconsistent areas in the SDF.  Large blocks can become\n    stabilized and stick out of the SDF.  A second sign sweep pass\n    can be performed to try to eliminate these blocks."], "extent": [7492, 7738]}, {"type": "para", "indent": 4, "text": ["The sign sweep threshold governs how big of a jump has to\n    occur for a sign transition to be considered inconsistent.  If\n    the values of the sdf change by more than this threshold times\n    the width of the cell, it is considered an invalid sign\n    transition.  The original geometry is then ray intersected to\n    determine inside/outside and the result used to determine\n    which sign is correct.  The correct sign is then propagated\n    forward through the model."], "extent": [7738, 8222]}], "container": true, "attrs": {"id": "sdf_sweepalpha"}}, {"type": "dt", "indent": 0, "text": ["Max Sign Sweep Count"], "extent": [8222, 8244], "body": [{"type": "para", "indent": 4, "text": ["The sign sweeps are repeated until no signs are flipped (ie,\n    all transitions are within the threshold) or this maximum is\n    reached.  Too low of a sign sweep threshold may prevent the\n    process from converging.  Otherwise, it tends to converge very\n    quickly."], "extent": [8273, 8548]}], "container": true, "attrs": {"id": "sdf_sweepcount"}}, {"type": "dt", "indent": 0, "text": ["Offset Surface"], "extent": [8548, 8564], "body": [{"type": "para", "indent": 4, "text": ["A constant amount to offset the signed distance field by.\n    This can be used grow the object slightly or shrink it.  Note\n    that it can\u2019t be grown much beyond its original size or it\n    will hit the bounding box of the signed distance field."], "extent": [8564, 8820]}], "container": true}, {"type": "dt", "indent": 0, "text": ["Tolerance"], "extent": [8820, 8831], "body": [{"type": "para", "indent": 4, "text": ["This specifies the tolerance used for ray intersections\n    when computing the SDF. This value is multiplied by the size\n    of the geometry and is scale invariant."], "extent": [8853, 9027]}], "container": true, "attrs": {"id": "sdf_tol"}}, {"type": "dt", "indent": 0, "text": ["Proxy Volume"], "extent": [9027, 9041], "body": [{"type": "para", "indent": 4, "text": ["The geometry which will be used rather than the base geometry for\n    computing the SDF.  This can be a volume or VDB in the case of Volume Sample\n    mode to allow one better control over the cached data."], "extent": [9041, 9256]}], "container": true}, {"type": "dt", "indent": 0, "text": ["File Mode"], "extent": [9256, 9267], "body": [{"type": "para", "indent": 4, "text": ["Controls the operation for this object\u2019s volume data."], "extent": [9267, 9326]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Automatic"], "extent": [9326, 9341], "body": [{"type": "para", "indent": 8, "text": ["If a file with the specified name exists already, it is\n        read from disk. Otherwise the volume is created based on the\n        other parameters on this page, and the specified file is\n        created on disk. This file will never be deleted\n        automatically, even when exiting the application."], "extent": [9341, 9654]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Read Files"], "extent": [9654, 9670], "body": [{"type": "para", "indent": 8, "text": ["The specified file is read from disk."], "extent": [9670, 9716]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Write Files"], "extent": [9716, 9733], "body": [{"type": "para", "indent": 8, "text": ["The volume is created using the other parameters on this\n        page, and is then written to the specified file on disk."], "extent": [9733, 9863]}], "container": true}, {"type": "dt", "indent": 4, "text": ["No Operation"], "extent": [9863, 9881], "body": [{"type": "para", "indent": 8, "text": ["The file is never read or written. The parameters on this\n        page are used to create the volume."], "extent": [9881, 9991]}], "container": true}], "container": true}], "container": true}, {"type": "dt", "indent": 0, "text": ["File"], "extent": [9991, 9997], "body": [{"type": "para", "indent": 4, "text": ["The name of the file to access according to the choice of File\n    Modes above.  This is always .simdata file format.  Saving to\n    a .bgeo extension will ", {"type": "strong", "text": ["not"]}, " save a .bgeo file."], "extent": [9997, 10187]}], "container": true}], "container": true}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Surface"], "extent": [10187, 10203], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["Surface Representation"], "extent": [10203, 10228], "body": [{"type": "para", "indent": 4, "text": ["Chooses between colliding points against volume or colliding\n    edges against volume. "], "extent": [10228, 10325]}, {"type": "para", "indent": 4, "text": ["Optionally, the point attributes ", {"type": "code", "text": ["nopointvolume"]}, " and ", {"type": "code", "text": ["noedgevolume"]}, " may be added to the geometry to disable individual points/edges from participating in\n    collision detection against a volume object. An edge is disabled\n    if either of its endpoints is disabled."], "extent": [10325, 10601]}], "container": true}, {"type": "dt", "indent": 0, "text": ["Convert To Poly"], "extent": [10601, 10618], "body": [{"type": "para", "indent": 4, "text": ["This enables conversion of primitives (such as spheres) in the\n    geometry into polygons. Only polygons are used for collision\n    detection."], "extent": [10618, 10770]}], "container": true}, {"type": "dt", "indent": 0, "text": ["Triangulate"], "extent": [10770, 10783], "body": [{"type": "para", "indent": 4, "text": ["When this flag is turned on, polygons in the geometry are\n    triangulated."], "extent": [10783, 10868]}], "container": true}, {"type": "dt", "indent": 0, "text": ["LOD "], "extent": [10868, 10874], "body": [{"type": "para", "indent": 4, "text": ["This controls the Level Of Detail of the triangulation. It is\n    used to specify the point density in the U and V directions."], "extent": [10874, 11010]}], "container": true}, {"type": "dt", "indent": 0, "text": ["Add Barycenters"], "extent": [11010, 11027], "body": [{"type": "para", "indent": 4, "text": ["The barycenters of each polygon can be included in the\n    collision detection as points or edges (connected to the\n    vertices of the primitive)."], "extent": [11027, 11179]}], "container": true}], "container": true}]}]}]}