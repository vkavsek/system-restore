{"type": "root", "attrs": {"type": "node", "context": "dop", "internal": "vellumsolver", "icon": "DOP/vellumsolver", "tags": "vellum", "since": "17.0", "version": null, "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Vellum Solver"], "extent": [111, 129]}, {"type": "summary", "indent": 0, "text": ["Sets and configures a Vellum solver."], "extent": [129, 174]}, {"type": "para", "indent": 0, "text": ["Vellum Solvers are a type of POP Solver that include support for internal triangle and edge collisions and explicit constraint geometry."], "extent": [174, 312]}, {"type": "para", "indent": 0, "text": ["The Geometry data stores the dynamic attributes of the simulation as point attributes.  It also stores the collision geometry, so the triangle or poly-line mesh is used to detect and resolve collisions. However, the way the points are held together is determined by the separate Constraint Geometry data.  The Constraint Geometry data should have a one-to-one point correspondence with the Geometry.  Polygons in the Constraint Geometry are interpreted as rules to maintain certain properties of the source points, such as distance or bend angle."], "extent": [312, 860]}, {"type": "para", "indent": 0, "text": ["POP Forces can be wired into the solver-inputs to adjust the behavior of the object."], "extent": [860, 946]}, {"type": "para", "indent": 0, "text": ["Usually an empty Vellum object is created using a ", {"scheme": "Node", "value": "/nodes/dop/vellumobject", "type": "link", "text": ["Vellum Object DOP"], "fullpath": "/nodes/dop/vellumobject"}, " and patches of geometry are added to this object with ", {"scheme": "Node", "value": "/nodes/dop/vellumsource", "type": "link", "text": ["Vellum Source DOPs"], "fullpath": "/nodes/dop/vellumsource"}, "."], "extent": [946, 1138]}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [1138, 1150], "body": [{"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Common"], "extent": [1150, 1164], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Enable Collisions"], "extent": [3206, 3226], "body": [{"type": "para", "indent": 4, "text": ["Controls if any collision detection is done at all."], "extent": [3253, 3310]}], "container": true, "attrs": {"id": "enablecollisions"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Self Collisions"], "extent": [3310, 3327], "body": [{"type": "para", "indent": 4, "text": ["Controls if self collisions are detected."], "extent": [3354, 3401]}], "container": true, "attrs": {"id": "doselfcollisions"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Time Scale"], "extent": [1612, 1625], "body": [{"type": "para", "indent": 4, "text": ["Scales the effective time of the Vellum solve.  This can be used to\n    create bullet-time like effects where the physics of the Vellum\n    solver run at a different rate than the Houdini playbar.  A\n    value of 2 will cause cloth to fall twice as fast, and 0.1\n    will slow it to a tenth the speed."], "extent": [1645, 1952]}], "container": true, "attrs": {"id": "timescale"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Velocity Damping"], "extent": [6085, 6103], "body": [{"type": "para", "indent": 4, "text": ["A more brute force approach to reducing dynamic velocity - the velocity\n    is scaled directly by this amount, causing sudden movements to\n    be quickly damped."], "extent": [6124, 6291]}], "container": true, "attrs": {"id": "veldamping"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Iterations"], "extent": [1360, 1379], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Substeps"], "extent": [1952, 1962], "body": [{"type": "para", "indent": 4, "text": ["Each frame will be broken into this number of substeps.  Additional\n    substeps are required for fast moving collisions or sudden forces."], "extent": [1981, 2125]}, {"type": "para", "indent": 4, "text": ["The default substeps can be very aggressive, usually if the\n    Vellum solver is too stretchy, raising substeps to 2 or 5 is\n    a good first start."], "extent": [2125, 2279]}], "container": true, "attrs": {"id": "substeps"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Constraint Iterations"], "extent": [2279, 2302], "body": [{"type": "para", "indent": 4, "text": ["Within each substep, this number of passes will be taken by the\n    constraint enforcement operations.   Stiff constraints can\n    require more iterations to converge.  A good starting point\n    is the diameter of the geometry - the number of edges between\n    the farthest points."], "extent": [2318, 2606]}], "container": true, "attrs": {"id": "niter"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Smoothing Iterations"], "extent": [2606, 2628], "body": [{"type": "para", "indent": 4, "text": ["The default constraint iterations use a Gauss-Seidel approach that\n    is fast to converge.  However, if it doesn\u2019t fully converge due to\n    too high stiffness, or impossible configurations, it will leave the error\n    as bad looking triangles.  The smoothing iterations use a Jacobi\n    approach which is slower to converge but leaves error spread out\n    in a more attractive fashion.  The default of ten passes helps\n    smooth out error, but might need to be increased if the overall\n    ", {"type": "ui", "text": ["Constraint Iterations"]}, " is very high."], "extent": [2649, 3187]}], "container": true, "attrs": {"id": "smoothiter"}, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Collisions"], "extent": [1511, 1530], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Collision Passes"], "extent": [3625, 3643], "body": [{"type": "para", "indent": 4, "text": ["Number of collision detection passes to perform.  These are interleaved\n    between the constraint iterations.  Since collision is expensive, it is\n    best to minimize this.   But frequent interleaving helps avoid tent-poling\n    effects where a small collider is fighting with the no-stretch constraints.\n    In practice we find 10 to be correct for most situations, and substeps\n    often being a better solution to increase quality."], "extent": [3668, 4111]}], "container": true, "attrs": {"id": "collisionsiter"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Post Collision Passes"], "extent": [4111, 4134], "body": [{"type": "para", "indent": 4, "text": ["After all constraints are performed, a final round of collision detection\n    is done.   Collisions are often the most noticeable failure mode, and it\n    is ideal if the next frame can start with non-intersecting geometry.\n    Thus a final cleanup pass can achieve these requirements.   We have\n    found that ", {"type": "q", "text": ["number of stacked layers + 2"]}, " is a good estimate for this\n    number.   This allows the effect of the underlying collider to ripple\n    through the stacked layers fully."], "extent": [4162, 4649]}], "container": true, "attrs": {"id": "postcollisioniter"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Polish Passes"], "extent": [4649, 4664], "body": [{"type": "para", "indent": 4, "text": ["In any collision pass, any colliding pair may not be fully resolved.   This\n    number of additional collider-pair passes will be run until they are\n    resolved.  Since these are only performed on active colliders (and no new\n    collision search is done) this is very cheap."], "extent": [4688, 4971]}], "container": true, "attrs": {"id": "resolveallmax"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Layer Shock"], "extent": [4971, 4984], "body": [{"type": "para", "indent": 4, "text": ["The ", {"type": "code", "text": ["layer"]}, " integer point attribute is used to flag point as belonging\n    to different layers of cloth.  Higher numbers refer to higher layers.\n    Layer Shock will make lower layers this many times heavier during collision\n    evaluation, ensuring the higher layers will move out of their way.  The\n    rest of the dynamics are unaffected by this, and the difference is fixed\n    regardless of the number of layers between the two.  This can be thought\n    of as a way to dial between one-way layering of sims and fully coupled\n    sims."], "extent": [5005, 5550]}], "container": true, "attrs": {"id": "layershock"}, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Friction"], "extent": [1729, 1746], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Static Threshold"], "extent": [6308, 6327], "body": [{"type": "para", "indent": 4, "text": ["A threshold at which to apply full friction.  When the ratio of the tangential velocity and the normal impulse is less than this, the tangential velocity will be fully eliminated through friction.  This is roughly tan() of the slope angle that will allow sliding under gravity."], "extent": [6354, 6638]}], "container": true, "attrs": {"id": "static_threshold"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Dynamic Scale"], "extent": [6638, 6653], "body": [{"type": "para", "indent": 4, "text": ["If the static threshold fails, this controls what percentage the tangential velocity will be reduced in the dynamic friction case."], "extent": [6677, 6813]}], "container": true, "attrs": {"id": "dynamic_scale"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Enable External"], "extent": [6813, 6830], "body": [{"type": "para", "indent": 4, "text": ["A scale factor on the amount of friction effect to apply for collisions with external geometry."], "extent": [6849, 6950]}], "container": true, "attrs": {"id": "friction"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Enable Self"], "extent": [6950, 6963], "body": [{"type": "para", "indent": 4, "text": ["A scale factor on the amount of friction effect to apply for collisions with self geometry."], "extent": [6986, 7083]}], "container": true, "attrs": {"id": "selffriction"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Static SDF Enable"], "extent": [1940, 1959], "body": [{"type": "para", "indent": 4, "text": ["A scale factor for the volume collider\u2019s static friction.  Useful to\n    create frictionless grounds."], "extent": [1985, 2092]}], "container": true, "attrs": {"id": "static_sdfscale"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Dynamic SDF Enable"], "extent": [2092, 2112], "body": [{"type": "para", "indent": 4, "text": ["A scale factor for the volume collider\u2019s dynamic friction.  Useful to\n    create frictionless grounds."], "extent": [2139, 2247]}], "container": true, "attrs": {"id": "dynamic_sdfscale"}, "role": "item"}], "container": true, "role": "item_group"}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Advanced"], "extent": [2247, 2262], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Integration"], "extent": [8924, 8937], "body": [{"type": "para", "indent": 4, "text": ["When integrating points forward by their velocities, curved motions\n    like swinging pendulums will be mispredicted and be damped by\n    the constraint projections.   A second order predictor recovers more of\n    this curved motion and maintains more energy in the system."], "extent": [8959, 9238]}, {"type": "para", "indent": 4, "text": ["In any case, if collisions are detected the system will fall back\n    to first order to avoid excessive bouncing."], "extent": [9238, 9357]}], "container": true, "attrs": {"id": "integration"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["External Forces"], "extent": [2310, 2327], "body": [{"type": "para", "indent": 4, "text": ["The Vellum points will receive forces from DOP forces.  Turning this off\n    will remove this effect, and the points will only be affected by POP forces."], "extent": [2351, 2510]}], "container": true, "attrs": {"id": "externalforce"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Default Mass"], "extent": [2510, 2524], "body": [{"type": "para", "indent": 4, "text": ["If no ", {"type": "code", "text": ["mass"]}, " attribute is on the incoming geometry, this will be used as the\n    default value for the points."], "extent": [2539, 2655]}, {"type": "para", "indent": 4, "text": ["Usually mass should already be set by the ", {"scheme": "Node", "value": "/nodes/sop/vellumconstraints", "type": "link", "text": ["Vellum Constraints"], "fullpath": "/nodes/sop/vellumconstraints"}, " SOP."], "extent": [2655, 2756]}], "container": true, "attrs": {"id": "mass"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Default Thickness"], "extent": [2756, 2775], "body": [{"type": "para", "indent": 4, "text": ["If the incoming geometry has no ", {"type": "code", "text": ["pscale"]}, " attribute, it will be set to this value."], "extent": [2795, 2882]}, {"type": "para", "indent": 4, "text": ["Usually thickness should already be set by the ", {"scheme": "Node", "value": "/nodes/sop/vellumconstraints", "type": "link", "text": ["Vellum Constraints"], "fullpath": "/nodes/sop/vellumconstraints"}, " SOP."], "extent": [2882, 2987]}], "container": true, "attrs": {"id": "thickness"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Secondary Constraint Pass"], "extent": [2987, 3021], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Enable Secondary Constraint Pass"], "extent": [9391, 9426], "body": [{"type": "para", "indent": 4, "text": ["If this checkbox is turned on, all constraints in the specified ", {"type": "ui", "text": ["Constraint Group"]}, " will be solved in a separate, interleaved pass to the remaining constraints.  "], "extent": [9448, 9621]}, {"type": "para", "indent": 4, "text": ["There are two main uses for this option. First, there are some expensive constraint types that do not need to be solved as frequently as the rest of the constraints, so enabling this option and choosing a low ", {"type": "ui", "text": ["Solve Frequency"]}, " can improve performance.  For example, cloth bend constraints on high resolution cloth with low bend stiffness such a silk or cotton. You need to ensure that you're solving distance constraints every pass so the cloth doesn\u2019t stretch. However, bend constraints are expensive and don\u2019t need to be as strong, since silk and cotton have very low bend resistance and wrinkle easily. Solving the bend constraints as a secondary pass will give you strong performance gains. However, this method isn\u2019t practical for stiffer material such as leather."], "extent": [9621, 10398]}, {"type": "para", "indent": 4, "text": ["The second use case is constraints that cause frequent changes in the constraint topology,\n    which causes the solver to re-order the constraint solve, possibly causing jittering in the\n    remaining constraints.  An example is organic tissue represented by tetrahedra and attached\n    together with sliding Stitch constraints.  As the sliding causes changes in the constraint\n    topology the tetrahedra might jitter slightly as the constraint solve order changes.  Moving\n    the Stitch constraints to another pass by setting ", {"type": "ui", "text": ["Constraint Group"]}, " to ", {"type": "code", "text": ["@type=ptprim"]}, " and\n    increasing the ", {"type": "ui", "text": ["Solve Frequency"]}, " to 1 will retain the same stiffness but eliminate tetrahedral\n    jittering due to changes in the solve order."], "extent": [10398, 11125]}], "container": true, "attrs": {"id": "dosecondary"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Constraint Group"], "extent": [11125, 11143], "body": [{"type": "para", "indent": 4, "text": ["The constraint group(s) that should be solved in the interleaved secondary pass.  This parameter accepts standard group syntax, so can contain explicit group names and ad-hoc groups, often specifying one or more constraint types with something like ", {"type": "code", "text": ["@type==bend"]}, ". Any constraint not contained in these groups will be solved in the primary pass as usual."], "extent": [11168, 11527]}], "container": true, "attrs": {"id": "secondarygroup"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Solve Frequency"], "extent": [11527, 11544], "body": [{"type": "para", "indent": 4, "text": ["The frequency at which to solve the secondary pass.  A setting of 1 will solve the secondary pass as often as the primary pass, while a setting of 0.25 will solve once every four passes of the primary pass (one quarter of the time)."], "extent": [11573, 11811]}], "container": true, "attrs": {"id": "secondaryfrequency"}, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Multi-Pass Solve"], "extent": [3173, 3198], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Enable Multi-Pass"], "extent": [11836, 11856], "body": [{"type": "para", "indent": 4, "text": ["The multi-pass options allow a substep to be repeated until certain\n    conditions are met.  The current conditions are designed to fix\n    issues that are caused by disabled points causing geometry to be\n    caught and cause the undisabled points to generate stretching.  Since\n    collisions always pre-empt constraints, the result is cloth or\n    hair stretching.  Points adjacent to auto-disabled points will\n    be themselves disabled if too much stretching is detected.  The\n    solve step will then be repeated in the hopes this frees up the\n    geometry."], "extent": [11878, 12446]}], "container": true, "attrs": {"id": "domultipass"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Maximum Passes"], "extent": [12446, 12462], "body": [{"type": "para", "indent": 4, "text": ["The maximum number of times to repeat the substep.  If no new\n    points need to be disabled, the process will stop immediately."], "extent": [12485, 12619]}], "container": true, "attrs": {"id": "maxmultipass"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Disable Stretch Ratio"], "extent": [12619, 12642], "body": [{"type": "para", "indent": 4, "text": ["The amount of stretch at the end of a solve step that will trigger\n    points to be eligible for disabling.  This is to detect when failed\n    collisions are pulling the Vellum object apart. By failing additional\n    points the object usually can be released and result in a better\n    result than continuing to stretch."], "extent": [12672, 12998]}], "container": true, "attrs": {"id": "disablestretchratio"}, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Collisions"], "extent": [3349, 3368], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Disable Failed Collisions"], "extent": [3368, 3396], "body": [{"type": "para", "indent": 4, "text": ["If points fail to resolve their collisions after the post-collision passes,\n    they will be flagged as disabled, allowing them and any primitives attached\n    to them to move collision free."], "extent": [3430, 3628]}], "container": true, "attrs": {"id": "disablefailedcollisions"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Reset Collided Points"], "extent": [3628, 3651], "body": [{"type": "para", "indent": 4, "text": ["If a disabled point detects it is no longer in a tangled situation,\n    and is connected to non-disabled point, it will re-activate itself.  The\n    hope is that it has moved back to the correct side of the geometry."], "extent": [3675, 3898]}], "container": true, "attrs": {"id": "resetcollided"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Initialize Overlap Distances"], "extent": [3898, 3928], "body": [{"type": "para", "indent": 4, "text": ["The ", {"type": "code", "text": ["overlap_self"]}, " and ", {"type": "code", "text": ["overlap_external"]}, " attributes will be created\n    and initialized to respect the initial setup of the solver."], "extent": [3950, 4088]}, {"type": "para", "indent": 4, "text": ["Note if the attributes are already present, they will not be\n    initialized.  If the configuration has changed due to modeling\n    operations you may need to delete those attributes."], "extent": [4088, 4278]}], "container": true, "attrs": {"id": "initoverlap"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Update Overlap Distances"], "extent": [4278, 4304], "body": [{"type": "para", "indent": 4, "text": ["The ", {"type": "code", "text": ["overlap_self"]}, " and ", {"type": "code", "text": ["overlap_external"]}, " will be updated to reflect\n    the current configuration.   The only decrease with this operation,\n    so to initialize set to a large initial value."], "extent": [4328, 4525]}], "container": true, "attrs": {"id": "updateoverlap"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Tetrahedral Open Faces"], "extent": [4525, 4549], "body": [{"type": "para", "indent": 4, "text": ["The unshared faces of a tetrahedral mesh will generate collision geometry if this is set.  Sometimes one wishes to use both a triangle shell and a tetrahedral mesh, making this operation redundant."], "extent": [4565, 4769]}], "container": true, "attrs": {"id": "dotet"}, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Motion"], "extent": [4769, 4784], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Max Acceleration"], "extent": [13013, 13032], "body": [{"type": "para", "indent": 4, "text": ["Various acceleration limiting options can be used to prevent the\n    simulation from being over-eager to obey non-realistic forces.   These\n    can otherwise result in large energy spikes."], "extent": [13051, 13245]}], "container": true, "attrs": {"id": "maxaccel"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Fallback to First Order Integration on Collision"], "extent": [13245, 13295], "body": [{"type": "para", "indent": 4, "text": ["If ", {"type": "ui", "text": ["Max Acceleration"]}, " is exceeded for a point, assume it signals a sharp,\n    discontinuous collision where the second order prediction will be wrong\n    and add erroneous motion, often in the form of bouncing.  In this case,\n    fallback to first order integration for the affected point."], "extent": [13319, 13616]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [13616, 13626], "body": [{"type": "para", "indent": 8, "text": ["Grain and Fluid particles are always considered for fallback to first order,\n        not only in the case of collisions.  While this control is helpful to calm down\n        simulations and avoid stray particles, it can decrease overall splashiness\n        of grain and fluid motion. Increasing ", {"type": "ui", "text": ["Max Acceleration"]}, " can restore\n        that splashiness."], "extent": [13626, 13989]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "accelfallback"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Limit Acceleration in Velocity Update"], "extent": [13989, 14028], "body": [{"type": "para", "indent": 4, "text": ["Cap the amount that velocity of a particle is allowed to change as a\n    result of any of the dynamics.   This is useful to prevent some\n    instant motion being mis-identified as a massive force, and thus\n    avoid fly-away particles."], "extent": [14049, 14290]}], "container": true, "attrs": {"id": "limitaccel"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Limit Displacement on Collision"], "extent": [14290, 14323], "body": [{"type": "para", "indent": 4, "text": ["During the collision resolution, if the collision correction moves a\n    particle more than the acceleration amount, cap the effect.  The hope\n    is to fail more gracefully when a part of a model snags on the cloth\n    and is pulling it in a surprising fashion."], "extent": [14347, 14615]}], "container": true, "attrs": {"id": "limitdisplace"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Disable Broken Welds"], "extent": [14615, 14637], "body": [{"type": "para", "indent": 4, "text": ["When a weld breaks, the two new points start off next to each other.\n    If the surfaces do not separate naturally due to whatever triggered\n    the break, they may trigger collision detection and be pushed out,\n    causing an explosive motion when breaking occurs.  This option\n    sets the ", {"type": "code", "text": ["disableself"]}, " attribute when points are de-welded to avoid\n    these self collisions.  Note that this may cause layered cloth to\n    self penetrate, however."], "extent": [14666, 15121]}], "container": true, "attrs": {"id": "disablebrokenwelds"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Normalize Stress"], "extent": [15121, 15139], "body": [{"type": "para", "indent": 4, "text": ["Normalize the stress computation over time, so that the computed values\n    are more predictable as the ", {"type": "ui", "text": ["Substeps"]}, " parameter changes."], "extent": [15165, 15306]}], "container": true, "attrs": {"id": "normalizestress"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Breaking Frequency"], "extent": [5078, 5098], "body": [{"type": "para", "indent": 4, "text": ["How frequently welds and constraints are tested to see if they\n    have reached their breaking point.  Higher rates will give more\n    accuracy to the solve, but changes to the topology from a broken\n    constraint can slow down the solve considerably."], "extent": [5123, 5381]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Never"], "extent": [5381, 5392], "body": [{"type": "para", "indent": 8, "text": ["Do not test for any breaking."], "extent": [5392, 5431]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Per Frame"], "extent": [5431, 5446], "body": [{"type": "para", "indent": 8, "text": ["Check only once every frame, regardless of number of substeps."], "extent": [5446, 5518]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Per Substep"], "extent": [5518, 5535], "body": [{"type": "para", "indent": 8, "text": ["Check every substep."], "extent": [5535, 5565]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "breakfrequency"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Sliding Method"], "extent": [15306, 15322], "body": [{"type": "para", "indent": 4, "text": ["The method used for finding the next closest position on the target geometry\n    when sliding ", {"type": "ui", "text": ["Attach to Geometry"]}, " or ", {"type": "ui", "text": ["Stitch Points"]}, " constraints.\n    ", {"type": "ui", "text": ["Closest Point"]}, " simply chooses the closest point on the target geometry to\n    the projected sliding position.  This approach is fast but can improperly jump\n    across concavities in the target geometry.  ", {"type": "ui", "text": ["Traverse Polygons"]}, " starts from\n    the current target primitive and successively walks outwards, finding the closest\n    point on the surrounding primitives.  This approach is more expensive but handles\n    concave target geometry better.  ", {"type": "ui", "text": ["Traverse Triangles (Optimized)"]}, " is similar to\n    the previous option in its improved handling of concavities, but can be many times faster\n    as it uses specialized triangle distance functions.  However, it can only be used with\n    target geometry consisting of triangles."], "extent": [15346, 16237]}, {"type": "tip_group", "body": [{"type": "tip", "indent": 4, "role": "item", "extent": [16237, 16246], "body": [{"type": "para", "indent": 8, "text": ["Target geometry with quadrilaterals can be triangulated with the ", {"scheme": "Node", "value": "/nodes/sop/divide", "type": "link", "text": ["Divide"], "fullpath": "/nodes/sop/divide"}, " SOP."], "extent": [16246, 16350]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "slidingmethod"}, "role": "item"}], "container": true, "role": "item_group"}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Sleeping"], "extent": [5615, 5630], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Enable Auto Sleep"], "extent": [16367, 16387], "body": [{"type": "para", "indent": 4, "text": ["Particles that remain near-stationary for sufficient time will be\n    put to sleep by setting their ", {"type": "code", "text": ["stopped"]}, " attribute to ", {"type": "code", "text": ["1"]}, "."], "extent": [16409, 16542]}, {"type": "para", "indent": 4, "text": ["You can use the Pinned visualization to visualize which points are\n    sleeping."], "extent": [16542, 16628]}], "container": true, "attrs": {"id": "doautosleep"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Velocity Threshold"], "extent": [16628, 16648], "body": [{"type": "para", "indent": 4, "text": ["How slowly particles need to be moving before they are eligible\n    for sleeping.  The amount of time they remain below this speed\n    is accumulated in the ", {"type": "code", "text": ["deactivation_time"]}, " attribute.  If they\n    exceed this speed, the ", {"type": "code", "text": ["deactivation_time"]}, " is reset to zero."], "extent": [16681, 16948]}], "container": true, "attrs": {"id": "sleep_velocitythreshold"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Sleep Delay"], "extent": [16948, 16961], "body": [{"type": "para", "indent": 4, "text": ["How many seconds particles need to remain at or below the\n    velocity threshold before they are put to sleep.  See the\n    ", {"scheme": "Node", "value": "/nodes/dop/popawaken", "type": "link", "text": ["POP Awaken"], "fullpath": "/nodes/dop/popawaken"}, " DOP for methods to wake the\n    particles back up again."], "extent": [16982, 17200]}], "container": true, "attrs": {"id": "sleep_delay"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Grain Collisions"], "extent": [5785, 5810], "body": [{"type": "para", "indent": 0, "text": ["Vellum grains use a separate collision pass to deal with collisions\nbetween the grains.  These parameters control that behavior.  They\nare similar to those on ", {"scheme": "Node", "value": "/nodes/dop/popgrains", "type": "link", "text": ["POP Grains"], "fullpath": "/nodes/dop/popgrains"}], "extent": [5810, 6003]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Search Scale"], "extent": [16, 30], "body": [{"type": "para", "indent": 4, "text": ["Potential intersection particles are any within this scaled distance\n    of the average of the two particles ", {"type": "code", "text": ["pscale"]}, " attribute.  This\n    is an overestimate because usually collisions are not updated\n    during the constraint iterations, so it needs to record not\n    just the currently colliding particles, but those that may\n    start to collide due to the earlier iterations."], "extent": [58, 443]}, {"type": "para", "indent": 4, "text": ["This also effects the range of the attraction force in clumping."], "extent": [443, 513]}], "container": true, "attrs": {"id": "grain_searchscale"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Max Neighbors"], "extent": [513, 528], "body": [{"type": "para", "indent": 4, "text": ["The maximum number of particles that will be considered when searching for potential collisions over the substep. Capping this is useful to avoid excessive computations, if too many particles are created at one spot.  This parameter is ignored if ", {"type": "ui", "text": ["OpenCL Neighbor Search"]}, " is enabled, in which\n    case all neighbors are considered within the radius determined by ", {"type": "ui", "text": ["Search Scale"]}, "."], "extent": [556, 944]}], "container": true, "attrs": {"id": "grain_maxneighbor"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Assume Uniform Radius"], "extent": [1338, 1361], "body": [{"type": "para", "indent": 4, "text": ["The ", {"type": "code", "text": ["pscale"]}, " attribute is used to determine the radius of each\n    particle.  If all particles have the same radius, faster acceleration\n    structures can be used to find neighbors."], "extent": [1391, 1579]}], "container": true, "attrs": {"id": "grain_uniformradius"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Ignore Neighbors in Same Piece"], "extent": [1579, 1611], "body": [{"type": "para", "indent": 4, "text": ["Ignore any neighbors that have the same non-negative value for the ", {"type": "code", "text": ["piece"]}, " point attribute.\n    This option can be enabled to create separate clusters of grains that only interact\n    with other clusters, often in conjunction with a ", {"type": "ui", "text": ["Shape Match"]}, " constraint to give\n    rigid behavior.  The ", {"scheme": "Node", "value": "/nodes/sop/vdbtospheres", "type": "link", "text": ["VDB To Spheres"], "fullpath": "/nodes/sop/vdbtospheres"}, " SOP can be a good method\n    for filling objects with overlapping grains."], "extent": [1633, 2044]}], "container": true, "attrs": {"id": "ignorepiece"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Enable Constraint Averaging"], "extent": [2044, 2073], "body": [{"type": "para", "indent": 4, "text": ["When multiple particles collide at the same time, this will average\n    out all the constraints.  This is effective in ensuring stability, but does\n    not preserver momentum.  Thus, when combined with internal forces, such as\n    clumping, bunches of particles may accelerate under their own force."], "extent": [2105, 2410]}], "container": true, "attrs": {"id": "doconstraintaveraging"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Repulsion Weight"], "extent": [2410, 2428], "body": [{"type": "para", "indent": 4, "text": ["A weighting for how much the particle collision forces are weighted.\n    A value of zero will disable particle collision."], "extent": [2454, 2581]}, {"type": "para", "indent": 4, "text": ["Scale with the ", {"type": "code", "text": ["repulsionweight"]}, " point attribute."], "extent": [2581, 2636]}], "container": true, "attrs": {"id": "repulsionweight"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Repulsion"], "extent": [2636, 2647], "body": [{"type": "para", "indent": 4, "text": ["How strongly particles are kept apart.  Higher values result in\n    less bouncy repulsion."], "extent": [2676, 2772]}], "container": true, "attrs": {"id": "repulsionstiffness"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Attraction Weight"], "extent": [2772, 2791], "body": [{"type": "para", "indent": 4, "text": ["A weighting for how much the particles will naturally stick together\n    when close.  A value of zero will disable particle clumping."], "extent": [2818, 2957]}, {"type": "para", "indent": 4, "text": ["Scale with the ", {"type": "code", "text": ["attractionweight"]}, " point attribute."], "extent": [2957, 3013]}], "container": true, "attrs": {"id": "attractionweight"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Attraction"], "extent": [3013, 3025], "body": [{"type": "para", "indent": 4, "text": ["How strongly nearby particles stick to each other.  Higher values\n    result in a less bouncy adhesion."], "extent": [3055, 3164]}], "container": true, "attrs": {"id": "attractionstiffness"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Enable Mass Shock"], "extent": [3164, 3183], "body": [{"type": "para", "indent": 4, "text": ["Artificially scales the mass of particles according to their position\n    with respect to gravity.  By making particles higher up lighter,\n    stacks of particles will converge faster and be more stable."], "extent": [3205, 3414]}], "container": true, "attrs": {"id": "domassshock"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Shock Scaling Power"], "extent": [3414, 3435], "body": [{"type": "para", "indent": 4, "text": ["The amount of scaling to perform.  Higher numbers increase the\n    contrast between successive particles.  A value of 0 will\n    cause no ratio between particles, a value of 1 a 15% ratio\n    between two particles stacked vertically."], "extent": [3460, 3699]}, {"type": "para", "indent": 4, "text": ["Too high a number makes higher particles extremely light\n    and destabilizes the system."], "extent": [3699, 3794]}], "container": true, "attrs": {"id": "massshockpower"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Shock Axis"], "extent": [3794, 3806], "body": [{"type": "para", "indent": 4, "text": ["The up-vector used to define a gradient of particle masses."], "extent": [3830, 3895]}, {"type": "para", "indent": 4, "text": ["Should be in the direction of stacking, so usually is\n    opposite to that of gravity."], "extent": [3895, 3987]}], "container": true, "attrs": {"id": "massshockaxis"}, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Fluids"], "extent": [6663, 6678], "body": [{"type": "para", "indent": 0, "text": ["Vellum fluids use a density constraint to keep fluids incompressible, as well\nas provide viscosity and surface tension.  Any particle with a non-zero ", {"type": "code", "text": ["phase"]}, "\nattribute is treated as fluid."], "extent": [6678, 6869]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Kernel Radius Scale"], "extent": [3987, 4008], "body": [{"type": "para", "indent": 4, "text": ["The radius of the kernel used for fluid calculations.  In general the default value\n    of 4 is recommended, but it can be increased or reduced slightly for different effects.\n    In particular this value can effect the size of the drops created by surface tension, with\n    larger values creating larger drops and fewer individual particles. Note that larger values\n    will result in slower simulation and more memory usage for neighbor lists.  Also values\n    much below 3 or above 5 can lead to instability."], "extent": [4036, 4553]}], "container": true, "attrs": {"id": "fluid_searchscale"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Viscosity"], "extent": [4553, 4564], "body": [{"type": "para", "indent": 4, "text": ["The viscosity of the fluid.  Low values for viscosity help keep the simulation stable,\n    while higher values can simulate liquids like honey.  A per-particle ", {"type": "code", "text": ["viscosity"]}, " attribute\n    can be used to multiply this value for variable viscosity.  Fluid particles will different\n    ", {"type": "code", "text": ["phase"]}, " values will be solved independently for viscosity, allowing multi-phase fluid\n    behavior."], "extent": [4584, 4970]}], "container": true, "attrs": {"id": "viscosity"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["SDF Collision Viscosity"], "extent": [4970, 4995], "body": [{"type": "para", "indent": 4, "text": ["The viscosity of the fluid in contact with an SDF collision. This value is currently only\n    used when ", {"type": "ui", "text": ["Enable Minimal Solver"]}, " is enabled and the solver has a ground plane or\n    SDF collision object."], "extent": [5024, 5233]}], "container": true, "attrs": {"id": "collisionviscosity"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Viscosity Solver"], "extent": [5233, 5251], "body": [{"type": "para", "indent": 4, "text": ["The type of viscosity solve to perform.  ", {"type": "ui", "text": ["Explicit"]}, " is fast but can be unstable for high particle\n    counts, high viscosity, or low substeps.  ", {"type": "ui", "text": ["Implicit"]}, " is slower but remains stable even for higher\n    particle counts and viscosity values."], "extent": [5277, 5528]}], "container": true, "attrs": {"id": "viscositysolver"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Viscosity Tolerance"], "extent": [5528, 5549], "body": [{"type": "para", "indent": 4, "text": ["The tolerance for the viscosity solve when using the ", {"type": "ui", "text": ["Implicit"]}, " solve.  Lower values are more accurate \n    at the cost of more iterations."], "extent": [5563, 5710]}], "container": true, "attrs": {"id": "tol"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Max Viscosity Iterations"], "extent": [5710, 5736], "body": [{"type": "para", "indent": 4, "text": ["The maximum number of iterations for the ", {"type": "ui", "text": ["Implicit"]}, " viscosity solve."], "extent": [5769, 5845]}], "container": true, "attrs": {"id": "maxviscosityiterations"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Surface Tension"], "extent": [5845, 5862], "body": [{"type": "para", "indent": 4, "text": ["The surface tension of the fluid.  Higher values for this setting reduce the curvature of the fluid\n    and cause it to form blobs.  A per-particle ", {"type": "code", "text": ["surfacetension"]}, " attribute\n    can be used to multiply this value for variable surface tension.  Fluid particles will different\n    ", {"type": "code", "text": ["phase"]}, " values will be solved independently for surface tension, allowing multi-phase fluid\n    behavior."], "extent": [5887, 6278]}], "container": true, "attrs": {"id": "surfacetension"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Spatial Sort Interval"], "extent": [6278, 6301], "body": [{"type": "para", "indent": 4, "text": ["Vellum fluids and grains perform many calculations involving nearby points.  Generally performance\n    is greatly improved by ensuring that points that are near other in 3D space are also near each other in\n    memory.  This option enables a spatial sort of the particles at the specified interval of frames."], "extent": [6323, 6641]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [6641, 6651], "body": [{"type": "para", "indent": 8, "text": ["This sort will change the point numbers of the particles, so it can be useful to add an ", {"type": "code", "text": ["id"]}, " attribute before simulation."], "extent": [6651, 6782]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "sortinterval"}, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Minimal Solver"], "extent": [7292, 7315], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Enable Minimal Solver"], "extent": [7315, 7339], "body": [{"type": "para", "indent": 4, "text": ["Enable a limited version of the solver used by the ", {"scheme": "Node", "value": "/nodes/sop/vellumbrush", "type": "link", "text": ["Vellum Brush SOP"], "fullpath": "/nodes/sop/vellumbrush"}, ". Currently this is an internal feature used only for brushing, since there are limitations. It allows for cloth and other softbodies to interact with static geometry very quickly. However, it doesn\u2019t work with animated collisions or any kind of animated input. This option is not recommended for end users."], "extent": [7361, 7764]}], "container": true, "attrs": {"id": "minimalmode"}, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["OpenCL"], "extent": [7764, 7779], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Kernel Options"], "extent": [7779, 7796], "body": [{"type": "para", "indent": 4, "text": ["Specify any desired compile flags for the kernel."], "extent": [7820, 7875]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [7875, 7885], "body": [{"type": "para", "indent": 8, "text": ["The Apple OSX OpenCL compiler requires only a single space between kernel options!"], "extent": [7885, 7978]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "kerneloptions"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Finish Kernels"], "extent": [7978, 7994], "body": [{"type": "para", "indent": 4, "text": ["When Finish Kernels is disabled, no attempt is to wait for the\n    OpenCL kernels to complete before continuing the next solver.\n    This lets them run in the background until their results\n    are actually needed.  To simplify debugging or timing, it is useful\n    to ensure kernels are finished to make sure errors are detected\n    in the right spot."], "extent": [8011, 8370]}], "container": true, "attrs": {"id": "finish"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Recompile Kernels"], "extent": [8370, 8389], "body": [{"type": "para", "indent": 4, "text": ["When loading kernels from disk the kernel is cached to avoid\n    regenerating it every solve.  Turning this on forces the re-loading\n    and recompiling of the kernel.  This is useful if #include files\n    refer to code that has changed, or the kernel file is changed\n    in an external text editor."], "extent": [8409, 8714]}, {"type": "para", "indent": 4, "text": ["It should always be disabled when prototyping is complete."], "extent": [8714, 8778]}], "container": true, "attrs": {"id": "recompile"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["OpenCL Graph Coloring"], "extent": [18222, 18246], "body": [{"type": "para", "indent": 4, "text": ["When doing graph coloring, a fast parallel OpenCL algorithm is used.\n    Unfortunately it may require 10\u00d7 more memory than the rest of the\n    solve on tetrahedral meshes.  Thus, systems that might fit in memory\n    for solving will not succeed the color pass.  Disabling this forces\n    all graph coloring to be done in a slower sequential manner, preserving\n    RAM for the actual solve."], "extent": [18270, 18665]}], "container": true, "attrs": {"id": "oclgraphcolor"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["OpenCL Neighbor Search"], "extent": [18665, 18689], "body": [{"type": "para", "indent": 4, "text": ["Perform any neighbor searches for grains and fluids using OpenCL, which\n    is faster than the CPU but can use a bit more GPU memory."], "extent": [18717, 18856]}], "container": true, "attrs": {"id": "oclneighborsearch"}, "role": "item"}], "container": true, "role": "item_group"}]}]}], "text": "Parameters"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [8879, 8888], "body": [{"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": [{"scheme": "Node", "value": "/nodes/dop/vellumobject", "type": "link", "text": "", "fullpath": "/nodes/dop/vellumobject"}], "extent": [8888, 8918]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"scheme": "Node", "value": "/nodes/dop/vellumsource", "type": "link", "text": "", "fullpath": "/nodes/dop/vellumsource"}], "extent": [8918, 8948]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"scheme": "Node", "value": "/nodes/dop/vellumconstraints", "type": "link", "text": "", "fullpath": "/nodes/dop/vellumconstraints"}], "extent": [8948, 8984]}], "container": true}], "text": "Related"}], "title": ["Vellum Solver"], "summary": ["Sets and configures a Vellum solver."], "included": ["/nodes/dop/standard_fluid_grains_parms", "/nodes/sop/_vellum_common", "/nodes/sop/vellumsolver"]}