{"type": "root", "attrs": {"type": "node", "context": "lop", "internal": "followpathconstraint", "icon": "SHELF/followpath", "tags": "constraints", "since": "18.0", "version": null, "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Follow Path Constraint"], "extent": [0, 27]}, {"type": "summary", "indent": 0, "text": ["Constrains a prim to follow a path curve."], "extent": [142, 191]}, {"level": 2, "id": "about", "container": true, "type": "h", "indent": 0, "text": ["Solaris constraints"], "extent": [1325, 1359], "body": [{"type": "para", "indent": 0, "text": ["Currently, USD does not support constraints. Parametric constraints are probably antithetical to USD\u2019s design mission of being descriptive, immutable, and idempotent."], "extent": [1359, 1528]}, {"type": "para", "indent": 0, "text": ["As a layer above USD, that generates USD, the LOP network can compute dynamic constraints, and ", {"type": "q", "text": ["bake"]}, " the results as time samples when it writes the USD to disk."], "extent": [1528, 1694]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Notes and tips"], "extent": [222, 243], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["You ", {"type": "strong", "text": ["cannot"]}, " use a nested point instance as a source (the thing constrained to the path)."], "extent": [243, 337]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You ", {"type": "strong", "text": ["can"]}, " use a nested point instance as a path."], "extent": [337, 389]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["By default, geometry imported from SOPs (for example, through ", {"scheme": "Node", "value": "/nodes/lop/sopimport", "type": "link", "text": ["SOP Import"], "fullpath": "/nodes/lop/sopimport"}, " or ", {"scheme": "Node", "value": "/nodes/lop/sopcreate", "type": "link", "text": ["SOP Create"], "fullpath": "/nodes/lop/sopcreate"}, ") has point attributes imported into USD. So you can set up attributes (for example, an up vector attribute) in SOPs and use them in this node."], "extent": [389, 664]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["In VEX snippets, you can use ", {"type": "code", "text": ["@"]}, " variable names containing colons (", {"type": "code", "text": [":"]}, "). This makes it easier to automatically bind certain USD attribute names (for example ", {"type": "code", "text": ["i@primvars:foo"]}, "). (These names are not normally legal in names in VEX source code. The node automatically encodes these kinds of names when used in a snippet.)"], "extent": [16, 336]}], "container": true}]}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [691, 703], "body": [{"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Source"], "extent": [703, 717], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Type"], "extent": [717, 724], "body": [{"type": "para", "indent": 4, "text": ["Whether the source (the thing constrained to follow a path) is a regular primitive, or a point instance. You ", {"type": "strong", "text": ["cannot"]}, " use a nested point instance as a source."], "extent": [724, 888]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}, {"type": "include_group", "body": [{"ext": "_constraints#source", "type": "include", "indent": 0, "role": "item", "extent": [888, 919]}], "container": true, "role": "item_group"}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Source Instances"], "extent": [126, 144], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Source \u25b8 Type"]}, " is ", {"type": "q", "text": ["Point Intance"]}, ", the point instance to use, using ", {"type": "code", "text": ["/", {"type": "var", "text": ["path"]}, "[", {"type": "var", "text": ["instance_index"]}, "]"]}, " syntax (for example, ", {"type": "code", "text": ["/geometry/instancer[1]"]}, ")."], "extent": [170, 331]}], "container": true, "attrs": {"id": "sourceinstances"}, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Path"], "extent": [960, 971], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Target Source"], "extent": [971, 987], "body": [{"type": "para", "indent": 4, "text": ["Where to get the path curve to follow, either the first input or the second input."], "extent": [987, 1075]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Type"], "extent": [1075, 1081], "body": [{"type": "para", "indent": 4, "text": ["Whether the path is a regular primitive, or a point instance. (You ", {"type": "strong", "text": ["can"]}, " use a nested point instance as a target.)"], "extent": [1081, 1201]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}, {"type": "include_group", "body": [{"ext": "_constaints#target", "type": "include", "indent": 0, "role": "item", "extent": [1201, 1231]}, {"ext": "_constaints#targetinstance", "type": "include", "indent": 0, "role": "item", "extent": [1231, 1269]}, {"ext": "_constaints#hidetarget", "type": "include", "indent": 0, "role": "item", "extent": [1269, 1304]}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Constraint Options"], "extent": [1304, 1329], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Import Time"], "extent": [807, 820], "body": [{"type": "para", "indent": 4, "text": ["Specify the frame at which the source and/or target geometry are imported into the embedded sopnet to build the constraints. \n    The default ", {"type": "q", "text": ["$FF"]}, " expression forces the constraint LOP to be time dependent, which is needed when operating on a non time-dependent\n    network that has time samples driving the source or target primitives.\n    However, for better performance with a non time-dependent network with no time samples, it is recommended to use a static value instead."], "extent": [841, 1325]}], "container": true, "attrs": {"id": "importtime"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Maintain Local Offset"], "extent": [1365, 1388], "body": [{"type": "para", "indent": 4, "text": ["When this is off (the default), the source object snaps onto the path it follows. When this is on, the object maintains the same relative distance between itself and the path as it follows the shape of the path."], "extent": [1388, 1605]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Parametrization"], "extent": [1605, 1622], "body": [{"type": "para", "indent": 4, "text": ["How to map the ", {"type": "ui", "text": ["Position"]}, " value onto the path."], "extent": [1622, 1676]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Normalized Distance"], "extent": [1676, 1701], "body": [{"type": "para", "indent": 8, "text": ["Make ", {"type": "code", "text": ["0"]}, " the start of the curve and ", {"type": "code", "text": ["1"]}, " the end of the curve, with fractional values in between are divided by the arc length of the curve."], "extent": [1701, 1850]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Normalized Knots"], "extent": [1850, 1872], "body": [{"type": "para", "indent": 8, "text": ["Make ", {"type": "code", "text": ["0"]}, " the start of the curve and ", {"type": "code", "text": ["1"]}, " the end of curve, where fractional values in between are divided by the distances between knots/edit points."], "extent": [1872, 2030]}, {"type": "para", "indent": 8, "text": ["For example, if a polyline has 5 points (two ends and three interior corners), the distance at each successive point would be ", {"type": "code", "text": ["0.0"]}, ", ", {"type": "code", "text": ["0.25"]}, ", ", {"type": "code", "text": ["0.5"]}, ", ", {"type": "code", "text": ["0.75"]}, ", and ", {"type": "code", "text": ["1.0"]}, "."], "extent": [2030, 2206]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Distance from Start"], "extent": [2206, 2231], "body": [{"type": "para", "indent": 8, "text": ["Use the ", {"type": "ui", "text": ["Position"]}, " as an arc-length distance (in world units) from the ", {"type": "strong", "text": ["start"]}, " of the curve."], "extent": [2231, 2335]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Distance from End"], "extent": [2335, 2358], "body": [{"type": "para", "indent": 8, "text": ["Use the ", {"type": "ui", "text": ["Position"]}, " as an arc-length distance (in world units) from the ", {"type": "strong", "text": ["end"]}, " of the curve."], "extent": [2358, 2460]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Distance Point Attribute"], "extent": [2460, 2490], "body": [{"type": "para", "indent": 8, "text": ["Get the ", {"type": "q", "text": ["distance"]}, " value at each point in the curve from a primvar. The primvar must be a ", {"type": "code", "text": ["vector3"]}, ", but only the first (X) component is used. The X values should monotonically increase along the curve or the result will be very weird."], "extent": [2490, 2735]}], "container": true}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Distance Attribute"], "extent": [2735, 2755], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Parameterization"]}, " is ", {"type": "q", "text": ["Distance point attribute"]}, ", the name of the primvar containing the distance value (not including the ", {"type": "code", "text": ["primvar:"]}, " prefix). The primvar must be a ", {"type": "code", "text": ["vector3"]}, ", but only the first (X) component is used."], "extent": [2755, 2985]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Position"], "extent": [2985, 2995], "body": [{"type": "para", "indent": 4, "text": ["Where to position the source object along the path. To animate the source object along the path, this should be an expression based on the current frame (", {"type": "code", "text": ["$F"]}, ") or time (", {"type": "code", "text": ["$T"]}, ")."], "extent": [2995, 3176]}, {"type": "para", "indent": 4, "text": ["For example, if ", {"type": "ui", "text": ["Parameterizaiton"]}, " is ", {"type": "q", "text": ["Normalized distance"]}, ", you might set this to ", {"type": "code", "text": ["$F/100"]}, "."], "extent": [3176, 3276]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Use Snippet"], "extent": [3276, 3289], "body": [{"type": "para", "indent": 4, "text": ["Set the position using a VEX snippet. The snippet should write the position value to the ", {"type": "code", "text": ["pos"]}, " variable. You can use the variables typically available to an ", {"scheme": "Node", "value": "/nodes/sop/attribwrangle", "type": "link", "text": ["Attribute Wrangle SOP"], "fullpath": "/nodes/sop/attribwrangle"}, ". ", {"type": "code", "text": ["@ptnum"]}, " is the index of the current prim being constrained. You can use ", {"type": "code", "text": ["npoints(0)"]}, " to get the total number of prims being constrained. You can use ", {"type": "code", "text": ["@Frame"]}, " and ", {"type": "code", "text": ["@Time"]}, " to make the snippet time-dependent."], "extent": [3289, 3706]}, {"type": "para", "indent": 4, "text": ["The initial value of ", {"type": "code", "text": ["pos"]}, " (at the start of the snippet) is the evaluated value of the ", {"type": "ui", "text": ["Position"]}, " parameter. So you can use an expression in that parameter to compute a ", {"type": "q", "text": ["base"]}, " value, and modify it using the snippet."], "extent": [3706, 3930]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Orientation"], "extent": [3930, 3948], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Look At Mode"], "extent": [3948, 3963], "body": [{"type": "para", "indent": 4, "text": ["How to compute the direction the source object points along."], "extent": [3963, 4029]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["None"], "extent": [4029, 4039], "body": [{"type": "para", "indent": 8, "text": ["Don\u2019t rotate the source object to look at anything."], "extent": [4039, 4100]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Along Path"], "extent": [4100, 4116], "body": [{"type": "para", "indent": 8, "text": ["Point along the path curve\u2019s tangent direction. This is usually what you want, so it looks like the object is following the curve."], "extent": [4116, 4256]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Direction Attribute from Path"], "extent": [4256, 4291], "body": [{"type": "para", "indent": 8, "text": ["Use a ", {"type": "code", "text": ["vector3f"]}, " primvar on the curve to specify the look at vector at each point."], "extent": [4291, 4383]}, {"type": "para", "indent": 8, "text": ["From Primitive:\n        Rotate the source prim to point at a specific prim."], "extent": [4383, 4468]}], "container": true}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Look At Source"], "extent": [4468, 4484], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Look at mode"]}, " is ", {"type": "q", "text": ["from primitive"]}, ", where to get the primitive to look at (the first or second input)."], "extent": [4507, 4622]}], "container": true, "attrs": {"id": "lookatsource"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Look At Xform"], "extent": [4622, 4637], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Look at mode"]}, " is ", {"type": "q", "text": ["from primitive"]}, ", the scene graph path of the prim to look at. (This does not support looking at a point instance.)"], "extent": [4659, 4805]}], "container": true, "attrs": {"id": "lookatxform"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Direction Attribute"], "extent": [4805, 4826], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Look at mode"]}, " is ", {"type": "q", "text": ["Direction attribute from path"]}, ", the name of a ", {"type": "code", "text": ["vector3f"]}, " primvar (minus the ", {"type": "code", "text": ["primvar:"]}, " prefix) to use as the look at direction."], "extent": [4826, 4985]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Look Up Mode"], "extent": [4985, 4999], "body": [{"type": "para", "indent": 4, "text": ["How to compute the up vector."], "extent": [4999, 5034]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Up Vector Attribute from Path"], "extent": [5034, 5069], "body": [{"type": "para", "indent": 8, "text": ["Use ", {"type": "code", "text": ["vector3f"]}, " primvar on the curve to specify the up vector at each point."], "extent": [5069, 5154]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Along Path"], "extent": [5154, 5170], "body": [{"type": "para", "indent": 8, "text": ["Use the path tangent as the Up vector."], "extent": [5170, 5218]}], "container": true}, {"type": "dt", "indent": 4, "text": ["X Axis"], "extent": [5218, 5230], "body": [{"type": "para", "indent": 12, "text": ["Use the world +X direction as the up vector."], "extent": [5230, 5288]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Y Axis"], "extent": [5288, 5300], "body": [{"type": "para", "indent": 12, "text": ["Use the world +Y direction as the up vector."], "extent": [5300, 5358]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Z Axis"], "extent": [5358, 5370], "body": [{"type": "para", "indent": 12, "text": ["Use the world +Z direction as the up vector."], "extent": [5370, 5428]}], "container": true}, {"type": "dt", "indent": 4, "text": ["From Primitive"], "extent": [5428, 5448], "body": [{"type": "para", "indent": 12, "text": ["Rotate the source prim so its up vector points at a specific prim as it moves along the curve."], "extent": [5448, 5556]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Custom"], "extent": [5556, 5568], "body": [{"type": "para", "indent": 8, "text": ["Use the vector in the ", {"type": "ui", "text": ["Up vector"]}, " parameter."], "extent": [5568, 5624]}], "container": true}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Up Vector Source"], "extent": [5624, 5642], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Look up mode"]}, " is ", {"type": "q", "text": ["from primitive"]}, ", where to get the primitive to point the up vector at (the first or second input)."], "extent": [5667, 5797]}], "container": true, "attrs": {"id": "upvectorsource"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Up Vector Xform"], "extent": [5797, 5814], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Look at mode"]}, " is ", {"type": "q", "text": ["from primitive"]}, ", the scene graph path of the prim to point the up vector at. (This does not support point instances.)"], "extent": [5838, 5987]}], "container": true, "attrs": {"id": "upvectorxform"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Look At Axis"], "extent": [5987, 6001], "body": [{"type": "para", "indent": 4, "text": ["Which axis on the source object to match to the look at vector. You can use this to compensate for the orientation the source object was created in. This can\u2019t be the same as the ", {"type": "ui", "text": ["Look up axis"]}, "."], "extent": [6022, 6224]}], "container": true, "attrs": {"id": "lookataxis"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Look Up Axis"], "extent": [6224, 6238], "body": [{"type": "para", "indent": 4, "text": ["Which axis on the source object to match to the up vector. You can use this to compensate for the orientation the source object was created in.  This can\u2019t be the same as the ", {"type": "ui", "text": ["Look at axis"]}, "."], "extent": [6259, 6457]}], "container": true, "attrs": {"id": "lookupaxis"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Up Attribute"], "extent": [6457, 6471], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Look up mode"]}, " is ", {"type": "q", "text": ["Up attribute from path"]}, ", the name of a ", {"type": "code", "text": ["vector3f"]}, " primvar (minus the ", {"type": "code", "text": ["primvar:"]}, " prefix) to use as the look up vector."], "extent": [6471, 6620]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Roll"], "extent": [6620, 6626], "body": [{"type": "para", "indent": 4, "text": ["Roll angle (in degrees) around the look at direction. You can use this, for example, to animate ", {"type": "q", "text": ["banking"]}, " as the source object goes around curves."], "extent": [6626, 6778]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Use Snippet"], "extent": [6778, 6791], "body": [{"type": "para", "indent": 4, "text": ["Set the roll using a VEX snippet. The snippet should write the roll degrees to the ", {"type": "code", "text": ["roll"]}, " variable. You can use the variables typically available to an ", {"scheme": "Node", "value": "/nodes/sop/attribwrangle", "type": "link", "text": ["Attribute Wrangle SOP"], "fullpath": "/nodes/sop/attribwrangle"}, ". ", {"type": "code", "text": ["@ptnum"]}, " is the index of the current prim being constrained. You can use ", {"type": "code", "text": ["npoints(0)"]}, " to get the total number of prims being constrained. You can use ", {"type": "code", "text": ["@Frame"]}, " and ", {"type": "code", "text": ["@Time"]}, " to make the snippet time-dependent."], "extent": [6816, 7228]}, {"type": "para", "indent": 4, "text": ["The initial value of ", {"type": "code", "text": ["roll"]}, " (at the start of the snippet) is the evaluated value of the ", {"type": "ui", "text": ["Roll"]}, " parameter. So you can use an expression in that parameter to compute a ", {"type": "q", "text": ["base"]}, " value, and modify it using the snippet."], "extent": [7228, 7449]}], "container": true, "attrs": {"id": "userollsnippet"}, "role": "item"}], "container": true, "role": "item_group"}]}], "text": "Parameters"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [7449, 7458], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/lop/lookatconstraint", "type": "link", "text": "", "fullpath": "/nodes/lop/lookatconstraint"}], "extent": [7458, 7489]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/lop/parentconstraint", "type": "link", "text": "", "fullpath": "/nodes/lop/parentconstraint"}], "extent": [7489, 7519]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/lop/pointsconstraint", "type": "link", "text": "", "fullpath": "/nodes/lop/pointsconstraint"}], "extent": [7519, 7549]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/lop/surfaceconstraint", "type": "link", "text": "", "fullpath": "/nodes/lop/surfaceconstraint"}], "extent": [7549, 7583]}], "container": true}], "text": "Related"}], "title": ["Follow Path Constraint"], "summary": ["Constrains a prim to follow a path curve."], "included": ["/nodes/lop/_constraints", "/nodes/lop/_snippet_token"]}