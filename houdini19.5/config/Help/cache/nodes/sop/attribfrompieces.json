{"type": "root", "attrs": {"type": "node", "context": "sop", "internal": "attribfrompieces", "icon": "SOP/attribfrompieces", "since": "18.5", "tags": "copy, random, points", "version": null, "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Attribute From Pieces"], "extent": [0, 26]}, {"type": "summary", "indent": 0, "text": ["Assigns an attribute to points specifying which of a set of models should be copied/instanced to that point, randomly or based on various rules."], "extent": [151, 304]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Overview"], "extent": [304, 319], "body": [{"type": "para", "indent": 0, "text": ["Houdini\u2019s workflow for automatically creating large numbers of objects in a scene (such as trees in a forest, rocks and pebbles in a desert, or buildings in a city) is as follows:"], "extent": [319, 501]}, {"type": "ord_group", "body": [{"blevel": 2, "type": "ord", "indent": 0, "text": ["Build the surface you want to scatter the objects across."], "extent": [501, 562]}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["Use the ", {"scheme": "Node", "value": "/nodes/sop/scatteralign", "type": "link", "text": ["Scatter and Align node"], "fullpath": "/nodes/sop/scatteralign"}, " to scatter points across the surface."], "extent": [562, 658], "body": [{"type": "para", "indent": 4, "text": ["Scatter and Align has many high-level controls for how to distribute the points, avoid certain areas, add variety in size and orientation, and so on."], "extent": [658, 813]}], "container": true}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["Build the set of models you want to copy onto the points. For example, a set of different types and shapes of trees to make a forest."], "extent": [813, 950]}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["Use the ", {"scheme": "Node", "value": "/nodes/sop/copytopoints", "type": "link", "text": ["Copy to Points node"], "fullpath": "/nodes/sop/copytopoints"}, " to copy the objects onto the points."], "extent": [950, 1042], "body": [{"type": "para", "indent": 4, "text": ["Copy to Points has a ", {"type": "ui", "text": ["Piece Attribute"]}, " parameter that chooses which of the set of models to copy onto each point based on the value of an attribute on the point."], "extent": [1042, 1211]}], "container": true}], "container": true}, {"type": "para", "indent": 0, "text": ["This node is a powerful and flexible way to create the ", {"type": "q", "text": ["piece"]}, " attribute used by Copy to Points to decide which model to copy onto each point. It lets you assign the pieces randomly, or according to various rules. For example, you could make deciduous trees more likely at lower elevations and conifer trees more likely at higher elevations on a mountain."], "extent": [1211, 1569]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Visualizing the results"], "extent": [1569, 1599], "body": [{"type": "para", "indent": 0, "text": ["The best way to use this node is to set up the network to create the pieces, scatter the points, this node to assign a attribute specifying which piece to copy onto each point, and a ", {"scheme": "Node", "value": "/nodes/sop/copytopoints", "type": "link", "text": ["Copy to Points node"], "fullpath": "/nodes/sop/copytopoints"}, " to copy the pieces onto the points (make sure you set the piece attribute on the Copy to Points node). Then you can select this node and tweak the parameters based on how they affect the copies/instances."], "extent": [1599, 2033]}, {"type": "para", "indent": 0, "text": ["Even if you don\u2019t have the finished models for the pieces, it\u2019s helpful to create simple proxies (for example, different simple shapes or shapes with different colors) for the pieces so you can visualize how the distribution changes as you edit the parameters."], "extent": [2033, 2295]}, {"type": "para", "indent": 0, "text": [{"scheme": "Image", "value": "/images/nodes/sop/attrib_from_pieces_network.jpg", "type": "img", "text": ""}], "extent": [2295, 2354]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Understanding pieces"], "extent": [2354, 2381], "body": [{"type": "para", "indent": 0, "text": ["Houdini SOP geometry is conceptually just a bunch of unstructured primitives (polygon faces), it does not have an inherent concept of separate ", {"type": "q", "text": ["objects"]}, " or hierarchy of primitives. Instead, the way nodes can tell that a set of faces are part of the same thing is that they all have the same value in a certain attribute. For example, assuming the node is using a piece attribute named ", {"type": "code", "text": ["piece"]}, ", all polygons where the point attribute ", {"type": "code", "text": ["piece"]}, " equals ", {"type": "code", "text": ["2"]}, " are part of the same conceptual object."], "extent": [2381, 2875]}, {"type": "para", "indent": 0, "text": ["The piece attribute may be an integer or string attribute. This attribute is often called ", {"type": "code", "text": ["piece"]}, ", ", {"type": "code", "text": ["class"]}, ", ", {"type": "code", "text": ["name"]}, ", or ", {"type": "code", "text": ["path"]}, "."], "extent": [2875, 3003]}, {"type": "para", "indent": 0, "text": ["You can create a piece attribute on geometry using the ", {"scheme": "Node", "value": "/nodes/sop/connectivity", "type": "link", "text": ["Connectivity node"], "fullpath": "/nodes/sop/connectivity"}, " to automatically create a piece attribute). This is usually all you need. If you need more fine-grained control (if individual objects have disconnected parts), you can use a series of upstream ", {"scheme": "Node", "value": "/nodes/sop/attribcreate", "type": "link", "text": ["Attribute Create nodes"], "fullpath": "/nodes/sop/attribcreate"}, " to ", {"type": "q", "text": ["manually"]}, " assign value to the piece attribute for each separate set of faces."], "extent": [3003, 3424]}, {"type": "para", "indent": 0, "text": ["This node works by creating an attribute on the ", {"type": "em", "text": ["points"]}, " that the pieces will be copied onto in the scattering workflow. For each point, the value of this attribute specifies that the ", {"scheme": "Node", "value": "/nodes/sop/copytopoints", "type": "link", "text": ["Copy to Points node"], "fullpath": "/nodes/sop/copytopoints"}, " should copy the piece with the same attribute value from the source geometry on this point."], "extent": [3424, 3745]}, {"type": "para", "indent": 0, "text": ["This node doesn\u2019t copy the pieces onto the points (it just creates the attribute that Copy to Points uses to do that), but you do need to connect the geometry containing the pieces to this node\u2019s second input (and specify the name of the piece attribute) so it can see what pieces are available. This means you must have geometry with a piece attribute set up before using this node."], "extent": [3745, 4131]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Modeling the pieces"], "extent": [4131, 4157], "body": [{"type": "para", "indent": 0, "text": ["Houdini\u2019s copying/instancing workflows are based on using the ", {"type": "code", "text": ["pscale"]}, " (point scale) attribute to control the size of each instance. Since this is a scale, it works best if you ", {"type": "strong", "text": ["model the objects to copy/instance at 1 unit scale"]}, ", at least along the axis you don\u2019t want to overlap when scattering."], "extent": [4157, 4457]}, {"type": "para", "indent": 0, "text": ["For example, if you are scattering trees, it is best to model each tree so the ", {"type": "q", "text": ["radius"]}, " of the tree (the maximum distance from the center of the truck to the end of the longest branch) is one world unit. Then the copy node can scale the tree smaller or larger using ", {"type": "code", "text": ["pscale"]}, "."], "extent": [4457, 4734]}, {"type": "para", "indent": 0, "text": ["If you have a model created at a different scale, you can make it 1 unit scale with the ", {"scheme": "Node", "value": "/nodes/sop/matchsize", "type": "link", "text": ["Match Size node"], "fullpath": "/nodes/sop/matchsize"}, "."], "extent": [4734, 4862]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Tips and notes"], "extent": [4862, 4883], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["The ", {"type": "q", "text": ["Pieces"]}, " parameters (shuffle and offset) are not available when ", {"type": "ui", "text": ["Mode"]}, " is ", {"type": "ui", "text": ["VEXpression"]}, "."], "extent": [4883, 4985]}], "container": true}]}, {"level": 1, "id": "inputs", "container": true, "type": "inputs_section", "indent": 0, "role": "section", "extent": [4985, 4993], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["Points"], "extent": [4993, 5002], "body": [{"type": "para", "indent": 4, "text": ["The points to create the name attribute on."], "extent": [5002, 5051]}], "container": true}, {"type": "dt", "indent": 0, "text": ["Geometry Library"], "extent": [5051, 5069], "body": [{"type": "para", "indent": 4, "text": ["The different pieces that can be assigned to the points."], "extent": [5069, 5132]}], "container": true}], "container": true}], "text": "Inputs"}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [5132, 5144], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Piece Attribute"], "extent": [5144, 5162], "body": [{"type": "para", "indent": 4, "text": ["The name of the point attribute the specifies which primitives in the second input are parts of the same thing."], "extent": [5184, 5301]}], "container": true, "attrs": {"id": "pieceattrib"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Piece Filter"], "extent": [5301, 5315], "body": [{"type": "para", "indent": 4, "text": ["If you only want the node to use a few of the available pieces from the second input, type a space separated list of the attribute values here. If this is blank, the node uses all available pieces in the second input."], "extent": [5337, 5560]}], "container": true, "attrs": {"id": "piecefilter"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Mode"], "extent": [5560, 5566], "body": [{"type": "para", "indent": 4, "text": ["The method this node uses to assign pieces to points."], "extent": [5581, 5640]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Cycle"], "extent": [5640, 5651], "body": [{"type": "para", "indent": 8, "text": ["Go through the points in order, cycling through the available pieces (essentially, assign the piece using ", {"type": "q", "text": ["point number modulo number of pieces"]}, ")."], "extent": [5651, 5807]}, {"type": "para", "indent": 8, "text": ["Note that if the points were created by ", {"scheme": "Node", "value": "/nodes/sop/scatter", "type": "link", "text": ["Scatter"], "fullpath": "/nodes/sop/scatter"}, " or ", {"scheme": "Node", "value": "/nodes/sop/scatteralign", "type": "link", "text": ["Scatter and Align"], "fullpath": "/nodes/sop/scatteralign"}, ", the point numbers have no relationship to their position, so the distribution of pieces will look random."], "extent": [5807, 6035]}, {"type": "para", "indent": 8, "text": [{"scheme": "Image", "value": "/images/nodes/sop/attrib_from_pieces_mode_cycle.jpg", "type": "img", "text": ""}], "extent": [6035, 6108]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Patches"], "extent": [6108, 6121], "body": [{"type": "para", "indent": 8, "text": ["Assigns the pieces in random ", {"type": "q", "text": ["splotches"]}, " (using Worley noise). That is, instead of randomizing each individual point, it randomizes irregularly shaped groups of points."], "extent": [6121, 6299]}, {"type": "para", "indent": 8, "text": [{"scheme": "Image", "value": "/images/nodes/sop/attrib_from_pieces_mode_patches.jpg", "type": "img", "text": ""}], "extent": [6299, 6374]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Noise"], "extent": [6374, 6385], "body": [{"type": "para", "indent": 8, "text": ["Assigns the pieces using noise. This is not the same as randomizing each piece. Instead it assigns a piece based on the quantization of the output of a chosen noise function. This lets you create organic-looking patterns and other effects."], "extent": [6385, 6634]}, {"type": "para", "indent": 8, "text": [{"scheme": "Image", "value": "/images/nodes/sop/attrib_from_pieces_mode_noise.jpg", "type": "img", "text": ""}], "extent": [6634, 6707]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Random"], "extent": [6707, 6719], "body": [{"type": "para", "indent": 8, "text": ["Assigns pieces to points randomly. You can assign weights to each piece to make some pieces more likely than others."], "extent": [6719, 6845]}, {"type": "para", "indent": 8, "text": [{"scheme": "Image", "value": "/images/nodes/sop/attrib_from_pieces_mode_random.jpg", "type": "img", "text": ""}], "extent": [6845, 6919]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Map Attribute"], "extent": [6919, 6938], "body": [{"type": "para", "indent": 8, "text": ["Assigns pieces to points based on the value of an attribute on the points."], "extent": [6938, 7022]}, {"type": "para", "indent": 8, "text": ["This is very powerful since you can use the wide variety of SOP nodes that create attributes to set up the point attribute. For example, you can paint on values using ", {"scheme": "Node", "value": "/nodes/sop/attribpaint", "type": "link", "text": ["Attribute Paint"], "fullpath": "/nodes/sop/attribpaint"}, ", or set the attribute based on distance from another object with ", {"scheme": "Node", "value": "/nodes/sop/distancefromgeometry", "type": "link", "text": ["Distance From Geometry"], "fullpath": "/nodes/sop/distancefromgeometry"}, ", or from a certain coordinate with ", {"scheme": "Node", "value": "/nodes/sop/distancefromtarget", "type": "link", "text": ["Distance From Target"], "fullpath": "/nodes/sop/distancefromtarget"}, "."], "extent": [7022, 7444]}, {"type": "tip_group", "body": [{"type": "tip", "indent": 8, "role": "item", "extent": [7444, 7457], "body": [{"type": "para", "indent": 12, "text": ["If multiple mappings apply to a point, the node picks one randomly."], "extent": [7457, 7538]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 8, "text": [{"scheme": "Image", "value": "/images/nodes/sop/attrib_from_pieces_mode_mapattr.jpg", "type": "img", "text": ""}], "extent": [7538, 7613]}], "container": true}, {"type": "dt", "indent": 4, "text": ["VEXpression"], "extent": [7613, 7630], "body": [{"type": "para", "indent": 8, "text": ["Evaluates a series of VEX expressions, and assigns the piece based on which VEX expression returns true."], "extent": [7630, 7744]}, {"type": "para", "indent": 8, "text": ["If you can write ", {"scheme": null, "value": "/vex/snippets", "type": "link", "text": ["VEX"], "fullpath": "/vex/snippets"}, ", this allows full control over how to select a piece based on an attribute value or a logical combination of values."], "extent": [7744, 7907]}, {"type": "tip_group", "body": [{"type": "tip", "indent": 8, "role": "item", "extent": [7907, 7920], "body": [{"type": "para", "indent": 12, "text": ["If multiple expressions return true for a point, the node picks one randomly."], "extent": [7920, 8011]}], "container": true}], "container": true, "role": "item_group"}], "container": true}], "container": true}], "container": true, "attrs": {"id": "mode"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Copy Attributes"], "extent": [8011, 8028], "body": [{"type": "para", "indent": 4, "text": ["List of attributes to copy from source pieces. Attributes that match this\n    pattern are aggregated over each piece using ", {"type": "ui", "text": ["Promotion Method"]}, " before\n    they are transferred to the output points."], "extent": [8049, 8252]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [8252, 8262], "body": [{"type": "para", "indent": 8, "text": ["Attributes are copied from the same class as ", {"type": "ui", "text": ["Piece Attribute"]}, ". That\n        is, if the ", {"type": "ui", "text": ["Piece Attribute"]}, " lives on points, then point attributes\n        will be copied; otherwise, the attributes will come from primitives."], "extent": [8262, 8497]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "copyattrib"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Allow P Attribute"], "extent": [8497, 8516], "body": [{"type": "para", "indent": 4, "text": ["The position attribute (", {"type": "code", "text": ["P"]}, ") will be matched against the ", {"type": "ui", "text": ["Copy Attributes"]}, "\n    pattern only when this parameter is enabled. Turn this on if you want to\n    transfer piece positions to the output instances."], "extent": [8532, 8745]}], "container": true, "attrs": {"id": "copyp"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Promotion Method"], "extent": [8745, 8763], "body": [{"type": "para", "indent": 4, "text": ["Specifies how the attribute values are aggregated over each piece before\n    copying to the output points."], "extent": [8784, 8896]}, {"type": "para", "indent": 8, "text": ["Whenever there is more than one attribute in the original class\n        which matches a single entity in the new class, some method must\n        be used to determine the new value. For example, if converting\n        from point attribute to primitive attribute, there will be many\n        points corresponding to a single polygon."], "extent": [2770, 3109]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 8, "text": ["Maximum"], "extent": [3109, 3126], "body": [{"type": "para", "indent": 12, "text": ["Picks the largest match."], "extent": [3126, 3163]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Minimum"], "extent": [3163, 3180], "body": [{"type": "para", "indent": 12, "text": ["Picks the smallest match."], "extent": [3180, 3218]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Average"], "extent": [3218, 3235], "body": [{"type": "para", "indent": 12, "text": ["The mean, or the sum of all matches divided by the number of\n            matches."], "extent": [3235, 3329]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Mode"], "extent": [3329, 3343], "body": [{"type": "para", "indent": 12, "text": ["The most common match. If there is more than one most\n            common, it will be the minimum of the most common."], "extent": [3343, 3472]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Median"], "extent": [3472, 3488], "body": [{"type": "para", "indent": 12, "text": ["The middle of the matches. If there is an even number of\n            elements, it is the higher of the two possible middles."], "extent": [3488, 3625]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Sum"], "extent": [3625, 3638], "body": [{"type": "para", "indent": 12, "text": ["All of the matches added together."], "extent": [3638, 3685]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Sum of Squares"], "extent": [3685, 3709], "body": [{"type": "para", "indent": 12, "text": ["All of the matches squared, and then added together."], "extent": [3709, 3774]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Root Mean Square"], "extent": [3774, 3800], "body": [{"type": "para", "indent": 12, "text": ["The square root of the average of the squares of all the\n            matches."], "extent": [3800, 3890]}], "container": true}, {"type": "dt", "indent": 8, "text": ["First Match"], "extent": [3890, 3911], "body": [{"type": "para", "indent": 12, "text": ["The first valid match. For promoting points to primitives,\n            this would be the point of the first vertex in the\n            primitive."], "extent": [3911, 4068]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Last Match"], "extent": [4068, 4088], "body": [{"type": "para", "indent": 12, "text": ["The last valid match. For promoting points to primitives,\n            this would be the point of the last vertex in the\n            primitive."], "extent": [4088, 4243]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Array of All"], "extent": [4243, 4265], "body": [{"type": "para", "indent": 12, "text": ["Provided the source attribute is a tuple attribute, a new\n            array attribute is created.  The array attribute is populated\n            with all the values of the matches."], "extent": [4265, 4457]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "copymethod"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "type": "sep", "indent": 0, "text": [" Pieces "], "extent": [8951, 8966], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Shuffle"], "extent": [8966, 8980], "body": [{"type": "para", "indent": 8, "text": ["Turn this on to randomly scramble the order of the pieces."], "extent": [9002, 9070]}], "container": true, "attrs": {"id": "shuffle"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Seed"], "extent": [9070, 9080], "body": [{"type": "para", "indent": 8, "text": ["The seed for the random number generator used to scrable the piece order. The same seed will always produce the same ordering. For example, if you want different orderings in each frame, set the seed to ", {"type": "code", "text": ["$F"]}, " (the current frame number)."], "extent": [9099, 9344]}], "container": true, "attrs": {"id": "seed"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Offset"], "extent": [9344, 9356], "body": [{"type": "para", "indent": 8, "text": ["Shifts the order of pieces forward a certain number of places, with pieces at the end moving to the front of the order."], "extent": [9377, 9507]}], "container": true, "attrs": {"id": "offset"}, "role": "item"}], "container": true, "role": "item_group"}], "container": true}, {"level": 3, "type": "sep", "indent": 0, "text": [" Source Points "], "extent": [9507, 9529], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Override Ptnum"], "extent": [9529, 9550], "body": [{"type": "para", "indent": 8, "text": ["Turn on the checkbox next to ", {"type": "ui", "text": ["ID Attribute"]}, " to use the value of a custom attribute on each point to cycle through the pieces instead of the inherent point number."], "extent": [9578, 9752]}], "container": true, "attrs": {"id": "overrideptnum"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["ID Attribute"], "extent": [9752, 9770], "body": [{"type": "para", "indent": 8, "text": ["Turn the checkbox on and specify the name of an integer attribute on the points to use the attribute\u2019s value to cycle through the pieces instead of the inherent point number."], "extent": [9796, 9980]}], "container": true, "attrs": {"id": "ptnumattrib"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Location Attribute"], "extent": [9980, 10004], "body": [{"type": "para", "indent": 8, "text": ["When ", {"type": "ui", "text": ["Mode"]}, " is ", {"type": "ui", "text": ["Patches"]}, " or ", {"type": "ui", "text": ["Noise"]}, ", the attribute to use as the point\u2019s position in the noise field. The default is the point position ", {"type": "code", "text": ["P"]}, ". However, you might want to use a different attribute, for example you could use ", {"type": "code", "text": ["rest"]}, " if the point positions are animated but you want the noise to follow the points."], "extent": [10028, 10353]}], "container": true, "attrs": {"id": "locattrib"}, "role": "item"}], "container": true, "role": "item_group"}], "container": true}, {"level": 3, "type": "sep", "indent": 0, "text": [" Patches "], "extent": [10353, 10369], "body": [{"type": "para", "indent": 4, "text": ["These parameters are visible when ", {"type": "ui", "text": ["Mode"]}, " is ", {"type": "ui", "text": ["Patches"]}, "."], "extent": [10395, 10459]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Patch Size"], "extent": [10459, 10475], "body": [{"type": "para", "indent": 8, "text": ["Controls the average size of the patches."], "extent": [10499, 10550]}], "container": true, "attrs": {"id": "patchsize"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Scale"], "extent": [10550, 10561], "body": [{"type": "para", "indent": 8, "text": ["Allows you to control the average height, width, and depth of the patches separately."], "extent": [10586, 10681]}], "container": true, "attrs": {"id": "patchscale"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Patch Offset"], "extent": [10681, 10699], "body": [{"type": "para", "indent": 8, "text": ["Moves the noise field relative to the points."], "extent": [10725, 10781]}], "container": true, "attrs": {"id": "patchoffset"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "type": "sep", "indent": 4, "text": [" Distortion "], "extent": [10781, 10804]}, {"type": "para", "indent": 4, "text": ["These parameters can optionally add distortion on top of the base noise pattern."], "extent": [10804, 10891]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Strength"], "extent": [10891, 10905], "body": [{"type": "para", "indent": 8, "text": ["The strength of distortion to add."], "extent": [10935, 10979]}], "container": true, "attrs": {"id": "distortstrength"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Size"], "extent": [10979, 10989], "body": [{"type": "para", "indent": 8, "text": ["The size of the distortion."], "extent": [11015, 11052]}], "container": true, "attrs": {"id": "distortsize"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Roughness"], "extent": [11052, 11067], "body": [{"type": "para", "indent": 8, "text": ["The roughness of the distortion."], "extent": [11093, 11135]}], "container": true, "attrs": {"id": "worleyrough"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Offset"], "extent": [11135, 11147], "body": [{"type": "para", "indent": 8, "text": ["An offset added to the center of the distortion map."], "extent": [11175, 11238]}], "container": true, "attrs": {"id": "distortoffset"}, "role": "item"}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "patches_section"}}, {"level": 3, "type": "sep", "indent": 0, "text": [" Noise "], "extent": [11238, 11252], "body": [{"type": "para", "indent": 4, "text": ["These parameters are visible when ", {"type": "ui", "text": ["Mode"]}, " is ", {"type": "ui", "text": ["Noise"]}, "."], "extent": [11276, 11338]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Noise Type"], "extent": [11338, 11354], "body": [{"type": "para", "indent": 8, "text": ["The function to use to generate the noise field. The node uses the point positions as the seed for the random number generator."], "extent": [11379, 11516]}], "container": true, "attrs": {"id": "noisebasis"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Element Size"], "extent": [11516, 11534], "body": [{"type": "para", "indent": 8, "text": ["Controls the size of the noise features."], "extent": [11565, 11615]}], "container": true, "attrs": {"id": "noiseelementsize"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Element Scale"], "extent": [11615, 11634], "body": [{"type": "para", "indent": 8, "text": ["Allows you to control the height, width, and depth of the noise features separately."], "extent": [11666, 11760]}], "container": true, "attrs": {"id": "noiseelementscale"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Offset"], "extent": [11760, 11772], "body": [{"type": "para", "indent": 8, "text": ["Moves the noise field relative to the points."], "extent": [11794, 11849]}], "container": true, "attrs": {"id": "offset2"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Max Octaves"], "extent": [11849, 11866], "body": [{"type": "para", "indent": 8, "text": ["The number of combined noise layers."], "extent": [11889, 11935]}], "container": true, "attrs": {"id": "noiseoct"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Roughness"], "extent": [11935, 11950], "body": [{"type": "para", "indent": 8, "text": ["The influence falloff for each successive noise layer."], "extent": [11975, 12040]}], "container": true, "attrs": {"id": "noiserough"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "type": "sep", "indent": 4, "text": [" Distortion "], "extent": [12040, 12063]}, {"type": "para", "indent": 4, "text": ["These parameters can optionally add distortion on top of the base noise pattern."], "extent": [12063, 12150]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Lattice Warp"], "extent": [12150, 12168], "body": [{"type": "para", "indent": 8, "text": ["Adds ", {"type": "q", "text": ["stringiness"]}, " or ", {"type": "q", "text": ["wiriness"]}, " to standard noise."], "extent": [12187, 12248]}], "container": true, "attrs": {"id": "disp"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Freq"], "extent": [12248, 12258], "body": [{"type": "para", "indent": 8, "text": ["The frequency of the ", {"type": "ui", "text": ["Lattice Warp"]}, "."], "extent": [12281, 12329]}], "container": true, "attrs": {"id": "dispfreq"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Gradient Warp"], "extent": [12329, 12348], "body": [{"type": "para", "indent": 8, "text": ["Widens the peaks or valleys of the noise output."], "extent": [12368, 12426]}], "container": true, "attrs": {"id": "gflow"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Remap Noise"], "extent": [12426, 12443], "body": [{"type": "para", "indent": 8, "text": ["A ramp used to remap noise values."], "extent": [12468, 12513]}], "container": true, "attrs": {"id": "noiseremap"}, "role": "item"}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "noise_section"}}, {"level": 3, "type": "sep", "indent": 0, "text": [" Random "], "extent": [12513, 12528], "body": [{"type": "para", "indent": 4, "text": ["These parameters are visible when ", {"type": "ui", "text": ["Mode"]}, " is ", {"type": "ui", "text": ["Random"]}, "."], "extent": [12553, 12616]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Weight Method"], "extent": [12616, 12635], "body": [{"type": "para", "indent": 8, "text": ["The way of specifying the weight that each piece is given."], "extent": [12662, 12730]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 8, "text": ["Uniform Distribution"], "extent": [12730, 12760], "body": [{"type": "para", "indent": 12, "text": ["Each piece is equally likely."], "extent": [12760, 12811]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Piece Weights"], "extent": [12811, 12834], "body": [{"type": "para", "indent": 12, "text": ["Give each piece a weighting using a multiparm, allowing you to make some pieces more likely than others."], "extent": [12834, 12952]}, {"type": "para", "indent": 12, "text": ["If you choose this option, click the ", {"type": "ui", "text": ["Autofill Pieces"]}, " button to automatically set up the multiparm based on the pieces in the second input."], "extent": [12952, 13116]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Weight Attribute"], "extent": [13116, 13142], "body": [{"type": "para", "indent": 12, "text": ["Use a primitive float attribute on the piece geometry that sets the piece\u2019s random weighting. The weighting for a piece is the ", {"type": "em", "text": ["average"]}, " of this attribute\u2019s values across the primitives of the piece."], "extent": [13142, 13355]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "weightmethod"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Seed"], "extent": [13355, 13365], "body": [{"type": "para", "indent": 8, "text": ["When ", {"type": "ui", "text": ["Weight Method"]}, " is not ", {"type": "ui", "text": ["Uniform"]}, ", this is the seed value for the random number generator that chooses between weighted alternatives."], "extent": [13384, 13535]}], "container": true, "attrs": {"id": "seed"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Autofill Pieces"], "extent": [13535, 13556], "body": [{"type": "para", "indent": 8, "text": ["When ", {"type": "ui", "text": ["Weight Method"]}, " is ", {"type": "ui", "text": ["Piece Weights"]}, ", click this button to automatically set up the multiparm based on the pieces in the second input."], "extent": [13586, 13738]}, {"type": "para", "indent": 8, "text": ["A button that will automatically fill out the ", {"type": "ui", "text": ["Number of Assets"]}, " and ", {"type": "ui", "text": ["Piece"]}, " parameters\n        such that each unique piece in the geometry is included in the list."], "extent": [13738, 13916]}], "container": true, "attrs": {"id": "autofillnamernd"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Number of Pieces"], "extent": [13916, 13938], "body": [{"type": "para", "indent": 8, "text": ["The number of pieces to specify weights for in the multiparm."], "extent": [13959, 14030]}], "container": true, "attrs": {"id": "numval"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Piece"], "extent": [14030, 14041], "body": [{"type": "para", "indent": 8, "text": ["The attribute value for this piece."], "extent": [14060, 14105]}], "container": true, "attrs": {"id": "name"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Weight"], "extent": [14105, 14117], "body": [{"type": "para", "indent": 8, "text": ["A value representing how likely this piece is to appear in the chain, relative to other pieces. The weights of all pieces are normalized to add up to ", {"type": "code", "text": ["1.0"]}, " and then used as probabilities. For example, if three pieces have weights of ", {"type": "code", "text": ["1"]}, ", ", {"type": "code", "text": ["1"]}, ", and ", {"type": "code", "text": ["2"]}, ", the last piece is likely to appear 50% of the time, while the other two are each likely to appear 25% of the time."], "extent": [14139, 14515]}], "container": true, "attrs": {"id": "weight_"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Weight Attribute"], "extent": [14515, 14537], "body": [{"type": "para", "indent": 8, "text": ["When ", {"type": "ui", "text": ["Mode"]}, " is ", {"type": "ui", "text": ["Weight Attribute"]}, ", the name of a primitive float attribute on the piece geometry that sets the piece\u2019s random weighting. The weighting for a piece is the ", {"type": "em", "text": ["average"]}, " of this attribute\u2019s values across the primitives of the piece."], "extent": [14564, 14821]}], "container": true, "attrs": {"id": "weightattrib"}, "role": "item"}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "random_section"}}, {"level": 3, "type": "sep", "indent": 0, "text": [" Map Attribute "], "extent": [14821, 14843], "body": [{"type": "para", "indent": 4, "text": ["These parameters are visible when ", {"type": "ui", "text": ["Mode"]}, " is ", {"type": "ui", "text": ["Map Attribute"]}, "."], "extent": [14843, 14914]}, {"type": "tip_group", "body": [{"type": "tip", "indent": 4, "role": "item", "extent": [14914, 14923], "body": [{"type": "para", "indent": 8, "text": ["If multiple mappings apply to a point, the node picks one randomly."], "extent": [14923, 15000]}], "container": true}], "container": true, "role": "item_group"}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Attribute"], "extent": [15000, 15015], "body": [{"type": "para", "indent": 8, "text": ["The name of an attribute on the points to use to choose the piece for each point."], "extent": [15036, 15127]}], "container": true, "attrs": {"id": "attrib"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Attribute Type"], "extent": [15127, 15147], "body": [{"type": "para", "indent": 8, "text": ["The type of attribute."], "extent": [15172, 15204]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 8, "text": ["Numeric"], "extent": [15204, 15221], "body": [{"type": "para", "indent": 12, "text": ["The attribute is either a float or an integer. This lets you matching pieces to ranges of numbers."], "extent": [15221, 15341]}], "container": true}, {"type": "dt", "indent": 8, "text": ["String"], "extent": [15341, 15357], "body": [{"type": "para", "indent": 12, "text": ["The attribute is a string. This lets you match against exact values or string patterns."], "extent": [15357, 15458]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "attribtype"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Map Pieces From"], "extent": [15458, 15479], "body": [{"type": "para", "indent": 8, "text": ["When ", {"type": "ui", "text": ["Attribute Type"]}, " is ", {"type": "ui", "text": ["Numeric"]}, ", choose whether to map values to pieces automatically or manually."], "extent": [15507, 15622]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 8, "text": ["Automatic Ranges"], "extent": [15622, 15648], "body": [{"type": "para", "indent": 12, "text": ["Automatically creates a mapping between equal-sized ranges of values in the attribute and the available pieces in the second input."], "extent": [15648, 15793]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Explicit Ranges"], "extent": [15793, 15818], "body": [{"type": "para", "indent": 12, "text": ["Lets you manually map between ranges and pieces using a multiparm."], "extent": [15818, 15898]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "mappiecesfrom"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Autofill Pieces"], "extent": [15898, 15919], "body": [{"type": "para", "indent": 8, "text": ["When ", {"type": "ui", "text": ["Attribute Type"]}, " is ", {"type": "ui", "text": ["String"]}, " or ", {"type": "ui", "text": ["Map Pieces From"]}, " is ", {"type": "ui", "text": ["Explicit Ranges"]}, ", click this button to automatically set up the multiparm with an initial set of mappings based on the pieces in the second input."], "extent": [15987, 16210]}], "container": true, "attrs": {"id": "autofillnamenumeric", "also": "autofillnamestring"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Number of Maps/ranges"], "extent": [16210, 16237], "body": [{"type": "para", "indent": 8, "text": ["When ", {"type": "ui", "text": ["Attribute Type"]}, " is ", {"type": "ui", "text": ["String"]}, " or ", {"type": "ui", "text": ["Map Pieces From"]}, " is ", {"type": "ui", "text": ["Explicit Ranges"]}, ", this is the number of mappings in the multiparm."], "extent": [16284, 16427]}], "container": true, "attrs": {"id": "numranges", "also": "nummaps"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Enable Piece"], "extent": [16427, 16445], "body": [{"type": "para", "indent": 8, "text": ["Use the checkbox next to each range to control whether it is used or not."], "extent": [16506, 16589]}], "container": true, "attrs": {"id": "enablerangepiece", "also": "enablemappiece"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Piece"], "extent": [16589, 16600], "body": [{"type": "para", "indent": 8, "text": ["The name of the piece to assign to points where the value matches this pattern. If you enter a space-separated list of piece names, the node will choose one randomly."], "extent": [16649, 16825]}], "container": true, "attrs": {"id": "rangepiece", "also": "mappiece"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Map From"], "extent": [16825, 16839], "body": [{"type": "para", "indent": 8, "text": ["The string value or pattern to match against."], "extent": [16861, 16916]}], "container": true, "attrs": {"id": "mapfrom"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Min"], "extent": [16916, 16925], "body": [{"type": "para", "indent": 8, "text": ["The minimum value for this range."], "extent": [16943, 16986]}], "container": true, "attrs": {"id": "min"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Max"], "extent": [16986, 16995], "body": [{"type": "para", "indent": 8, "text": ["The maximum value for this range."], "extent": [17013, 17057]}], "container": true, "attrs": {"id": "max"}, "role": "item"}], "container": true, "role": "item_group"}], "container": true}, {"level": 3, "type": "sep", "indent": 0, "text": [" VEXpression "], "extent": [17057, 17077], "body": [{"type": "para", "indent": 4, "text": ["These parameters are visible when ", {"type": "ui", "text": ["Mode"]}, " is ", {"type": "ui", "text": ["VEXpression"]}, "."], "extent": [17107, 17175]}, {"type": "tip_group", "body": [{"type": "tip", "indent": 4, "role": "item", "extent": [17175, 17184], "body": [{"type": "para", "indent": 8, "text": ["If multiple expressions return true for a point, the node picks one randomly."], "extent": [17184, 17271]}], "container": true}], "container": true, "role": "item_group"}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Autofill Pieces"], "extent": [17271, 17292], "body": [{"type": "para", "indent": 8, "text": ["Click this button to set up the multiparm with expressions for each piece in the second input."], "extent": [17322, 17426]}], "container": true, "attrs": {"id": "autofillnamevex"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Number of VEXpressions"], "extent": [17426, 17454], "body": [{"type": "para", "indent": 8, "text": ["The number of VEX expressions to test."], "extent": [17475, 17523]}], "container": true, "attrs": {"id": "numvex"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Enable piece"], "extent": [17523, 17541], "body": [{"type": "para", "indent": 8, "text": ["Use the checkbox next to each expression to control whether it is used or not."], "extent": [17570, 17658]}], "container": true, "attrs": {"id": "enablevexpiece"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Piece"], "extent": [17658, 17669], "body": [{"type": "para", "indent": 8, "text": ["The name of the piece to assign to points where the expression returns true. If you enter a space-separated list of piece names, the node will choose one randomly."], "extent": [17692, 17865]}], "container": true, "attrs": {"id": "vexpiece"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["VEXpression"], "extent": [17865, 17882], "body": [{"type": "para", "indent": 8, "text": ["The VEX expression to run for each point. If the expression evaluates to a non-zero value, it ", {"type": "q", "text": ["matches"]}, " the point and the corresponding piece will be assigned to the point."], "extent": [17904, 18087]}], "container": true, "attrs": {"id": "vexcode"}, "role": "item"}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "vexpression_section"}}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Unmatched Piece"], "extent": [18087, 18104], "body": [{"type": "para", "indent": 4, "text": ["When none of the rules in the multiparm match, use this piece. If you enter a space-separated list of piece names, the node will choose one randomly."], "extent": [18164, 18319]}], "container": true, "attrs": {"id": "attribunmatchedpiece", "also": "vexunmatchedpiece"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Use Unmatched Group"], "extent": [18319, 18340], "body": [{"type": "para", "indent": 4, "text": ["Turn on the checkbox next to ", {"type": "ui", "text": ["Unmatched group"]}, " to create a group in the output containing any unmatched points."], "extent": [18406, 18525]}], "container": true, "attrs": {"id": "useattribunmatchedgroup", "also": "usevexunmatchedgroup"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Unmatched Group"], "extent": [18525, 18542], "body": [{"type": "para", "indent": 4, "text": ["Turn on the checkbox and enter a group name to create a group in the output containing any unmatched points."], "extent": [18602, 18716]}], "container": true, "attrs": {"id": "attribunmatchedgroup", "also": "vexunmatchedgroup"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Seed"], "extent": [18716, 18722], "body": [{"type": "para", "indent": 4, "text": ["The seed value for the random number generator for when the node chooses between alternatives."], "extent": [18765, 18866]}], "container": true, "attrs": {"id": "seedmapattrib", "also": "seedvex"}, "role": "item"}], "container": true, "role": "item_group"}], "text": "Parameters"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [18866, 18875], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/scatter", "type": "link", "text": "", "fullpath": "/nodes/sop/scatter"}], "extent": [18875, 18897]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/instancepoints", "type": "link", "text": "", "fullpath": "/nodes/sop/instancepoints"}], "extent": [18897, 18925]}], "container": true}], "text": "Related"}], "title": ["Attribute From Pieces"], "summary": ["Assigns an attribute to points specifying which of a set of models should be copied/instanced to that point, randomly or based on various rules."], "included": ["/nodes/sop/attribpromote"]}