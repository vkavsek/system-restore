{"type": "root", "attrs": {"type": "node", "context": "sop", "internal": "attribwrangle", "icon": "SOP/attribwrangle", "tags": "attrs, vex, tech", "since": "12.5", "version": null, "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Attribute Wrangle"], "extent": [0, 22]}, {"type": "summary", "indent": 0, "text": ["Runs a VEX snippet to modify attribute values."], "extent": [137, 191]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Overview"], "extent": [191, 206], "body": [{"type": "para", "indent": 0, "text": ["This is a very powerful, low-level node that lets experts who are\nfamiliar with VEX tweak attributes using code."], "extent": [206, 321]}, {"type": "para", "indent": 0, "text": ["This node corresponds to the ", {"scheme": "Node", "value": "/nodes/sop/attribvop", "type": "link", "text": ["Attribute VOP SOP"], "fullpath": "/nodes/sop/attribvop"}, ",\nbut uses a textual VEX snippet instead of a VOP network."], "extent": [321, 448]}, {"type": "warning_group", "body": [{"type": "warning", "indent": 0, "role": "item", "extent": [448, 457], "body": [{"type": "para", "indent": 4, "text": ["This node requires that you understand the ", {"scheme": null, "value": "/vex/", "type": "link", "text": ["vex language"], "fullpath": "/vex/index"}, ".\n    It is very easy to write incorrect code using this node."], "extent": [457, 588]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 0, "text": ["This node ", {"type": "em", "text": ["runs the snippet on the detail or every point/primitive/vertex"]}, "\n(depending on the ", {"type": "ui", "text": ["Class"]}, " parameter) in the input geometry.\nThe snippet can edit the input geometry by changing attributes.\nIt can access information from other geometry using attributes and VEX functions."], "extent": [588, 872]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["Press ", {"keys": ["MMB"], "type": "keys", "text": null}, " on the node to see any error output from the snippet."], "extent": [872, 943]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You can use the VEX function ", {"type": "code", "text": ["ch"]}, " to evaluate parameters.\n  The path is relative to this node (", {"type": "code", "text": ["ch(\"parm\")"]}, " will evaluate the parameter ", {"type": "code", "text": ["parm"]}, " on this node). This evaluation will be done at the current time."], "extent": [943, 1154]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Unlike the ", {"scheme": "Node", "value": "/nodes/sop/attribcreate", "type": "link", "text": ["Attrib Create SOP"], "fullpath": "/nodes/sop/attribcreate"}, ", this does not use local variables.\n  Further, all backtick expressions and ", {"type": "code", "text": ["$F"]}, " variables will be evaluated at frame 1,\n  not the current time.\n  Use ", {"type": "code", "text": ["@Frame"]}, ", ", {"type": "code", "text": ["@Time"]}, ", or ", {"type": "code", "text": ["@TimeInc"]}, " instead."], "extent": [1154, 1404]}], "container": true}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Syntax"], "extent": [1404, 1417], "body": [{"type": "para", "indent": 0, "text": ["The ", {"type": "ui", "text": ["VEX snippet"]}, " parameter lets you enter a snippet of ", {"scheme": null, "value": "/vex/", "type": "link", "text": ["VEX code"], "fullpath": "/vex/index"}, " to run on the input geometry.\nSee ", {"scheme": null, "value": "/vex/snippets", "type": "link", "text": ["VEX snippets"], "fullpath": "/vex/snippets"}, " for basic information on the syntax available in the snippet parameter.\nSee ", {"scheme": null, "value": "/vex/", "type": "link", "text": ["the VEX chapter"], "fullpath": "/vex/index"}, " for general information on the VEX language."], "extent": [16, 299]}]}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [1445, 1457], "body": [{"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Code"], "extent": [1457, 1469], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Group"], "extent": [1469, 1477], "body": [{"type": "para", "indent": 4, "text": ["A subset of points in the input geometry to run the program on.\n    Leave this blank to affect all points in the input."], "extent": [1477, 1602]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Group Type"], "extent": [1602, 1614], "body": [{"type": "para", "indent": 4, "text": ["What the group is made of."], "extent": [1614, 1646]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Run Over"], "extent": [16, 26], "body": [{"type": "para", "indent": 4, "text": ["Apply the VEX code to each component of this type (points, primitives/faces, or vertices. Or choose ", {"type": "ui", "text": ["Detail"]}, " to run the code only once. For each component, the code runs with attributes bound to variables starting with ", {"type": "code", "text": ["@"]}, " (for example ", {"type": "code", "text": ["@Cd"]}, ") for reading and writing."], "extent": [42, 317]}, {"type": "para", "indent": 4, "text": ["If you choose ", {"type": "code", "text": ["Numbers"]}, ", Houdini runs the code for certain number of iterations instead of over components. In this mode the code only has read-only detail-level attributes bound to ", {"type": "code", "text": ["@"]}, " variables."], "extent": [317, 519]}], "container": true, "attrs": {"id": "class"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Number Count"], "extent": [519, 533], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Run Over"]}, " is ", {"type": "ui", "text": ["Numbers"]}, ", the number of iterations to run the code. In each iteration, ", {"type": "code", "text": ["@numelem"]}, " is bound to this total count, and ", {"type": "code", "text": ["@elemnum"]}, " is bound to the iteration number, from ", {"type": "code", "text": ["0"]}, " to ", {"type": "code", "text": ["@numelem - 1"]}, ". "], "extent": [556, 775]}, {"type": "para", "indent": 4, "text": ["In this mode the code only has read-only detail-level attributes bound to ", {"type": "code", "text": ["@"]}, " variables."], "extent": [775, 869]}], "container": true, "attrs": {"id": "vex_numcount"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Thread Job Size"], "extent": [869, 886], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Run Over"]}, " is ", {"type": "ui", "text": ["Numbers"]}, ", this is the number of iterations to run per separate thread. If this number is greater than or equal the ", {"type": "ui", "text": ["Number count"]}, ", all iterations will run serially in a single thread. If this is ", {"type": "code", "text": ["1"]}, ", each iteration will run in a separate thread. In between, the node will group the iterations into batches of this size, and run each batch in parallel on separate threads."], "extent": [914, 1316]}], "container": true, "attrs": {"id": "vex_threadjobsize"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["VEXpression"], "extent": [2337, 2350], "body": [{"type": "para", "indent": 4, "text": ["A snippet of VEX code that will manipulate the point attributes.\n    You can use ", {"type": "code", "text": ["@", {"type": "var", "text": ["variable_name"]}]}, " syntax to access geometry attributes."], "extent": [2368, 2513]}], "container": true, "attrs": {"id": "snippet"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Attributes to Create"], "extent": [1699, 1721], "body": [{"type": "para", "indent": 4, "text": ["Only create attributes if their names match this pattern.\n    The default pattern allows any attribute to be created."], "extent": [1721, 1848]}, {"type": "para", "indent": 4, "text": ["You can restrict the created attributes by replacing the ", {"type": "code", "text": ["*"]}, " with a list of allowed names."], "extent": [1848, 1944]}, {"type": "para", "indent": 4, "text": ["Bound attributes, such as ", {"type": "code", "text": ["vtxnum"]}, ", cannot be created and will be ignored."], "extent": [1944, 2024]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Enforce Prototypes"], "extent": [16, 36], "body": [{"type": "para", "indent": 4, "text": ["Requires that you declare ", {"type": "code", "text": ["@"]}, " bindings in snippets as prototypes before using them. This applies to both attributes (for example ", {"type": "code", "text": ["@Cd"]}, ") and ", {"type": "q", "text": ["convenience"]}, " bindings such as ", {"type": "code", "text": ["@ptnum"]}, " and ", {"type": "code", "text": ["@Frame"]}, ". For example:"], "extent": [36, 248]}, {"lang": "vex", "type": "pre", "indent": 4, "text": ["\n    // Declare bindings\n    int @ptnum;\n    float @Frame;\n    vector @Cd;\n\n    // Use bindings after declaration\n    int pointnum = @ptnum;\n    float red = @Cd[0] / @Frame;\n    "], "extent": [248, 447]}, {"type": "para", "indent": 4, "text": ["Automatic binding with the ", {"type": "code", "text": ["@"]}, " syntax can be convenient, but as your scene becomes more complex there is the risk that a typo in an ", {"type": "code", "text": ["@"]}, " binding will silently just bind a non-existent attribute."], "extent": [447, 646]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Bindings"], "extent": [2061, 2076], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Autobind by Name"], "extent": [2076, 2095], "body": [{"type": "para", "indent": 4, "text": ["Automatically bind attributes to parameters by name.\n    If for some reason you need CVEX parameters to have different names\n    than the corresponding attributes,\n    turn this off and use the ", {"type": "ui", "text": ["Number of bindings"]}, " parameter to set up\n    mappings between ", {"type": "ui", "text": ["Attribute name"]}, " and ", {"type": "ui", "text": ["VEX parameter"]}, "."], "extent": [2095, 2400]}, {"type": "para", "indent": 4, "text": ["Integer attributes will bind to integer parameters.\n    Float attributes will bind to float, vector, point, matrix, or matrix4 depending on their tuple size.\n    String attributes will bind to strings."], "extent": [2400, 2607]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Autobind Groups by Name"], "extent": [2607, 2632], "body": [{"type": "para", "indent": 4, "text": ["Automatically bind any groups to the integer parameter prefixed with ", {"type": "code", "text": ["group_"]}, ". If for some reason you need CVEX parameters to have different names than the corresponding groups, turn this off and use the ", {"type": "ui", "text": ["Group Bindings"]}, " parameter to set up mappings between ", {"type": "ui", "text": ["Group Name"]}, " and ", {"type": "ui", "text": ["VEX Parameter"]}, "."], "extent": [2632, 2939]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Group Bindings"], "extent": [2939, 2955], "body": [{"type": "para", "indent": 8, "text": ["Manually specifies the bindings of each group. "], "extent": [2955, 3012]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Evaluation Node Path"], "extent": [3012, 3034], "body": [{"type": "para", "indent": 4, "text": ["VEX functions like ", {"type": "code", "text": ["ch()"]}, " usually evaluate with respect to this node.\n    Enter a node path here to override where the path search starts from.\n    This is useful for embedding in a digital asset, where you want searches\n    to start from the asset root."], "extent": [3034, 3294]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Export Parameters"], "extent": [3294, 3313], "body": [{"type": "para", "indent": 4, "text": ["When a VEX parameter is exported, the bound attribute will be\n    created if it doesn\u2019t exist.  This pattern can be used to override\n    the export option on the VEX shader to avoid writing to or creating\n    certain attributes.  The pattern matches the VEX parameter, not\n    the bound attribute. The attribute will still be bound for reading."], "extent": [3313, 3663]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Update Normals If Displaced"], "extent": [3663, 3692], "body": [{"type": "para", "indent": 4, "text": ["If points are being run over, and the ", {"type": "code", "text": ["P"]}, " attribute is written to,\n    but the ", {"type": "code", "text": ["N"]}, " attribute is not written to, any incoming normals will\n    become out of date.  When this option is set, vertex and point\n    normals will be updated when this occurs."], "extent": [3692, 3948]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Attribute To Match"], "extent": [3948, 3968], "body": [{"type": "para", "indent": 4, "text": ["Which attribute to use for matching.  This attribute must be\n    present on both inputs for matching to be done.  Otherwise matching\n    is done by element number (ie, point number when running over points).\n    The attribute should either be an integer or string attribute.\n    This controls how the ", {"type": "code", "text": ["opinput#_"]}, " virtual bindings connect.\n    You can use ", {"type": "code", "text": ["v@opinput1_Cd"]}, ", for example, to read the second input\u2019s\n    ", {"type": "code", "text": ["v@Cd"]}, " attribute."], "extent": [3968, 4407]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Compute Results In Place"], "extent": [4407, 4433], "body": [{"type": "para", "indent": 4, "text": ["When compiled the Attribute VOP is able to work on the incoming\n    geometry in place without making a copy of it.  This can speed\n    up processing as one less copy is made, but requires that the\n    VEX code doesn\u2019t bind for writing any attributes that are\n    read from the first input."], "extent": [4433, 4728]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Output Selection Group"], "extent": [4728, 4752], "body": [{"type": "para", "indent": 4, "text": ["The name of a group to use as the output selection.  When the highlight flag is enabled for this node, this group will be the output selection used by later modeling tools (if it exists)."], "extent": [4752, 4945]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["VEX Precision"], "extent": [2846, 2862], "body": [{"type": "para", "indent": 4, "text": ["VEX can evaluate at 32-bit or 64-bit precision.  64-bit provides\n    higher accuracy, especially for transforms."], "extent": [2886, 3008]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [3008, 3018], "body": [{"type": "para", "indent": 8, "text": ["Incoming attributes will preserve their original precision, so using 64-bit VEX on 32-bit positions will convert them to 64-bit, apply the operation, then convert back to 32-bit when writing out."], "extent": [3018, 3227]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 4, "text": ["The auto mode will switch between 32-bit and 64-bit depending on the preferred precision of the incoming geometry. When run in 64-bit precision, any created attributes will be 64-bit. When run in 32-bit any created attributes will be 32-bit. Use ", {"scheme": "Node", "value": "/nodes/sop/attribcast", "type": "link", "text": "", "fullpath": "/nodes/sop/attribcast"}, " to change the preferred precision."], "extent": [3227, 3535]}], "container": true, "attrs": {"id": "vex_precision"}, "role": "item"}], "container": true, "role": "item_group"}]}], "text": "Parameters"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [4991, 5000], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/attribexpression", "type": "link", "text": "", "fullpath": "/nodes/sop/attribexpression"}], "extent": [5000, 5031]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/attribvop", "type": "link", "text": "", "fullpath": "/nodes/sop/attribvop"}], "extent": [5031, 5054]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/vexdeform", "type": "link", "text": "", "fullpath": "/nodes/sop/vexdeform"}], "extent": [5054, 5077]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/volumewrangle", "type": "link", "text": "", "fullpath": "/nodes/sop/volumewrangle"}], "extent": [5077, 5104]}], "container": true}], "text": "Related"}], "title": ["Attribute Wrangle"], "summary": ["Runs a VEX snippet to modify attribute values."], "included": ["/nodes/sop/_run_over", "/nodes/sop/attribvop", "/nodes/sop/pointwrangle", "/nodes/sop/wrangle_syntax", "/vex/_enforce_prototypes"]}