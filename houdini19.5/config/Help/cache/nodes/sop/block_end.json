{"type": "root", "attrs": {"type": "node", "context": "sop", "internal": "block_end", "icon": "SOP/block_end", "tags": "tech, loop", "since": "14.5", "version": null, "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Block End"], "extent": [0, 14]}, {"type": "summary", "indent": 0, "text": ["The end/output of a looping block."], "extent": [115, 157]}, {"type": "para", "indent": 0, "text": ["This node defines the end of a looping node block."], "extent": [157, 209]}, {"type": "para", "indent": 0, "text": ["See ", {"scheme": null, "value": "/model/looping", "type": "link", "text": ["looping in geometry networks"], "fullpath": "/model/looping"}, " for general information on how to use this node with the ", {"scheme": "Icon", "value": "/icons/SOP/block_begin.svg", "type": "link", "text": "", "fullpath": "/icons/SOP/block_begin.svg"}, " ", {"scheme": "Node", "value": "/nodes/sop/block_begin", "type": "link", "text": ["Block Begin SOP"], "fullpath": "/nodes/sop/block_begin"}, " node."], "extent": [209, 396]}, {"level": 2, "id": "modes", "container": true, "type": "h", "indent": 0, "text": ["Repetition mode vs. piecewise mode"], "extent": [396, 445], "body": [{"type": "para", "indent": 0, "text": ["This node will present different parameters in the Parameter Editor based on whether or not it is working on ", {"type": "em", "text": ["pieces"]}, ". A piece is usually a series of primitives that have the same ", {"type": "code", "text": ["piece"]}, " or ", {"type": "code", "text": ["name"]}, " partition attribute. The piece attribute name is set by the ", {"type": "ui", "text": ["Piece Attribute"]}, " parameter on this node."], "extent": [445, 749]}, {"type": "para", "indent": 0, "text": ["The ", {"type": "ui", "text": ["Block End SOP"]}, " is in ", {"type": "em", "text": ["piecewise"]}, " mode when:"], "extent": [749, 800]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["The ", {"type": "ui", "text": ["Interation Method"]}, " parameter on this node is set to ", {"type": "ui", "text": ["Auto Detect from Inputs"]}, ", and either the ", {"scheme": "Icon", "value": "/icons/SOP/block_begin.svg", "type": "link", "text": "", "fullpath": "/icons/SOP/block_begin.svg"}, " ", {"scheme": "Node", "value": "/nodes/sop/block_begin", "type": "link", "text": ["Block Begin SOP"], "fullpath": "/nodes/sop/block_begin"}, " node that is referenced in by the ", {"type": "ui", "text": ["Piece Block Path"]}, " parameter is set to ", {"type": "ui", "text": ["Method \u25b8 Extract Piece or Point"]}, ", or the second input of the node is connected."], "extent": [800, 1136]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["The ", {"type": "ui", "text": ["Interation Method"]}, " parameter on the node is set to ", {"type": "ui", "text": ["By Pieces or Points"]}, "."], "extent": [1136, 1222]}], "container": true}, {"type": "para", "indent": 0, "text": ["When this node is in ", {"type": "em", "text": ["piecewise"]}, " mode, it will show parameters related to ", {"type": "em", "text": ["pieces"]}, ", and you do ", {"type": "em", "text": ["not"]}, " need to set the number of iterations because it will automatically iterate over each piece."], "extent": [1222, 1416]}, {"type": "para", "indent": 0, "text": ["The ", {"type": "ui", "text": ["Block End SOP"]}, " is in ", {"type": "em", "text": ["repetition"]}, " mode when:"], "extent": [1416, 1468]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["None of the ", {"type": "em", "text": ["piecewise"]}, " mode conditions are met."], "extent": [1468, 1519]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["The ", {"type": "ui", "text": ["Interation Method"]}, " parameter on the node is set to ", {"type": "ui", "text": ["By Count"]}, "."], "extent": [1519, 1594]}], "container": true}, {"type": "para", "indent": 0, "text": ["When this node is in ", {"type": "em", "text": ["repetition"]}, " mode, it will show parameters allowing you to set the number of iterations."], "extent": [1594, 1705]}]}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [1705, 1717], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Iteration Method"], "extent": [1717, 1736], "body": [{"type": "para", "indent": 4, "text": ["Determines how the input geometry is iterated on."], "extent": [1756, 1811]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Auto Detect from Inputs"], "extent": [1811, 1840], "body": [{"type": "para", "indent": 7, "text": ["If a second input is present on the node, the ", {"type": "ui", "text": ["Interation Method \u25b8 By Pieces or Points"]}, " method is used across the input geometry. Similarly, if the ", {"scheme": "Node", "value": "/nodes/sop/block_end#templatepath", "type": "link", "text": ["Piece Block Path"], "fullpath": "/nodes/sop/block_end#templatepath", "fragment": "#templatepath"}, " is defined, then the ", {"type": "ui", "text": ["By Pieces or Points"]}, " method is used across the node\u2019s input. If neither of these are the case, then the ", {"type": "ui", "text": ["By Count"]}, " method is used."], "extent": [1840, 2206]}], "container": true}, {"type": "dt", "indent": 4, "text": ["By Pieces"], "extent": [2206, 2221], "body": [{"type": "para", "indent": 7, "text": ["One iteration is performed for each piece in the input geometry. If no input geometry is wired into the node, then an error will be issued."], "extent": [2221, 2369]}], "container": true}, {"type": "dt", "indent": 4, "text": ["By Count"], "extent": [2369, 2383], "body": [{"type": "para", "indent": 7, "text": ["A fixed number of iterations are performed according to the ", {"scheme": "Node", "value": "/nodes/sop/block_end#iterations", "type": "link", "text": ["Iterations"], "fullpath": "/nodes/sop/block_end#iterations", "fragment": "#iterations"}, " parameter."], "extent": [2383, 2505]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "itermethod"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Gather Method"], "extent": [2505, 2520], "body": [{"type": "para", "indent": 4, "text": ["Determines what is done with the results of a loop iteration."], "extent": [2536, 2603]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Feedback Each Iteration"], "extent": [2603, 2632], "body": [{"type": "para", "indent": 8, "text": ["Outputs the geometry from the last iteration of the loop. You can use this with the ", {"type": "ui", "text": ["Method \u25b8 Fetch Feedback"]}, " setting on the ", {"scheme": "Icon", "value": "/icons/SOP/block_begin.svg", "type": "link", "text": "", "fullpath": "/icons/SOP/block_begin.svg"}, " ", {"scheme": "Node", "value": "/nodes/sop/block_begin", "type": "link", "text": ["Block Begin SOP"], "fullpath": "/nodes/sop/block_begin"}, " node to have the loop accumulate geometry at each step and then output the end result."], "extent": [2632, 2932]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Merge Each Iteration"], "extent": [2932, 2958], "body": [{"type": "para", "indent": 8, "text": ["Records the geometry from each iteration and then merges them together at the end. You can use this with the ", {"type": "ui", "text": ["method \u25b8 Extract Piece or Point"]}, " setting on the ", {"scheme": "Icon", "value": "/icons/SOP/block_begin.svg", "type": "link", "text": "", "fullpath": "/icons/SOP/block_begin.svg"}, " ", {"scheme": "Node", "value": "/nodes/sop/block_begin", "type": "link", "text": ["Block Begin SOP"], "fullpath": "/nodes/sop/block_begin"}, " node to have the loop modify only one piece at a time and then merge all the pieces together at the end."], "extent": [2958, 3305]}, {"type": "note_group", "body": [{"type": "note", "indent": 8, "role": "item", "extent": [3305, 3319], "body": [{"type": "para", "indent": 12, "text": ["If you use ", {"scheme": "Node", "value": "/nodes/sop/block_begin#method", "type": "link", "text": ["Extract Piece or Point"], "fullpath": "/nodes/sop/block_begin#method", "fragment": "#method"}, " for each iteration and gather the results using this method, then the point and primitive numbers will be renumbered to be contiguous within their piece."], "extent": [3319, 3550]}], "container": true}], "container": true, "role": "item_group"}], "container": true}], "container": true}], "container": true, "attrs": {"id": "method"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Iterations"], "extent": [3550, 3562], "body": [{"type": "para", "indent": 4, "text": ["Sets the number of times to cook the loop. This parameter is only available when ", {"type": "ui", "text": ["Iteration Method"]}, " is set to ", {"type": "ui", "text": ["By Count"]}, "."], "extent": [3582, 3713]}], "container": true, "attrs": {"id": "iterations"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Start Value"], "extent": [3713, 3726], "body": [{"type": "para", "indent": 4, "text": ["Specifies the value of the ", {"type": "code", "text": ["value"]}, " metadata attribute on the first iteration. See ", {"scheme": null, "value": "/model/looping#metadata", "type": "link", "text": ["the looping documentation"], "fullpath": "/model/looping#metadata", "fragment": "#metadata"}, " for how to use this parameter. This parameter is only available when ", {"type": "ui", "text": ["Iteration Method"]}, " is set to ", {"type": "ui", "text": ["By Count"]}, "."], "extent": [3746, 3999]}], "container": true, "attrs": {"id": "startvalue"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Increment"], "extent": [3999, 4010], "body": [{"type": "para", "indent": 4, "text": ["Specifies the amount to add to the ", {"type": "code", "text": ["value"]}, " metadata attribute after each iteration. See ", {"scheme": null, "value": "/model/looping#metadata", "type": "link", "text": ["the looping documentation"], "fullpath": "/model/looping#metadata", "fragment": "#metadata"}, " for how to use this parameter. This parameter is only available when ", {"type": "ui", "text": ["Iteration Method"]}, " is set to ", {"type": "ui", "text": ["By Count"]}, "."], "extent": [4029, 4288]}], "container": true, "attrs": {"id": "increment"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Piece Elements"], "extent": [4288, 4304], "body": [{"type": "para", "indent": 4, "text": ["Determines whether to loop over primitives or points. This parameter controls whether the piece attribute is a ", {"type": "em", "text": ["point"]}, " or ", {"type": "em", "text": ["primitive"]}, " attribute. This parameter is only available when in ", {"scheme": "Node", "value": "/nodes/sop/block_end##mode", "type": "link", "text": ["piecewise mode"], "fullpath": "/nodes/sop/block_end##mode", "fragment": "#mode"}, "."], "extent": [4319, 4553]}], "container": true, "attrs": {"id": "class"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Piece Attribute"], "extent": [4553, 4570], "body": [{"type": "para", "indent": 4, "text": ["When on, specifies the name of the partition attribute that defines the pieces, where each point or primitive (depending on the current ", {"type": "ui", "text": ["Piece Elements"]}, " parameter setting) with the same attribute value is considered part of the same piece. Partition attributes can only be integers or strings. If a ", {"type": "ui", "text": ["Piece Attribute"]}, " is not provided, then the node will loop over every point or primitive on the input. This parameter is only available when in ", {"scheme": "Node", "value": "/nodes/sop/block_end##mode", "type": "link", "text": ["piecewise mode"], "fullpath": "/nodes/sop/block_end##mode", "fragment": "#mode"}, "."], "extent": [4586, 5085]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [5085, 5095], "body": [{"type": "para", "indent": 8, "text": ["Several tools (for example, like the ", {"scheme": "Icon", "value": "/icons/SOP/shatter.svg", "type": "link", "text": "", "fullpath": "/icons/SOP/shatter.svg"}, " ", {"scheme": null, "value": "/shelf/shatter", "type": "link", "text": ["Shatter"], "fullpath": "/shelf/shatter"}, " shelf tool) create this type of attribute for you."], "extent": [5095, 5251]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "attrib"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Max Iterations"], "extent": [5251, 5267], "body": [{"type": "para", "indent": 4, "text": ["When on, specifies the maximum number of iterations that are allowed. This can be useful for testing and debugging. You can also use this parameter to guard against huge input geometry when in ", {"scheme": "Node", "value": "/nodes/sop/block_end##mode", "type": "link", "text": ["piecewise mode"], "fullpath": "/nodes/sop/block_end##mode", "fragment": "#mode"}, "."], "extent": [5284, 5525]}], "container": true, "attrs": {"id": "maxiter"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Default Block Path"], "extent": [5525, 5545], "body": [{"type": "para", "indent": 4, "text": ["Specifies the path to the ", {"scheme": "Icon", "value": "/icons/SOP/block_begin.svg", "type": "link", "text": "", "fullpath": "/icons/SOP/block_begin.svg"}, " ", {"scheme": "Node", "value": "/nodes/sop/block_begin", "type": "link", "text": ["Block Begin SOP"], "fullpath": "/nodes/sop/block_begin"}, " node that starts this node\u2019s loop. "], "extent": [5564, 5704]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [5704, 5714], "body": [{"type": "para", "indent": 8, "text": ["When the number of ", {"type": "ui", "text": ["Iterations"]}, " is 0, then this node will output this ", {"type": "ui", "text": ["Block Begin SOP\u2019s"]}, " input."], "extent": [5714, 5824]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "blockpath"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Piece Block Path"], "extent": [5824, 5842], "body": [{"type": "para", "indent": 4, "text": ["Specifies the path to the ", {"scheme": "Icon", "value": "/icons/SOP/block_begin.svg", "type": "link", "text": "", "fullpath": "/icons/SOP/block_begin.svg"}, " ", {"scheme": "Node", "value": "/nodes/sop/block_begin", "type": "link", "text": ["Block Begin SOP"], "fullpath": "/nodes/sop/block_begin"}, " node from which to get the pieces. Alternatively, you can connect the geometry that contains the pieces to this node\u2019s ", {"type": "em", "text": ["second input"]}, ". Either method switches this node to ", {"scheme": "Node", "value": "/nodes/sop/block_end##mode", "type": "link", "text": ["piecewise mode"], "fullpath": "/nodes/sop/block_end##mode", "fragment": "#mode"}, "."], "extent": [5864, 6182]}], "container": true, "attrs": {"id": "templatepath"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Reset Cached Pass"], "extent": [6182, 6201], "body": [{"type": "para", "indent": 4, "text": ["After cooking, this node caches the output of its loop\u2019s last iteration. This allows you debug the last iteration by moving the display flag around inside the loop. This button clears that cache, and until the node cooks again, this node will show its initial state."], "extent": [6224, 6496]}], "container": true, "attrs": {"id": "resetcookpass"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Single Pass"], "extent": [6496, 6509], "body": [{"type": "para", "indent": 4, "text": ["When on, runs a single iteration at the given offset. This is useful for debugging ", {"scheme": "Node", "value": "/nodes/sop/block_end##mode", "type": "link", "text": ["piecewise"], "fullpath": "/nodes/sop/block_end##mode", "fragment": "#mode"}, " loops and showing the output of an individual piece/iteration."], "extent": [6529, 6717]}], "container": true, "attrs": {"id": "singlepass"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Stop Condition"], "extent": [6717, 6733], "body": [{"type": "para", "indent": 4, "text": ["If this parameter is ", {"type": "code", "text": ["1"]}, " at the start of an iteration, then looping of the block stops. As such, you can add an expression to this parameter to test various conditions. For example, you could set a threshold for the number of polygons in a feedback loop."], "extent": [6756, 7016]}, {"type": "para", "indent": 4, "text": ["When the stop condition triggers before the first iteration of a loop, then it is as if ", {"type": "ui", "text": ["Max Iterations"]}, " was set to ", {"type": "code", "text": ["0"]}, " and the node outputs the input of the ", {"scheme": "Icon", "value": "/icons/SOP/block_begin.svg", "type": "link", "text": "", "fullpath": "/icons/SOP/block_begin.svg"}, " ", {"scheme": "Node", "value": "/nodes/sop/block_begin", "type": "link", "text": ["Block Begin SOP"], "fullpath": "/nodes/sop/block_begin"}, " node specified by the ", {"type": "ui", "text": ["Default Block Path"]}, " parameter."], "extent": [7016, 7310]}], "container": true, "attrs": {"id": "stopcondition"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Multithread when Compiled"], "extent": [7310, 7337], "body": [{"type": "para", "indent": 4, "text": ["When on, if this node\u2019s For-Loop is inside of a ", {"scheme": null, "value": "/model/compile", "type": "link", "text": ["compiled block"], "fullpath": "/model/compile"}, ", then it may be possible to run each pass on a separate thread if this node has ", {"type": "ui", "text": ["Gather Method \u25b8 Merge Each Iteration"]}, " selected and no Feedback inputs. If these conditions are met, then you can create a separate task for each pass to allow singlethreaded operations to use multiple cores."], "extent": [7358, 7734]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [7734, 7744], "body": [{"type": "para", "indent": 8, "text": ["If the operations in this node\u2019s loop are already multithreaded, then there may be little gain from using this parameter and the overhead of starting tasks may even make it slower. Likewise, if the operations are very fast, then it may take longer to setup tasks than is gained. In particular, this parameter is usually only needed to multithread the outermost of a set of For-Loops."], "extent": [7744, 8137]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "multithread"}, "role": "item"}], "container": true, "role": "item_group"}], "text": "Parameters"}, {"level": 1, "id": "inputs", "container": true, "type": "inputs_section", "indent": 0, "role": "section", "extent": [8137, 8145], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["Input 1"], "extent": [8145, 8155], "body": [{"type": "para", "indent": 4, "text": ["Nodes to Iterate Over. This network chain will be re-evaluated at each iteration. Upstream ", {"scheme": "Icon", "value": "/icons/SOP/block_begin.svg", "type": "link", "text": "", "fullpath": "/icons/SOP/block_begin.svg"}, " ", {"scheme": "Node", "value": "/nodes/sop/block_begin", "type": "link", "text": ["Block Begin SOP"], "fullpath": "/nodes/sop/block_begin"}, " nodes will be dirtied on each pass."], "extent": [8155, 8360]}], "container": true}, {"type": "dt", "indent": 0, "text": ["Input 2"], "extent": [8360, 8369], "body": [{"type": "para", "indent": 4, "text": ["Geometry Pieces to Loop Over. A source for pieces to iterate over. Alternatively, you can use the ", {"scheme": "Node", "value": "/nodes/sop/block_end#templatepath", "type": "link", "text": ["Piece Block Path"], "fullpath": "/nodes/sop/block_end#templatepath", "fragment": "#templatepath"}, " parameter to specify the source (which should be a ", {"type": "ui", "text": ["Block Begin SOP"]}, " node set to ", {"type": "ui", "text": ["Method \u25b8 Extract Piece or Point"]}, ")."], "extent": [8369, 8644]}], "container": true}], "container": true}], "text": "Inputs"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [8644, 8653], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": null, "value": "/model/looping", "type": "link", "text": ["Looping in geometry networks"], "fullpath": "/model/looping"}], "extent": [8653, 8702]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/block_begin", "type": "link", "text": "", "fullpath": "/nodes/sop/block_begin"}], "extent": [8702, 8727]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/copy", "type": "link", "text": "", "fullpath": "/nodes/sop/copy"}], "extent": [8727, 8745]}], "container": true}], "text": "Related"}], "title": ["Block End"], "summary": ["The end/output of a looping block."]}