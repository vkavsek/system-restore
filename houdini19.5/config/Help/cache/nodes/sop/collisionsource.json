{"type": "root", "attrs": {"type": "node", "context": "sop", "internal": "collisionsource", "icon": "SHELF/deforming_object", "tags": "rbd, dynamics, source", "version": "2.0", "since": "16.0", "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Collision Source"], "extent": [0, 21]}, {"type": "summary", "indent": 0, "text": ["Creates geometry and VDB volumes for use with DOPs collisions."], "extent": [162, 232]}, {"type": "para", "indent": 0, "text": ["This node can be used to interpolate deforming geometry, calculate point\nvelocities, and create VDB Signed Distance volumes for fast and accurate DOPs\ncollisions, in particular with solvers such as ", {"scheme": "Node", "value": "/nodes/dop/flipsolver", "type": "link", "text": ["FLIP"], "fullpath": "/nodes/dop/flipsolver"}, " that\nrequire substepping and properly interpolated sub-frame geometry.  It is usually\nused in conjunction with a ", {"scheme": "Node", "value": "/nodes/dop/staticobject", "type": "link", "text": ["Static Object"], "fullpath": "/nodes/dop/staticobject"}, " DOP as set up\nby the ", {"scheme": null, "value": "/shelf/deformingobject", "type": "link", "text": ["Deforming Object"], "fullpath": "/shelf/deformingobject"}, " shelf tool."], "extent": [232, 684]}, {"type": "para", "indent": 0, "text": ["If the input geometry is deforming, it must have a consistent number and\nordering of points for proper interpolation to sub-frames.  The output of this\nnode is a combination of named geometry and VDB volumes."], "extent": [684, 894]}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [894, 900], "body": [{"type": "para", "indent": 4, "text": ["This SOP does not support calculating point velocities for \n    ", {"scheme": null, "value": "/model/packed", "type": "link", "text": ["packed primitives"], "fullpath": "/model/packed"}, " such as ", {"scheme": null, "value": "/io/alembic", "type": "link", "text": ["Alembic"], "fullpath": "/io/alembic"}, " files\n    or ", {"scheme": null, "value": "/crowds/agents", "type": "link", "text": ["crowd agents"], "fullpath": "/crowds/agents"}, ".  Use an ", {"scheme": "Node", "value": "/nodes/sop/unpack", "type": "link", "text": ["Unpack"], "fullpath": "/nodes/sop/unpack"}, " SOP to unpack\n    the geometry before sending into this node.  The ", {"scheme": null, "value": "/shelf/deformingobject", "type": "link", "text": ["Deforming Object"], "fullpath": "/shelf/deformingobject"}, "\n    shelf tool tries to detect packed geometry and automatically inserts an Unpack SOP."], "extent": [900, 1307]}], "container": true}], "container": true, "role": "item_group"}, {"type": "tip_group", "body": [{"type": "tip", "indent": 0, "role": "item", "extent": [1307, 1312], "body": [{"type": "para", "indent": 4, "text": ["If a collision object has both deforming SOP-level geometry ", {"type": "em", "text": ["and"]}, " transformations at the\n    Object-level, it can be helpful to create a separate non-transformed ", {"scheme": "Node", "value": "/nodes/obj/geo", "type": "link", "text": ["Geometry"], "fullpath": "/nodes/obj/geo"}, "\n    object and ", {"scheme": "Node", "value": "/nodes/sop/object_merge", "type": "link", "text": ["Object Merge"], "fullpath": "/nodes/sop/object_merge"}, " the collision object into it, with the\n    ", {"type": "ui", "text": ["Transform"]}, " parameter on the Object Merge set to ", {"type": "ui", "text": ["Into This Object"]}, ". By baking the\n    Object-level transformations into the geometry this way, it is easier to visualize the\n    point velocities and ensure they are correct before use in simulations."], "extent": [1312, 1852]}], "container": true}], "container": true, "role": "item_group"}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [1852, 1864], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Group"], "extent": [1864, 1872], "body": [{"type": "para", "indent": 4, "text": ["Specifies the primitives for which to generate collision geometry and\n    collisions."], "extent": [1872, 1963]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Geometry"], "extent": [1963, 1978], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Output Geometry"], "extent": [1978, 1996], "body": [{"type": "para", "indent": 4, "text": ["Include the geometry in the output of this node."], "extent": [1996, 2050]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Display Geometry"], "extent": [2050, 2068], "body": [{"type": "para", "indent": 4, "text": ["Display the output geometry in the viewport.  Turning this option off can\n    make it easier to visualize just the output volumes."], "extent": [2068, 2204]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Geometry Name"], "extent": [2204, 2219], "body": [{"type": "para", "indent": 4, "text": ["The primitives in the output geometry will have a ", {"type": "code", "text": ["name"]}, " attribute set\n    to this value."], "extent": [2219, 2314]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Interpolation"], "extent": [2314, 2336], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Blend Between Frames"], "extent": [2336, 2359], "body": [{"type": "para", "indent": 4, "text": ["Cooks the input geometry at the start and end of the nearest integer\n    frames, then blends between the two geometries according to the fractional\n    position within the frame.  This option can be used to interpolate\n    geometry that is defined only at whole frames, to be used with solvers\n    that require sub-frame geometry.  See the ", {"scheme": "Node", "value": "/nodes/sop/timeblend", "type": "link", "text": ["TimeBlend"], "fullpath": "/nodes/sop/timeblend"}, "\n    SOP for more information."], "extent": [2359, 2765]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Hold First Frame"], "extent": [2765, 2783], "body": [{"type": "para", "indent": 4, "text": ["Determines if the first frame should be clamped. If so, any\n    evaluations before this frame value will instead evaluate at\n    this frame value."], "extent": [2783, 2939]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Hold Last Frame"], "extent": [2939, 2956], "body": [{"type": "para", "indent": 4, "text": ["Determines if the last frame should be clamped. If so, any\n    evaluations after this frame value will instead evaluate at this\n    frame value."], "extent": [2956, 3106]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Cache Geometry in Memory"], "extent": [3106, 3132], "body": [{"type": "para", "indent": 4, "text": ["Geometry interpolation and point velocity calculation require cooking of\n    the input geometry at several different points in time.  When this option\n    is enabled, a few frames of the input geometry surrounding the current\n    frame are cached, accelerating these computations at the cost of extra\n    memory."], "extent": [3132, 3450]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Velocity"], "extent": [3450, 3467], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Approximation"], "extent": [3467, 3483], "body": [{"type": "para", "indent": 4, "text": ["The method used to compute point velocity values."], "extent": [3483, 3538]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["None"], "extent": [3538, 3548], "body": [{"type": "para", "indent": 8, "text": ["No point velocities are calculated."], "extent": [3548, 3592]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Backward Difference"], "extent": [3592, 3617], "body": [{"type": "para", "indent": 8, "text": ["Calculate velocities using the difference between the previous frame\n        and the current frame."], "extent": [3617, 3725]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Central Difference"], "extent": [3725, 3749], "body": [{"type": "para", "indent": 8, "text": ["Calculate velocities using the difference between the previous frame\n        and the next frame.  This method is generally the most accurate."], "extent": [3749, 3899]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Forward Difference"], "extent": [3899, 3923], "body": [{"type": "para", "indent": 8, "text": ["Calculate velocities using the difference between the current frame and the next frame."], "extent": [3923, 4020]}], "container": true}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Velocity Scale"], "extent": [4020, 4036], "body": [{"type": "para", "indent": 4, "text": ["When computing velocity the resulting velocity will be scaled by this\n    constant.  Note there is an internal scale of ", {"type": "code", "text": ["$FPS"]}, " to convert the\n    measured change over a frame into a change over a second."], "extent": [4036, 4245]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Compute Angular Velocity"], "extent": [4245, 4271], "body": [{"type": "para", "indent": 4, "text": ["The difference in orientation of successive frames will be used to\n    compute an angular velocity, ", {"type": "code", "text": ["w"]}, ", for the points."], "extent": [4271, 4397]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Points"], "extent": [4397, 4412], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Scatter Points"], "extent": [4412, 4429], "body": [{"type": "para", "indent": 4, "text": ["For deforming collisions, DOPs reads velocities from the nearest points\n    to any collision event.  If the input geometry consists of large\n    primitives with few points (e.g. a large box), the nearest input point\n    might not be a good sample of the object\u2019s velocity.  Enabling this option\n    will scatter points on the input geometry to better represent the\n    point velocities, to the accuracy controlled by ", {"type": "ui", "text": ["Density Scale"]}, "."], "extent": [4429, 4870]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Display Points"], "extent": [4870, 4886], "body": [{"type": "para", "indent": 4, "text": ["Show the scattered points."], "extent": [4886, 4918]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Density Scale"], "extent": [4918, 4933], "body": [{"type": "para", "indent": 4, "text": ["Measure the current point density then scale the scattering density so\n    there are approximately this many points per volume voxel as specified\n    by the ", {"type": "ui", "text": ["Voxel Size"]}, " parameter."], "extent": [4933, 5121]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Volume"], "extent": [5121, 5134], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Output Volume"], "extent": [5134, 5150], "body": [{"type": "para", "indent": 4, "text": ["Create a VDB Signed Distance volume from the input geometry primitives\n    and include it in the output of this node."], "extent": [5150, 5273]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Display Volume"], "extent": [5273, 5289], "body": [{"type": "para", "indent": 4, "text": ["Show the volume in the viewport.  Turning this option off can\n    make it easier to visualize just the output geometry."], "extent": [5289, 5414]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Volume Name"], "extent": [5414, 5427], "body": [{"type": "para", "indent": 4, "text": ["The VDB volume will have a ", {"type": "code", "text": ["name"]}, " attribute set to this value."], "extent": [5427, 5495]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Creation"], "extent": [5495, 5512], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Voxel Size"], "extent": [5512, 5525], "body": [{"type": "para", "indent": 4, "text": ["The size in world space of the voxels in the output VDB volume."], "extent": [5525, 5594]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Bandwidth"], "extent": [5594, 5605], "body": [{"type": "para", "indent": 4, "text": ["How many voxels outside the surface to fill in the generated VDB."], "extent": [5605, 5676]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Fill Interior"], "extent": [5676, 5691], "body": [{"type": "para", "indent": 4, "text": ["Fill all voxels inside the surface with ", {"type": "code", "text": ["1"]}, ", not just the voxels near\n    the surface. This requires an airtight surface and takes considerably\n    more memory and time."], "extent": [5691, 5866]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}]}], "text": "Parameters"}, {"level": 1, "id": "inputs", "container": true, "type": "inputs_section", "indent": 0, "role": "section", "extent": [5866, 5874], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["Input Geometry"], "extent": [5874, 5890], "body": [{"type": "para", "indent": 4, "text": ["The geometry from which to interpolate and create VDB volumes."], "extent": [5890, 5959]}], "container": true}], "container": true}], "text": "Inputs"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [5959, 5968], "body": [{"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": [{"scheme": "Node", "value": "/nodes/dop/staticobject", "type": "link", "text": "", "fullpath": "/nodes/dop/staticobject"}], "extent": [5968, 5998]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"scheme": "Node", "value": "/nodes/sop/timeblend", "type": "link", "text": "", "fullpath": "/nodes/sop/timeblend"}], "extent": [5998, 6025]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"scheme": "Node", "value": "/nodes/sop/trail", "type": "link", "text": "", "fullpath": "/nodes/sop/trail"}], "extent": [6025, 6048]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"scheme": "Node", "value": "/nodes/sop/vdbfrompolygons", "type": "link", "text": "", "fullpath": "/nodes/sop/vdbfrompolygons"}], "extent": [6048, 6081]}], "container": true}], "text": "Related"}], "title": ["Collision Source"], "summary": ["Creates geometry and VDB volumes for use with DOPs collisions."]}