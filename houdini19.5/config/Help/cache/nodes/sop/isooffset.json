{"type": "root", "attrs": {"type": "node", "context": "sop", "internal": "isooffset", "icon": "SOP/isooffset", "tags": "create, dynamics, model, surface", "version": null, "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["IsoOffset"], "extent": [0, 14]}, {"type": "summary", "indent": 0, "text": ["Builds an offset surface from geometry."], "extent": [124, 171]}, {"type": "para", "indent": 0, "text": ["The IsoOffset operation builds an implicit function given the input\ngeometry. It then uses the implicit function to create a shell at a\nfixed offset from the original surface."], "extent": [171, 348]}, {"type": "para", "indent": 0, "text": ["The tetrahedral mesh mode may be used to create a uniformly sampled\narray of tetrahedrons for use in simulations."], "extent": [348, 463]}, {"type": "para", "indent": 0, "text": ["The volume output modes allow the implicit function to be output\ndirectly as a volume primitive without further processing."], "extent": [463, 588]}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [588, 600], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Output"], "extent": [600, 609], "body": [{"type": "para", "indent": 4, "text": ["Controls what is done with the implicit surface generated."], "extent": [609, 673]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Iso Surface"], "extent": [673, 690], "body": [{"type": "para", "indent": 8, "text": ["A polygonal mesh will be created along the specified\n        offset of the implicit function."], "extent": [690, 797]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Fog Volume"], "extent": [797, 813], "body": [{"type": "para", "indent": 8, "text": ["The volume primitive will be set to 1 inside the object\n        and 0 outside the object.  Boundary cells will have an\n        interpolated value between these extremes."], "extent": [813, 996]}], "container": true}, {"type": "dt", "indent": 4, "text": ["SDF Volume"], "extent": [996, 1012], "body": [{"type": "para", "indent": 8, "text": ["The volume primitive will be a Signed Distance Field.\n        Inside the object will store negative numbers storing the\n        distance to the nearest point on the surface.  Outside the\n        object will store positive numbers storing the distance to\n        the nearest point on the primitive.  In the GL display,\n        these tend to look inverted as the exterior is what\n        renders as opaque.  SDFs are also used by the ", {"scheme": "Node", "value": "/nodes/dop/rbdsolver", "type": "link", "text": ["RBD Solver"], "fullpath": "/nodes/dop/rbdsolver"}, " and the ", {"scheme": "Node", "value": "/nodes/dop/fluidsolver", "type": "link", "text": ["Fluid Solver"], "fullpath": "/nodes/dop/fluidsolver"}, ". For additional information, see the ", {"scheme": "Node", "value": "/nodes/vop/volumesample", "type": "link", "text": ["Volume Sample VOP"], "fullpath": "/nodes/vop/volumesample"}, " help."], "extent": [1012, 1614]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Tetra Mesh"], "extent": [1614, 1630], "body": [{"type": "para", "indent": 8, "text": ["The interior of the object is filled with tetrahedrons.\n        The resulting mesh can be used for deformers or for\n        softbody approaches."], "extent": [1630, 1784]}], "container": true}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Tetra Type"], "extent": [1784, 1796], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Tetra Skeleton"], "extent": [1816, 1836], "body": [{"type": "para", "indent": 8, "text": ["A mesh of tetrahedrons is built within the ", {"type": "q", "text": ["inside"]}, " of the\n        field. This regular mesh is ideal for use in softbody\n        dynamics. "], "extent": [1836, 1985]}, {"type": "note_group", "body": [{"type": "note", "indent": 8, "role": "item", "extent": [1985, 1999], "body": [{"type": "para", "indent": 12, "text": ["The tetrahedrons share faces, so do not have well defined normals."], "extent": [1999, 2078]}], "container": true}], "container": true, "role": "item_group"}], "container": true}, {"type": "dt", "indent": 4, "text": ["Tetra Solid"], "extent": [2078, 2095], "body": [{"type": "para", "indent": 8, "text": ["A mesh of individual tetrahedrons is built within the\n        ", {"type": "q", "text": ["inside"]}, " of the field. These tetrahedrons do not share\n        points or faces, so can be split up for various fracturing\n        operations."], "extent": [2095, 2307]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Cubes"], "extent": [2307, 2318], "body": [{"type": "para", "indent": 8, "text": ["Builds a mesh of individual cubes inside the field. These\n        cubes do not share faces or points, so can be split up for\n        fracturing operations."], "extent": [2318, 2483]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "tetratype"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Mode"], "extent": [2483, 2489], "body": [{"type": "para", "indent": 4, "text": ["Governs the method that will be used to generate the signed\n    distance field."], "extent": [2504, 2589]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Ray Intersect"], "extent": [2589, 2608], "body": [{"type": "para", "indent": 8, "text": ["Rays will be fired at the geometry from various directions\n        to determine where the surface is. The resulting field will\n        be signed, so an offset of 0 will generate an iso surface\n        separating the inside from the outside."], "extent": [2608, 2862]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Meta Balls"], "extent": [2862, 2878], "body": [{"type": "para", "indent": 8, "text": ["The ", {"type": "ui", "text": ["Ray Intersect"]}, " method determines if voxels are inside or\n        outside the object by sending rays. This can result in leaks\n        and other problems. If you are building an SDF from a\n        collection of metaballs, you can instead determine\n        inside/outside by looking at the metaball field. That is\n        what this method uses. Note that Laser Scanning is likely\n        unwanted when this method is used."], "extent": [2878, 3315]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Minimum"], "extent": [3315, 3328], "body": [{"type": "para", "indent": 8, "text": ["Exact minimum point to surface will be found. This is slow,\n        but accurate. The resulting field is not signed, so you can\n        only generate a shell around the geometry. An offset greater\n        than 0 must be specified."], "extent": [3328, 3568]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Point Cloud"], "extent": [3568, 3585], "body": [{"type": "para", "indent": 8, "text": ["Only the points of the incoming geometry are used in\n        constructing the field. If the points have normals, the\n        normals are used to determine sign. Otherwise, the field is\n        unsigned like in the case of Minimum. The ", {"scheme": "Node", "value": "/nodes/sop/scatter", "type": "link", "text": ["Scatter SOP"], "fullpath": "/nodes/sop/scatter"}, " is a\n        good way to create a good collection of points from\n        geometry."], "extent": [3585, 3943]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Implicit Box"], "extent": [3943, 3961], "body": [{"type": "para", "indent": 8, "text": ["The geometry\u2019s bounding box is used to create an implicit\n        representation."], "extent": [3961, 4052]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Implicit Sphere"], "extent": [4052, 4073], "body": [{"type": "para", "indent": 8, "text": ["The geometry\u2019s bounding sphere is used to create an\n        implicit representation."], "extent": [4073, 4167]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Implicit Plane"], "extent": [4167, 4187], "body": [{"type": "para", "indent": 8, "text": ["The geometry is represented by a plane."], "extent": [4187, 4236]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 5, "text": ["Volume Sample"], "extent": [4236, 4256], "body": [{"type": "para", "indent": 9, "text": ["The volumes in the incoming gdp are all sampled and the\n         sum of their values used to initialize the signed distance\n         field.  No correction is done after the fact, so the\n         result may not actually be a signed distance field if the\n         input isn\u2019t."], "extent": [4256, 4541]}], "container": true}, {"type": "dt", "indent": 5, "text": ["Rebuild Volume Sample"], "extent": [4541, 4569], "body": [{"type": "para", "indent": 9, "text": ["The same behavior as Volume Sample, but a correction pass\n         is done afterward to make the result a signed distance\n         field using the provided zero crossing."], "extent": [4569, 4750]}], "container": true}], "container": true}], "container": true}], "container": true}], "container": true, "attrs": {"id": "mode"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Name"], "extent": [4750, 4756], "body": [{"type": "para", "indent": 5, "text": ["The name primitive attribute will be set to this value."], "extent": [4756, 4818]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Uniform Sampling"], "extent": [4818, 4836], "body": [{"type": "para", "indent": 5, "text": ["It is often advantageous to make sure voxels in a volume are\n     cubes.  This option allows the resolution of the volume to be\n     specified without having to worry about matching the size and\n     resolution fields.  This parameter controls which axis is\n     divided into Uniform Sampling Divisions."], "extent": [4836, 5146]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Uniform Sampling Divs"], "extent": [5146, 5169], "body": [{"type": "para", "indent": 5, "text": ["The number of voxels to divide the ", {"type": "ui", "text": ["Uniform Sampling"]}, " axis into.\n     The other axes will be divided into the number of cells that\n     fit for this voxel size."], "extent": [5169, 5338]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Sampling Divs"], "extent": [5338, 5353], "body": [{"type": "para", "indent": 5, "text": ["When using non-uniform voxel cells, each dimensions resolution\n     can be specified here."], "extent": [5353, 5450]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Div Size"], "extent": [5450, 5460], "body": [{"type": "para", "indent": 5, "text": ["The uniform size of the voxels, when specifying the voxel size directly.  The given sized box will be filled by voxels of this size."], "extent": [5460, 5599]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Override Output Divs"], "extent": [5599, 5621], "body": [{"type": "para", "indent": 5, "text": ["The resolution of the output mesh or voxel array can be\n     different from what the input was sampled at."], "extent": [5621, 5734]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Output Divs"], "extent": [5734, 5747], "body": [{"type": "para", "indent": 4, "text": ["The number of divisions to evaluate the field at. This can be\n    set to a higher resolution than the field, in which case the\n    field is linearly interpolated for the missing values.  When\n    outputing volumes, this is unused as they are generated at the\n    sampling resolution."], "extent": [5764, 6053]}], "container": true, "attrs": {"id": "isodiv"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Override Bounds"], "extent": [6053, 6070], "body": [{"type": "para", "indent": 4, "text": ["The default bounding box is set to be slightly larger than the\n    incoming geometry. If you want to do a large offset, or ensure\n    that the polygonization is stable over changing input geometry,\n    override the bounds to something else. If\n    ", {"type": "ui", "text": ["Force Bounds"]}, " is on it is assumed that the geometry will fit\n    entirely within these bounds.  If a second input is specified,\n    the bounding box of that input will be used rather than the\n    bounds specified here."], "extent": [6070, 6545]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Pad Bounds"], "extent": [6545, 6557], "body": [{"type": "para", "indent": 4, "text": ["Slightly increase the specified bounds to ensure there is a\n    layer of voxels outside of the specified boundary.  This can\n    ensure that there are proper outside voxels."], "extent": [6557, 6736]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Minimum Bound"], "extent": [6736, 6751], "body": [{"type": "para", "indent": 4, "text": ["The minimum clipping plane boundary for field evaluation and\n    surface construction."], "extent": [6751, 6843]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Maximum Bound"], "extent": [6843, 6858], "body": [{"type": "para", "indent": 4, "text": ["The maximum clipping plane boundary for field evaluation and\n    surface construction."], "extent": [6858, 6950]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Offset"], "extent": [6950, 6958], "body": [{"type": "para", "indent": 4, "text": ["The offset to build the iso surface on. The resulting surface\n    will describe points at this distance from the original surface."], "extent": [6958, 7094]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Build Polygon Soup"], "extent": [7094, 7114], "body": [{"type": "para", "indent": 4, "text": ["Creates the iso surface as a polygon soup primitive instead of creating separate polygon primitives when the output is an iso surface."], "extent": [7114, 7254]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Tolerance"], "extent": [7254, 7265], "body": [{"type": "para", "indent": 4, "text": ["The tolerance to use for building the SDF. This affects the ray\n    intersection code. This tolerance is multiplied by the maximum\n    bounding box size of the original geometry, so normally is\n    independent of geometry scale."], "extent": [7265, 7499]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Laser Scan"], "extent": [7499, 7511], "body": [{"type": "para", "indent": 4, "text": ["The ", {"type": "ui", "text": ["Laser Scan"]}, " mode only applies to the ", {"type": "ui", "text": ["Ray Intersect"]}, " mode."], "extent": [7531, 7604]}, {"type": "para", "indent": 4, "text": ["In laser scan mode the SDF is build by sending rays along the\n    primary axes. Only the closest and farthest intersection is\n    used. The space between these two points is classified as\n    inside, and the rest outside."], "extent": [7604, 7831]}, {"type": "para", "indent": 4, "text": ["The laser scan mode will work even with geometry which has\n    poorly defined normals, self intersects, or isn\u2019t fully\n    watertight. The disadvantage is that interior features can\u2019t be\n    represented as they aren\u2019t detected."], "extent": [7831, 8064]}, {"type": "para", "indent": 4, "text": ["When laser scanning is turned off, the SDF is still built by\n    sending rays along the primary axes. However, all intersections are\n    found. Each pair of intersections is tested to see if\n    the segment is inside or outside. This relies on the normal of\n    the geometry being well defined (ie: manifold, no self\n    intersections), and the geometry being watertight. However, complicated\n    shapes with holes can be accurately represented."], "extent": [8064, 8515]}], "container": true, "attrs": {"id": "laserscan"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Fix Signs"], "extent": [8515, 8526], "body": [{"type": "para", "indent": 4, "text": ["Even with the best made geometry, numerical imprecision can\n    result in incorrect sign choices. This option will cause the SDF\n    to be post-processed to look for inconsistent signs. These are\n    then made consistent, usually plugging leaks and filling holes."], "extent": [8526, 8795]}, {"type": "para", "indent": 4, "text": ["This takes time, however, so can be turned off in cases where\n    the SDF is known to generate without problems."], "extent": [8795, 8913], "body": [{"type": "para", "indent": 5, "text": ["NOTE:"], "extent": [8913, 8924]}], "container": true}, {"type": "para", "indent": 4, "text": ["Due to the nature of ", {"type": "ui", "text": ["Fix Signs"]}, " it also rounds sharp"], "extent": [8924, 8984], "body": [{"type": "para", "indent": 5, "text": ["features in the SDF as they may be considered inconsistent\n     signs."], "extent": [8984, 9061]}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Force Bounds"], "extent": [9061, 9075], "body": [{"type": "para", "indent": 4, "text": ["The ", {"type": "ui", "text": ["Fix Signs"]}, " method alone will smooth out, and usually\n    eliminate, sign inversions. However, it is possible for regions\n    of wrong-sign to become stabilized at the boundary of the SDF.\n    This option will force all voxels on the boundary to be marked\n    as exterior. The ", {"type": "ui", "text": ["Fix Signs"]}, " will be much less likely to stabilize\n    incorrectly then."], "extent": [9075, 9437]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Invert Sign"], "extent": [9437, 9450], "body": [{"type": "para", "indent": 4, "text": ["If one wants a hollow box, one method is to build one box inside\n    the other and not use ", {"type": "ui", "text": ["Laser Scanning"]}, ". A more robust method is to\n    just specify the inner box and use sign inversion. This treats\n    everything outside of the box as inside, allowing the more\n    robust ", {"type": "ui", "text": ["Laser Scanning"]}, " method to be used."], "extent": [9450, 9772]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Num Neighbour"], "extent": [9772, 9787], "body": [{"type": "para", "indent": 4, "text": ["The Point Cloud mode finds this number of nearest points and\n    uses them to determine the local surface properties. A higher\n    number of neighbor will smooth out local variations and create\n    a smoother field."], "extent": [9810, 10031]}], "container": true, "attrs": {"id": "numneighbour"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Sign Sweep Threshold"], "extent": [10031, 10053], "body": [{"type": "para", "indent": 4, "text": ["After the fix signs process is complete there can still be\n    inconsistent areas in the SDF.  Large blocks can become\n    stabilized and stick out of the SDF.  A second sign sweep pass\n    can be performed to try to eliminate these blocks."], "extent": [10053, 10299]}, {"type": "para", "indent": 4, "text": ["The sign sweep threshold governs how big of a jump has to\n    occur for a sign transition to be considered inconsistent.  If\n    the values of the sdf change by more than this threshold times\n    the width of the cell, it is considered an invalid sign\n    transition.  The original geometry is then ray intersected to\n    determine inside/outside and the result used to determine\n    which sign is correct.  The correct sign is then propagated\n    forward through the model."], "extent": [10299, 10779]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Max Sign Sweep Count"], "extent": [10779, 10801], "body": [{"type": "para", "indent": 4, "text": ["The sign sweeps are repeated until no signs are flipped (ie,\n    all transitions are within the threshold) or this maximum is\n    reached.  Too low of a sign sweep threshold may prevent the\n    process from converging.  Otherwise, it tends to converge very\n    quickly."], "extent": [10801, 11076]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["File Mode"], "extent": [11076, 11087], "body": [{"type": "para", "indent": 4, "text": ["The IsoOffset SOP can be used to load and save SDFs from disk\n    rather than always having to recalculate them. The File Mode\n    determines what, if any, disk access occurs."], "extent": [11087, 11268]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Automatic"], "extent": [11268, 11283], "body": [{"type": "para", "indent": 8, "text": ["If the file does not exist, the file will be written.\n        Otherwise, the SDF will be read from the file."], "extent": [11283, 11400]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Read Files"], "extent": [11400, 11416], "body": [{"type": "para", "indent": 8, "text": ["The file will be read. The input geometry will only be used\n        to determine the bounding box (if override bounds is off)\n        and otherwise ignored."], "extent": [11416, 11581]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Write Files"], "extent": [11581, 11598], "body": [{"type": "para", "indent": 8, "text": ["The SDF will be calculated from the input geometry and the\n        result saved in the given file name."], "extent": [11598, 11710]}], "container": true}, {"type": "dt", "indent": 4, "text": ["No Operation"], "extent": [11710, 11728], "body": [{"type": "para", "indent": 8, "text": ["No file access will occur. The SDF will be generated from\n        the input geometry and then discarded after the result\n        geometry is created."], "extent": [11728, 11887]}], "container": true}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["File Name"], "extent": [11887, 11898], "body": [{"type": "para", "indent": 4, "text": ["The name of the file to save the SDF representation to. If the\n    extension is .simdata, it will be saved in a format readable by\n    the File DOP. If it is saved in .sdf, it will be saved in the\n    .sdf format. Behavior with other extensions is undefined."], "extent": [11898, 12162]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}], "text": "Parameters"}, {"level": 1, "id": "inputs", "container": true, "type": "inputs_section", "indent": 0, "role": "section", "extent": [12162, 12170], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["Source"], "extent": [12170, 12179], "body": [{"type": "para", "indent": 4, "text": ["The geometry to convert into an SDF and then rebuild."], "extent": [12179, 12238]}], "container": true}, {"type": "dt", "indent": 0, "text": ["Reference Bounds"], "extent": [12238, 12256], "body": [{"type": "para", "indent": 4, "text": ["The geometry to use for the bounding box if ", {"type": "ui", "text": ["Override Bounds"]}, " is\n    specified."], "extent": [12256, 12343]}], "container": true}], "container": true}], "text": "Inputs"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [12343, 12352], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/iso", "type": "link", "text": "", "fullpath": "/nodes/sop/iso"}], "extent": [12352, 12370]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/scatter", "type": "link", "text": "", "fullpath": "/nodes/sop/scatter"}], "extent": [12370, 12391]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": null, "value": "/pyro/convertobjecttosmoke", "type": "link", "text": ["How to convert an object into smoke"], "fullpath": "/pyro/convertobjecttosmoke"}], "extent": [12391, 12459]}], "container": true}], "text": "Related"}], "title": ["IsoOffset"], "summary": ["Builds an offset surface from geometry."]}