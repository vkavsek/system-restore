{"type": "root", "attrs": {"type": "node", "context": "sop", "internal": "vdbcombine", "icon": "COMMON/openvdb", "since": "12.5", "verb_since": "16.5", "tags": "vdb, volumemix, vdbresample, vdbmerge", "version": null, "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["VDB Combine"], "extent": [148, 164]}, {"type": "summary", "indent": 0, "text": ["Combines the values of two VDB volumes in various ways."], "extent": [164, 228]}, {"type": "para", "indent": 0, "text": ["See ", {"scheme": null, "value": "/model/volumes", "type": "link", "text": ["volumes"], "fullpath": "/model/volumes"}, " for an explanation of standard volumes and OpenVDB volumes."], "extent": [16, 105]}, {"type": "para", "indent": 0, "text": ["The ", {"scheme": "Node", "value": "/nodes/sop/volumemix", "type": "link", "text": ["Volume Mix SOP"], "fullpath": "/nodes/sop/volumemix"}, " also works on VDBs.\nHowever, Volume Mix only operates on the ", {"type": "q", "text": ["active"]}, " area of the destination\nvolume.\nThat is, it will only update the ", {"type": "q", "text": ["non-empty"]}, " voxels in the destination VDB.\nTo get a true union of two disjoint VDB volumes, you must use this node."], "extent": [252, 544]}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [544, 556], "body": [{"type": "para", "indent": 0, "text": ["See ", {"scheme": null, "value": "/model/volumes#group", "type": "link", "text": ["specifying volumes"], "fullpath": "/model/volumes#group", "fragment": "#group"}, "."], "extent": [556, 605]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Group A"], "extent": [605, 614], "body": [{"type": "para", "indent": 4, "text": ["The volume primitives to be used from the first input."], "extent": [614, 678]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Group B"], "extent": [678, 687], "body": [{"type": "para", "indent": 4, "text": ["The volume primitives to merge in from the second input."], "extent": [687, 749]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Flatten All B into A"], "extent": [749, 771], "body": [{"type": "para", "indent": 4, "text": ["Requires that there is only one VDB in the A group.  Every VDB\n    in the B group will, in turn, be combined with the VDB in\n    the A group.  This can flatten a large collection of VDBs into\n    a single VDB."], "extent": [771, 986]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Combine A/B Pairs"], "extent": [986, 1005], "body": [{"type": "para", "indent": 4, "text": ["If disabled, each VDB in the A group will be combined with\n    the first VDB in the B group.  If enabled, the combination\n    will be done pairwise."], "extent": [1005, 1163]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Operation"], "extent": [1163, 1174], "body": [{"type": "para", "indent": 4, "text": ["Each voxel that is active in either of the input grids\n    will be processed with this operation."], "extent": [1174, 1277]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Copy A"], "extent": [1277, 1289], "body": [{"type": "para", "indent": 8, "text": ["Use ", {"type": "code", "text": ["A"]}, ", ignore ", {"type": "code", "text": ["B"]}, "."], "extent": [1289, 1327]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Copy B"], "extent": [1327, 1339], "body": [{"type": "para", "indent": 8, "text": ["Use ", {"type": "code", "text": ["B"]}, ", ignore ", {"type": "code", "text": ["A"]}, "."], "extent": [1339, 1377]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Invert A"], "extent": [1377, 1391], "body": [{"type": "para", "indent": 8, "text": ["Use ", {"type": "code", "text": ["0 - A"]}], "extent": [1391, 1420]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Add"], "extent": [1420, 1429], "body": [{"type": "para", "indent": 8, "text": ["Add the values of ", {"type": "code", "text": ["A"]}, " and ", {"type": "code", "text": ["B"]}, "."], "extent": [1429, 1469]}, {"type": "note_group", "body": [{"type": "note", "indent": 8, "role": "item", "extent": [1469, 1483], "body": [{"type": "para", "indent": 12, "text": ["Using this for fog volumes (ie. density values between 0 and 1)"], "extent": [1483, 1559]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 8, "text": ["will push density values over 1.0, which causes a bright interface\n        between the input volumes when rendered. Try using the\n        ", {"type": "code", "text": ["A + (1 - A) * B"]}, " operation to avoid this."], "extent": [1559, 1749]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Subtract"], "extent": [1749, 1763], "body": [{"type": "para", "indent": 8, "text": ["Subtract the values of ", {"type": "code", "text": ["B"]}, " from the values of ", {"type": "code", "text": ["A"]}, "."], "extent": [1763, 1831]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Multiply"], "extent": [1831, 1845], "body": [{"type": "para", "indent": 8, "text": ["Multiply the values of ", {"type": "code", "text": ["A"]}, " and ", {"type": "code", "text": ["B"]}, "."], "extent": [1845, 1898]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Divide"], "extent": [1898, 1910], "body": [{"type": "para", "indent": 8, "text": ["Divide the values of ", {"type": "code", "text": ["A"]}, " by ", {"type": "code", "text": ["B"]}, "."], "extent": [1910, 1960]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Maximum"], "extent": [1960, 1973], "body": [{"type": "para", "indent": 8, "text": ["Use the maximum of each corresponding value from ", {"type": "code", "text": ["A"]}, " and ", {"type": "code", "text": ["B"]}, "."], "extent": [1973, 2044]}, {"type": "note_group", "body": [{"type": "note", "indent": 8, "role": "item", "extent": [2044, 2058], "body": [{"type": "para", "indent": 12, "text": ["Using this for fog volumes (ie. density values between 0 and 1)"], "extent": [2058, 2134]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 8, "text": ["can produce a dark interface between the inputs when rendered due to\n        the binary nature of choosing a value from either from ", {"type": "code", "text": ["A"]}, " or ", {"type": "code", "text": ["B"]}, ".\n        To avoid this problem, try using the ", {"type": "code", "text": ["(1 - A) * B"]}, " operation."], "extent": [2134, 2365]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Minimum"], "extent": [2365, 2378], "body": [{"type": "para", "indent": 8, "text": ["Use the minimum of each corresponding value from ", {"type": "code", "text": ["A"]}, " and ", {"type": "code", "text": ["B"]}, "."], "extent": [2378, 2457]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["(1 - A) * B"]}], "extent": [2457, 2476], "body": [{"type": "para", "indent": 8, "text": ["This is similar to ", {"type": "code", "text": ["SDF Difference"]}, " except for fog volumes. It can also\n        be viewed as ", {"type": "q", "text": ["soft cut out"]}, " operation. Typically used to clear out an\n        area around characters in a dust simulation or some other environmental\n        volume."], "extent": [2476, 2731]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["A + (1 - A) * B"]}], "extent": [2731, 2754], "body": [{"type": "para", "indent": 8, "text": ["This is similar to ", {"type": "code", "text": ["SDF Union"]}, " except for fog volumes. It can also be\n        viewed as a ", {"type": "q", "text": ["soft union"]}, " or ", {"type": "q", "text": ["merge"]}, " operation. Consider using this over\n        the ", {"type": "code", "text": ["Maximum"]}, " or ", {"type": "code", "text": ["Add"]}, " operations for fog volumes."], "extent": [2754, 2972]}], "container": true}, {"type": "dt", "indent": 4, "text": ["SDF Union"], "extent": [2972, 2987], "body": [{"type": "para", "indent": 8, "text": ["Generate the union of signed distance fields A and B."], "extent": [2987, 3054]}], "container": true}, {"type": "dt", "indent": 4, "text": ["SDF Intersection"], "extent": [3054, 3076], "body": [{"type": "para", "indent": 8, "text": ["Generate the intersection of signed distance fields A and B."], "extent": [3076, 3154]}], "container": true}, {"type": "dt", "indent": 4, "text": ["SDF Difference"], "extent": [3154, 3174], "body": [{"type": "para", "indent": 8, "text": ["Remove signed distance field B from signed distance field A."], "extent": [3174, 3244]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Replace A with Active B"], "extent": [3244, 3273], "body": [{"type": "para", "indent": 8, "text": ["Copy the active voxels of B into A."], "extent": [3273, 3318]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Activity Union"], "extent": [3318, 3338], "body": [{"type": "para", "indent": 8, "text": ["Make voxels active which are active in both A ", {"type": "em", "text": ["or"]}, " B."], "extent": [3338, 3401]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Activity Intersection"], "extent": [3401, 3428], "body": [{"type": "para", "indent": 8, "text": ["Each voxel\u2019s active state is set to whether it is active in both A\n        ", {"type": "em", "text": ["and"]}, " B. This operation may deactivate voxels so it is recommended to\n        enable pruning when using this."], "extent": [3428, 3622]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Activity Difference"], "extent": [3622, 3647], "body": [{"type": "para", "indent": 8, "text": ["Each voxel\u2019s active state is set to ", {"type": "strong", "text": ["on"]}, " if is active in A but not B.\n        Otherwise, the voxel is made inactive.  It is recommended to enable\n        pruning when using this."], "extent": [3647, 3835]}], "container": true}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["A Multiplier"], "extent": [3835, 3849], "body": [{"type": "para", "indent": 4, "text": ["Scale values in the first field by this amount before the operation."], "extent": [3849, 3927]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["B Multiplier"], "extent": [3927, 3941], "body": [{"type": "para", "indent": 4, "text": ["Scale values in the second field by this amount before the operation."], "extent": [3941, 4016]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Resample"], "extent": [4016, 4026], "body": [{"type": "para", "indent": 4, "text": ["If the A and B VDB grids have different transforms, one grid should\n    be resampled to match the other before the two are combined.\n    Also, level set grids should have matching background values\n    (i.e., matching narrow band widths)."], "extent": [4026, 4270]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Interpolation"], "extent": [4270, 4285], "body": [{"type": "para", "indent": 4, "text": ["Specify the type of interpolation to be used when resampling."], "extent": [4285, 4352]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Deactivate Tolerance"], "extent": [4352, 4374], "body": [{"type": "para", "indent": 4, "text": ["Deactivate active output voxels whose values equal the output grid\u2019s\n    background value.  Voxel values are considered equal if they differ by less\n    than the specified tolerance."], "extent": [4374, 4562]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Prune Tolerance"], "extent": [4562, 4579], "body": [{"type": "para", "indent": 4, "text": ["After building the VDB grid there may be undetected constant tiles.\n    This tolerance is used to detect constant regions and collapse them.\n    Such areas that are within the background value will also be marked\n    inactive."], "extent": [4579, 4811]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Signed-Flood-Fill Output"], "extent": [4811, 4837], "body": [{"type": "para", "indent": 4, "text": ["Tests areas of inactive background values to determine if they\n    are inside or outside of an SDF, and hence whether they should\n    have negative or positive sign."], "extent": [4837, 5008]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}], "text": "Parameters"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [5008, 5017], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/volumevop", "type": "link", "text": "", "fullpath": "/nodes/sop/volumevop"}], "extent": [5017, 5041]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/volumemix", "type": "link", "text": "", "fullpath": "/nodes/sop/volumemix"}], "extent": [5041, 5064]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/vdbmerge", "type": "link", "text": "", "fullpath": "/nodes/sop/vdbmerge"}], "extent": [5064, 5087]}], "container": true}], "text": "Related"}], "title": ["VDB Combine"], "summary": ["Combines the values of two VDB volumes in various ways."], "included": ["/nodes/sop/volume_types"]}