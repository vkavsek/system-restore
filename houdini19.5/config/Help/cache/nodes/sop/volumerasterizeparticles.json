{"type": "root", "attrs": {"type": "node", "context": "sop", "internal": "volumerasterizeparticles", "icon": "SOP/volumerasterizeparticles", "tags": "volumes, merge", "since": "13.0", "verb_since": "16.5", "version": null, "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Volume Rasterize Particles"], "extent": [0, 31]}, {"type": "summary", "indent": 0, "text": ["Converts a point cloud into a volume."], "extent": [184, 229]}, {"type": "para", "indent": 0, "text": ["The Volume Rasterize particles operation takes a cloud of points and fills\na volume accordingly. If the input volume has more than one named\nprimitive, the named volumes will be filled with data from point attributes\nthat match the name of the volume. Currently only VDB vector volumes\nsupport filling from vector point attributes."], "extent": [229, 562]}, {"type": "para", "indent": 0, "text": ["The point attribute ", {"type": "code", "text": ["pscale"]}, " is used (along with the specified ", {"type": "ui", "text": ["Coverage\nAttribute"]}, ") to control the generated volume."], "extent": [562, 683]}, {"type": "para", "indent": 0, "text": ["This is a highly specialized node designed for filling the volume\nas fast as possible, so a lot of the controls present in ", {"scheme": "Node", "value": "/nodes/sop/volumerasterizepoints", "type": "link", "text": ["Volume Rasterize\nPoints"], "fullpath": "/nodes/sop/volumerasterizepoints"}, " are not available."], "extent": [683, 883]}, {"type": "para", "indent": 0, "text": ["Filtering is automatically performed to ensure small particles will always\ncontribute to the resulting volume.  This means that when you rasterize to a\nparticularly low resolution volume, things will seem to fatten."], "extent": [883, 1100]}, {"type": "para", "indent": 0, "text": ["The ", {"type": "code", "text": ["volumefilterstochastic"]}, " integer primitive attribute can be used to\noverride how points are filtered to voxels. For fields that can\u2019t be\nmeaningfully averaged together, setting this attribute to a value of 1 on\nthat volume primitive will cause only one of the overlapping particles to\ncontribute to each voxel, avoiding any averaging. This parameter only\napplies to fields other than coverage."], "extent": [1100, 1499]}, {"type": "para", "indent": 0, "text": ["Alternatively, the stamping method for each volume can be controlled separately\nby specifying rules, bypassing the need to set primitive attributes."], "extent": [1499, 1649]}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [1649, 1655], "body": [{"type": "para", "indent": 4, "text": ["This node does not support rasterizing into tapered volumes."], "extent": [1655, 1721]}], "container": true}], "container": true, "role": "item_group"}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [1721, 1733], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Destination"], "extent": [1733, 1747], "body": [{"type": "para", "indent": 4, "text": ["Which volumes or VDBs in the first input to stamp into."], "extent": [1747, 1808]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Particles"], "extent": [1808, 1819], "body": [{"type": "para", "indent": 4, "text": ["A group of points in the second input to rasterize."], "extent": [1819, 1876]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Filter"], "extent": [1876, 1884], "body": [{"type": "para", "indent": 4, "text": ["The filter shape to use when splatting particles. The default Gaussian\n    filter will produce smooth blobs and is useful for larger particles. When\n    the particle size is smaller than the voxel size, a box filter will produce\n    a similar result in less time."], "extent": [1884, 2153]}, {"type": "para", "indent": 4, "text": ["While most filters are designed to integrate over the voxel, the Cubic \n    Spline Filter instead is designed for defining the value at the voxel center. \n    This is useful for performing precise particle to grid transfers for APIC\n    (Affine Particle-in-Cell) based algorithms. Weights on neighboring grid nodes\n    depend only on the voxel size and their relative position to the particle, \n    which are not affected by the coverage and scale attributes."], "extent": [2153, 2618]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Coverage Attribute"], "extent": [2618, 2638], "body": [{"type": "para", "indent": 4, "text": ["Name of the point attribute that stores the coverage (or influence) of each\n    particle. If the coverage attribute does not exist, each particle is\n    assumed to have a coverage of 1."], "extent": [2638, 2829]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Coverage Scale"], "extent": [2829, 2845], "body": [{"type": "para", "indent": 4, "text": ["The coverage attribute will be scaled by this value."], "extent": [2845, 2903]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Particle Scale"], "extent": [2903, 2919], "body": [{"type": "para", "indent": 4, "text": ["The ", {"type": "code", "text": ["pscale"]}, " attribute will be scaled by this value. If this attribute does\n    not exist, 1 will be used as the reference."], "extent": [2919, 3048]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Minimum Filter Size"], "extent": [3048, 3069], "body": [{"type": "para", "indent": 4, "text": ["If the particle\u2019s radius is much smaller than a voxel, it can appear to pop\n    from grid-location to grid-location as it moves.  This adds an additional\n    blur to particles to ensure they are this fraction of a voxel.  A value of\n    1 ensures the main-support for each particle is at least a voxel, \n    guaranteeing that any movement of the particle will correspond to a smooth\n    change in voxel values, at the cost of less sharp boundaries."], "extent": [3069, 3523]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Velocity Blur"], "extent": [3523, 3538], "body": [{"type": "para", "indent": 4, "text": ["Enables rasterization of velocity blur. Velocity blurred particles are\n    rasterized by creating multiple point samples along the velocity path and\n    distributing the coverage of the original point among these samples."], "extent": [3538, 3765]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Shutter"], "extent": [3765, 3774], "body": [{"type": "para", "indent": 4, "text": ["The shutter time to use for velocity blur rasterization."], "extent": [3774, 3836]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Shutter Offset"], "extent": [3836, 3852], "body": [{"type": "para", "indent": 4, "text": ["The shutter offset to use for velocity blur rasterization."], "extent": [3852, 3916]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Blur Samples"], "extent": [3916, 3930], "body": [{"type": "para", "indent": 4, "text": ["The number of motion blur samples to use for velocity blur rasterization.\n    Larger numbers of samples will produce smoother and more accurate results,\n    but will take more time to compute."], "extent": [3930, 4128]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Normalize by Clamped Coverage"], "extent": [4128, 4159], "body": [{"type": "para", "indent": 4, "text": ["Enabling this option multiplies the sampled volume by coverage, yielding a\n    smooth transition between areas covered by the particles."], "extent": [4159, 4301]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [4301, 4311], "body": [{"type": "para", "indent": 8, "text": ["This option changes the default stamping method from ", {"type": "ui", "text": ["Weighted Average"]}, "\n        to ", {"type": "ui", "text": ["Covered Average"]}, "; ", {"type": "ui", "text": ["Attribute Rules"]}, " can be used to override this\n        default behavior."], "extent": [4311, 4501]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Attribute Rules"], "extent": [4501, 4518], "body": [{"type": "para", "indent": 4, "text": ["Rules that specify the stamping method on a per-volume basis."], "extent": [4518, 4585]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [4585, 4595], "body": [{"type": "para", "indent": 8, "text": ["If multiple rules apply to a volume, the first one is used."], "extent": [4595, 4664]}], "container": true}, {"type": "note", "indent": 4, "role": "item", "extent": [4664, 4674], "body": [{"type": "para", "indent": 8, "text": [{"type": "code", "text": ["volumefilterstochastic"]}, " primitive attribute takes precedence over the\n        rules. That is, ", {"type": "ui", "text": ["Stochastic"]}, " stamping will be used for all volumes that\n        have a value of 1 for the aforementioned attribute. If value is 0,\n        however, then the appropriate rule still applies."], "extent": [4674, 4969]}], "container": true}, {"type": "note", "indent": 4, "role": "item", "extent": [4969, 4979], "body": [{"type": "para", "indent": 8, "text": ["The ", {"type": "ui", "text": ["Coverage Attribute"]}, " is unconditionally stamped using the\n        ", {"type": "ui", "text": ["Accumulated"]}, " method."], "extent": [4979, 5084]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Attributes"], "extent": [5084, 5096], "body": [{"type": "para", "indent": 4, "text": ["This pattern identifies volumes to which the rule applies."], "extent": [5096, 5160]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Method"], "extent": [5160, 5168], "body": [{"type": "para", "indent": 4, "text": ["Stamping method to use when generating the volumes to which this rule\n    applies."], "extent": [5168, 5256]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Weighted Average"], "extent": [5256, 5278], "body": [{"type": "para", "indent": 8, "text": ["Voxel value is weighted average of attribute value from the overlapping\n        particles; weight depends on the coverage attribute, as well as\n        distance of the particle from the sample location."], "extent": [5278, 5489]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Covered Average"], "extent": [5489, 5510], "body": [{"type": "para", "indent": 8, "text": ["Same as ", {"type": "ui", "text": ["Weighted Average"]}, ", but areas outside of particle influence are\n        attenuated, yielding smooth falloff."], "extent": [5510, 5637]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Accumulated"], "extent": [5637, 5654], "body": [{"type": "para", "indent": 8, "text": ["Contributions from all particles are simply summed up."], "extent": [5654, 5717]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Stochastic"], "extent": [5717, 5733], "body": [{"type": "para", "indent": 8, "text": ["Voxel value is deduced from a single (pseudorandomly selected)\n        overlapping particle."], "extent": [5733, 5835]}], "container": true}], "container": true}], "container": true, "role": "item"}], "container": true, "role": "item_group"}], "text": "Parameters"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [5835, 5844], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/volumerasterizepoints", "type": "link", "text": "", "fullpath": "/nodes/sop/volumerasterizepoints"}], "extent": [5844, 5881]}], "container": true}], "text": "Related"}], "title": ["Volume Rasterize Particles"], "summary": ["Converts a point cloud into a volume."]}