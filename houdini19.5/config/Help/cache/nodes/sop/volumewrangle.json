{"type": "root", "attrs": {"type": "node", "context": "sop", "internal": "volumewrangle", "icon": "SOP/volumewrangle", "tags": "volume, attrs, core, tech", "since": "12.5", "version": null, "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Volume Wrangle"], "extent": [0, 19]}, {"type": "summary", "indent": 0, "text": ["Runs a VEX snippet to modify voxel values in a volume."], "extent": [143, 205]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Overview"], "extent": [205, 220], "body": [{"type": "para", "indent": 0, "text": ["This is a very powerful, low-level node that lets experts who are\nfamiliar with VEX tweak voxel values using code."], "extent": [220, 337]}, {"type": "para", "indent": 0, "text": ["This node corresponds to the ", {"scheme": "Node", "value": "/nodes/sop/volumevop", "type": "link", "text": ["Volume VOP SOP"], "fullpath": "/nodes/sop/volumevop"}, ",\nbut uses a textual VEX snippet instead of a VOP network."], "extent": [337, 461]}, {"type": "para", "indent": 0, "text": ["This node runs the snippet ", {"type": "em", "text": ["on every voxel in the input volume(s)"]}, "\n(unless the ", {"type": "ui", "text": ["Bind each volume to density"]}, " parameter is on).\nThe snippet can edit the input geometry by changing attributes.\nIt can access information from other geometry using attributes and VEX functions."], "extent": [461, 737]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["Press ", {"keys": ["MMB"], "type": "keys", "text": null}, " on the node to see any error output from the snippet."], "extent": [737, 808]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You can use the VEX function ", {"type": "code", "text": ["ch"]}, " to evaluate parameters.\n  The path is relative to this node (", {"type": "code", "text": ["ch(\"parm\")"]}, " will evaluate the parameter ", {"type": "code", "text": ["parm"]}, " on this node).\n  This evaluation will be done at the current time."], "extent": [808, 1021]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Unlike the ", {"scheme": "Node", "value": "/nodes/sop/volumemix", "type": "link", "text": ["Volume Mix SOP"], "fullpath": "/nodes/sop/volumemix"}, ", this does not use local variables.\n  Further, all backtick expressions and ", {"type": "code", "text": ["$F"]}, " variables will be evaluated at frame 1,\n  not the current time.\n  Use ", {"type": "code", "text": ["Frame"]}, ", ", {"type": "code", "text": ["Time"]}, ", or ", {"type": "code", "text": ["TimeInc"]}, " instead."], "extent": [1021, 1262]}], "container": true}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Syntax"], "extent": [1262, 1275], "body": [{"type": "para", "indent": 0, "text": ["The ", {"type": "ui", "text": ["VEX snippet"]}, " parameter lets you enter a snippet of ", {"scheme": null, "value": "/vex/", "type": "link", "text": ["VEX code"], "fullpath": "/vex/index"}, " to run on the input geometry.\nSee ", {"scheme": null, "value": "/vex/snippets", "type": "link", "text": ["VEX snippets"], "fullpath": "/vex/snippets"}, " for basic information on the syntax available in the snippet parameter.\nSee ", {"scheme": null, "value": "/vex/", "type": "link", "text": ["the VEX chapter"], "fullpath": "/vex/index"}, " for general information on the VEX language."], "extent": [16, 299]}]}, {"level": 2, "id": "values", "container": true, "type": "h", "indent": 0, "text": ["Reading and modifying the voxel value"], "extent": [1303, 1356], "body": [{"type": "para", "indent": 0, "text": ["The current voxel value in a volume is available as ", {"type": "code", "text": ["@", {"type": "var", "text": ["volume_name"]}]}, ".\nYou can read this variable to get the current value, and assign it to change the value.\nFor example, to add ", {"type": "code", "text": ["0.1"]}, " to the value of every voxel in the float volume ", {"type": "code", "text": ["foo"]}, ":"], "extent": [1356, 1599]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n@foo += 0.1\n"], "extent": [1599, 1625]}, {"type": "para", "indent": 0, "text": ["If a volume does not have a name, it will automatically be bound to ", {"type": "code", "text": ["@density"]}, "."], "extent": [1625, 1707]}, {"type": "para", "indent": 0, "text": ["If you have multiple named volumes in the input, you can write a single snippet\nthat modifies the different volumes in different ways, for example:"], "extent": [1707, 1856]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n@foo += 0.1\n@bar += 0.2\n@baz += 0.3\n"], "extent": [1856, 1906]}, {"type": "para", "indent": 0, "text": ["Alternatively, you can turn on ", {"type": "ui", "text": ["Bind each volume to density"]}, ".\nThis acts as if every input volume was named ", {"type": "code", "text": ["density"]}, ",\nso you can use the same snippet to modify every voxel in every volume:"], "extent": [1906, 2099]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n// Modify @foo, @bar, and @baz in the same way\n// (when Bind each volume to density is on)\n@density += sin(@P.x)\n"], "extent": [2099, 2226]}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [2226, 2233], "body": [{"type": "para", "indent": 4, "text": ["Unlike how the\n    ", {"scheme": "Node", "value": "/nodes/sop/pointwrangle", "type": "link", "text": ["Point Wrangle"], "fullpath": "/nodes/sop/pointwrangle"}, "\n    and ", {"scheme": "Node", "value": "/nodes/sop/attribwrangle", "type": "link", "text": ["Attribute Wrangle"], "fullpath": "/nodes/sop/attribwrangle"}, " nodes work,\n    writing to an unknown ", {"type": "code", "text": ["@", {"type": "var", "text": ["name"]}]}, " variable will not create a volume."], "extent": [2233, 2431]}], "container": true}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["VEX variables"], "extent": [2431, 2451], "body": [{"type": "para", "indent": 0, "text": ["You can create temporary variables.\nFor example, the following code reads an offset location from a point."], "extent": [2451, 2560]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\nvector temp = @P;\ntemp += {0.1, 0.2, 0.3};\n@density = volumesample(@OpInput1, 0, temp);\n"], "extent": [2560, 2662]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Bound Variables"], "extent": [2662, 2685], "body": [{"type": "para", "indent": 0, "text": ["A number of variables are bound in the Volume VOP context. \nUse the ", {"type": "code", "text": ["@"]}, " prefix syntax to access them."], "extent": [2685, 2789]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["P"]}], "extent": [2789, 2794], "body": [{"type": "para", "indent": 8, "text": ["Location of the current voxel\u2019s center."], "extent": [2794, 2842]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["ix"]}, ", ", {"type": "code", "text": ["iy"]}, ", ", {"type": "code", "text": ["iz"]}], "extent": [2842, 2860], "body": [{"type": "para", "indent": 8, "text": ["The integer index of the current voxel.  With VDBs, this can be\n        negative."], "extent": [2860, 2950]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["resx"]}, ", ", {"type": "code", "text": ["resy"]}, ", ", {"type": "code", "text": ["resz"]}], "extent": [2950, 2974], "body": [{"type": "para", "indent": 8, "text": ["The resolution of the current volume primitive.  For VDBs this\n        is the size of the active voxel region."], "extent": [2974, 3093]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["dPdx"]}, ", ", {"type": "code", "text": ["dPdy"]}, ", ", {"type": "code", "text": ["dPdz"]}], "extent": [3093, 3117], "body": [{"type": "para", "indent": 8, "text": ["Vectors giving the length and orientation of the x, y, and z edges of\n        the 0th voxel."], "extent": [3117, 3218]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["center"]}], "extent": [3218, 3228], "body": [{"type": "para", "indent": 8, "text": ["The center of the volume in SOP space."], "extent": [3228, 3275]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["primnum"]}], "extent": [3275, 3286], "body": [{"type": "para", "indent": 8, "text": ["Primitive number of primary volume being iterated over.  If\n        more than one volume or VDB align, there may be only a single\n        pass done and this will be only one of those.  Bind Each to\n        Density will ensure one pass per primitive."], "extent": [3286, 3544]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["Time"]}], "extent": [3544, 3552], "body": [{"type": "para", "indent": 8, "text": ["Current time in seconds."], "extent": [3552, 3585]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["Frame"]}], "extent": [3585, 3594], "body": [{"type": "para", "indent": 8, "text": ["Current time in frames."], "extent": [3594, 3626]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["TimeInc"]}], "extent": [3626, 3637], "body": [{"type": "para", "indent": 8, "text": ["Time increment between frames, in seconds."], "extent": [3637, 3688]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["OpInput1"]}, ", ", {"type": "code", "text": ["OpInput2"]}, ", ", {"type": "code", "text": ["OpInput3"]}, ", ", {"type": "code", "text": ["OpInput4"]}], "extent": [3688, 3736], "body": [{"type": "para", "indent": 8, "text": ["A string that can be used to refer to the corresponding input\n        of this SOP in vex operations that take file parameters."], "extent": [3736, 3872]}], "container": true}], "container": true}]}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [3872, 3884], "body": [{"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Code"], "extent": [3884, 3896], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Group"], "extent": [3896, 3904], "body": [{"type": "para", "indent": 4, "text": ["Only run the program on these volumes in the input geometry.\n    Leave this blank to modify all volumes in the input."], "extent": [3904, 4031]}, {"type": "para", "indent": 4, "text": ["(See ", {"scheme": null, "value": "#values", "type": "link", "text": ["reading and writing voxel values"], "fullpath": "/nodes/sop/volumewrangle#values", "fragment": "#values"}, " above.)"], "extent": [4031, 4092]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Bind Each to Density"], "extent": [4092, 4114], "body": [{"type": "para", "indent": 4, "text": ["Changes how the node applies the snippet.\n    When this is off, you must refer to specific volumes in the input by name (for example ", {"type": "code", "text": ["@foo"]}, ").\n    When this is on, every input volume is treated as ", {"type": "code", "text": ["@density"]}, ",\n    so you can write one snippet to affect every input volume regardless of their names."], "extent": [4114, 4420]}, {"type": "para", "indent": 4, "text": ["(See ", {"scheme": null, "value": "#values", "type": "link", "text": ["reading and writing voxel values"], "fullpath": "/nodes/sop/volumewrangle#values", "fragment": "#values"}, " above.)"], "extent": [4420, 4485]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["VEXpression"], "extent": [2337, 2350], "body": [{"type": "para", "indent": 4, "text": ["A snippet of VEX code that will manipulate the point attributes.\n    You can use ", {"type": "code", "text": ["@", {"type": "var", "text": ["variable_name"]}]}, " syntax to access geometry attributes."], "extent": [2368, 2513]}], "container": true, "attrs": {"id": "snippet"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Volumes To Write To"], "extent": [4517, 4538], "body": [{"type": "para", "indent": 4, "text": ["Only modify volumes if their names match this pattern.\n    The default pattern allows any volume to be modified.\n    You can speed up the node by only listing volumes that are ", {"type": "em", "text": ["actually"]}, " modified by the snippet."], "extent": [4538, 4759]}, {"type": "para", "indent": 4, "text": ["For example, in the following snippet, only the ", {"type": "code", "text": ["density"]}, " volume is modified.\n    The ", {"type": "code", "text": ["temperature"]}, " volume is not modified, only read."], "extent": [4759, 4903]}, {"lang": "vex", "type": "pre", "indent": 4, "text": ["\n    @density = @temperature;\n    "], "extent": [4903, 4958]}, {"type": "para", "indent": 4, "text": ["However, for obscure reasons, the node will both modify ", {"type": "code", "text": ["density"]}, " and ", {"type": "em", "text": ["copy"]}, " ", {"type": "code", "text": ["temperature"]}, ".\n    This uses time and memory.\n    To prevent this, you could set this parameter to ", {"type": "code", "text": ["density"]}, " to prevent the node\n    from copying ", {"type": "code", "text": ["temperature"]}, ".\n    Of course, this requires that you explicitly manage the list of writable volumes."], "extent": [4958, 5292]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Enforce Prototypes"], "extent": [16, 36], "body": [{"type": "para", "indent": 4, "text": ["Requires that you declare ", {"type": "code", "text": ["@"]}, " bindings in snippets as prototypes before using them. This applies to both attributes (for example ", {"type": "code", "text": ["@Cd"]}, ") and ", {"type": "q", "text": ["convenience"]}, " bindings such as ", {"type": "code", "text": ["@ptnum"]}, " and ", {"type": "code", "text": ["@Frame"]}, ". For example:"], "extent": [36, 248]}, {"lang": "vex", "type": "pre", "indent": 4, "text": ["\n    // Declare bindings\n    int @ptnum;\n    float @Frame;\n    vector @Cd;\n\n    // Use bindings after declaration\n    int pointnum = @ptnum;\n    float red = @Cd[0] / @Frame;\n    "], "extent": [248, 447]}, {"type": "para", "indent": 4, "text": ["Automatic binding with the ", {"type": "code", "text": ["@"]}, " syntax can be convenient, but as your scene becomes more complex there is the risk that a typo in an ", {"type": "code", "text": ["@"]}, " binding will silently just bind a non-existent attribute."], "extent": [447, 646]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Bindings"], "extent": [5329, 5344], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Autobind by Name"], "extent": [5344, 5367], "body": [{"type": "para", "indent": 8, "text": ["Will use the name primitive attribute to determine which\n        volume binds with which parameter.  If the name attribute\n        isn\u2019t present, the first volume is bound to density."], "extent": [5367, 5560]}, {"type": "para", "indent": 8, "text": ["A name like ", {"type": "q", "text": ["foo"]}, " will be bound to the float parameter\n        ", {"type": "q", "text": ["foo"]}, ".  A name of ", {"type": "q", "text": ["foo.x"]}, " will be bound to the x\n        component of the vector (three float) parameter ", {"type": "q", "text": ["foo"]}, ".  A\n        name like ", {"type": "q", "text": ["foo.zx"]}, " will be bound to the x,z component of\n        the matrix (three by three) parameter ", {"type": "q", "text": ["foo"]}, "."], "extent": [5560, 5869]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Primitive, Primitive Name, VEX Parameter"], "extent": [5869, 5915], "body": [{"type": "para", "indent": 8, "text": ["Manually specifies the bindings of each primitive.  This\n        is equivalent to those primitives having a name attribute\n        with the given name.  If Primitive Name is not empty,\n        the primitive with the matching name will be bound to the\n        given vex parameter."], "extent": [5915, 6204]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Only Output Created Geometry"], "extent": [6204, 6238], "body": [{"type": "para", "indent": 8, "text": ["Don\u2019t output any of the incoming volumes.  Instead, the output\n        will consiste of only geometry created by the VOPs.  This\n        is useful if generating points from volumes.  Note you will\n        still have to do a dummy write to any volume you wish\n        to iterate over."], "extent": [6238, 6531]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Evaluation Node Path"], "extent": [6531, 6557], "body": [{"type": "para", "indent": 8, "text": ["VEX functions like ", {"type": "code", "text": ["ch()"]}, " usually evaluate with respect to this node.\n        Providing a path here can override where the path search starts\n        from.  This is useful for embedding in a digital asset where you\n        would like the top level digital asset to be the search root."], "extent": [6557, 6851]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Export Parameters"], "extent": [6851, 6874], "body": [{"type": "para", "indent": 8, "text": ["This pattern can be used to override\n        the export option on the VEX shader to avoid writing to \n        certain volumes.  The pattern matches the VEX parameter, not\n        the bound volume.  The volume will still be bound for\n        reading."], "extent": [6874, 7133]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["VEX Precision"], "extent": [2846, 2862], "body": [{"type": "para", "indent": 4, "text": ["VEX can evaluate at 32-bit or 64-bit precision.  64-bit provides\n    higher accuracy, especially for transforms."], "extent": [2886, 3008]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [3008, 3018], "body": [{"type": "para", "indent": 8, "text": ["Incoming attributes will preserve their original precision, so using 64-bit VEX on 32-bit positions will convert them to 64-bit, apply the operation, then convert back to 32-bit when writing out."], "extent": [3018, 3227]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 4, "text": ["The auto mode will switch between 32-bit and 64-bit depending on the preferred precision of the incoming geometry. When run in 64-bit precision, any created attributes will be 64-bit. When run in 32-bit any created attributes will be 32-bit. Use ", {"scheme": "Node", "value": "/nodes/sop/attribcast", "type": "link", "text": "", "fullpath": "/nodes/sop/attribcast"}, " to change the preferred precision."], "extent": [3227, 3535]}], "container": true, "attrs": {"id": "vex_precision"}, "role": "item"}], "container": true, "role": "item_group"}], "text": "Parameters"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [7179, 7188], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/volumemix", "type": "link", "text": "", "fullpath": "/nodes/sop/volumemix"}], "extent": [7188, 7212]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/volumevop", "type": "link", "text": "", "fullpath": "/nodes/sop/volumevop"}], "extent": [7212, 7235]}], "container": true}], "text": "Related"}], "title": ["Volume Wrangle"], "summary": ["Runs a VEX snippet to modify voxel values in a volume."], "included": ["/nodes/sop/attribvop", "/nodes/sop/pointwrangle", "/nodes/sop/wrangle_syntax", "/vex/_enforce_prototypes"]}