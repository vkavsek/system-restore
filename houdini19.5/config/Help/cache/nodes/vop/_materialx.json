{"type": "root", "attrs": {"type": "node", "context": "vop", "icon": "COMMON/materialx", "index": "no", "internal": "_materialx", "version": null, "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["MaterialX"], "extent": [0, 14]}, {"type": "summary", "indent": 0, "text": ["MaterialX VOP nodes let you build MaterialX shaders for use with the Karma renderer."], "extent": [76, 168]}, {"type": "para", "indent": 0, "text": ["For help with individual MaterialX nodes, see the official MaterialX documentation."], "extent": [168, 253]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": null, "value": "https://www.materialx.org/assets/MaterialX.v1.38.Spec.pdf", "type": "link", "text": ["Specification (PDF)"], "exists": true}], "extent": [253, 335], "body": [], "container": true, "attrs": {"glyph": "fa-file-pdf-o"}}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": null, "value": "http://www.materialx.org/assets/MaterialX.v1.38.PBRSpec.pdf", "type": "link", "text": ["Physically Based Shading Nodes (PDF)"], "exists": true}], "extent": [362, 463], "body": [], "container": true, "attrs": {"glyph": "fa-file-pdf-o"}}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": null, "value": "http://www.materialx.org/assets/MaterialX.v1.38.Supplement.pdf", "type": "link", "text": ["Supplemental Notes (PDF)"], "exists": true}], "extent": [490, 582], "body": [], "container": true, "attrs": {"glyph": "fa-file-pdf-o"}}], "container": true}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [610, 619], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": null, "value": "/solaris/materialx", "type": "link", "text": ["MaterialX in Houdini"], "fullpath": "/solaris/materialx"}], "extent": [619, 666]}], "container": true}], "text": "Related"}, {"level": 1, "id": "karma_unsupported_disney_brdf", "container": true, "type": "karma_unsupported_disney_brdf_section", "indent": 0, "role": "section", "extent": [666, 697], "body": [{"type": "warning_group", "body": [{"type": "warning", "indent": 0, "role": "item", "extent": [697, 706], "body": [{"type": "para", "indent": 4, "text": ["Not implemented by Karma. Use the ", {"scheme": "Node", "value": "/nodes/vop/principledshader", "type": "link", "text": ["Principled Shader"], "fullpath": "/nodes/vop/principledshader"}, " if you wish to use a Disney BRDF/BSDF and Karma."], "extent": [706, 841]}], "container": true}], "container": true, "role": "item_group"}], "text": "Karma_unsupported_disney_brdf"}, {"level": 1, "id": "karma_unsupported", "container": true, "type": "karma_unsupported_section", "indent": 0, "role": "section", "extent": [841, 860], "body": [{"type": "warning_group", "body": [{"type": "warning", "indent": 0, "role": "item", "extent": [860, 869], "body": [{"type": "para", "indent": 4, "text": ["Not supported by Karma."], "extent": [869, 899]}], "container": true}], "container": true, "role": "item_group"}], "text": "Karma_unsupported"}, {"level": 1, "id": "lama_unsupported", "container": true, "type": "lama_unsupported_section", "indent": 0, "role": "section", "extent": [899, 917], "body": [{"type": "warning_group", "body": [{"type": "warning", "indent": 0, "role": "item", "extent": [917, 926], "body": [{"tag": "div", "attrs": {"style": "position: relative;"}, "type": "xml", "text": ["\n    ", {"tag": "div", "attrs": {"style": "float: left; width: 5em;"}, "type": "xml", "text": ["\n        ", {"scheme": "Image", "value": "/images/beta.svg", "type": "link", "text": "", "fullpath": "/images/beta.svg"}, "\n    "]}, "\n    ", {"tag": "div", "attrs": {"style": "margin-left: 5em; padding-left: 1em; min-height: 4em;"}, "type": "xml", "text": ["\n        Lama MaterialX has begun to appear in MaterialX, but the open source implementation is not complete. The nodes have been hidden, to avoid confusion about expectations and workflow. Once the definitions are more complete, Lama support will be announced.\n    "]}, "\n    "]}], "container": true}], "container": true, "role": "item_group"}], "text": "Lama_unsupported"}, {"level": 1, "id": "mtlx_color4_merge", "container": true, "type": "mtlx_color4_merge_section", "indent": 0, "role": "section", "extent": [1412, 1431], "body": [{"type": "para", "indent": 0, "text": ["MaterialX Merge nodes take two Color4 inputs and use their built-in alpha channel(s) to control how the ", {"type": "code", "text": ["fg"]}, " and ", {"type": "code", "text": ["bg"]}, " inputs are combined. These merge nodes only apply to Color4 input types. They optionally support a ", {"type": "code", "text": ["mix"]}, " input Float. This allows for blending the original ", {"type": "code", "text": ["bg"]}, " (where ", {"type": "code", "text": ["mix"]}, " is 0) with the result of the operation (where ", {"type": "code", "text": ["mix"]}, " is 1)."], "extent": [1431, 1783]}, {"type": "table", "thead": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["Merge Operator "], "role": "th", "extent": [1783, 1801], "container": true}, {"type": "cell", "indent": 4, "text": ["RGB Result "], "role": "th", "extent": [1801, 1819], "container": true}, {"type": "cell", "indent": 8, "text": ["Alpha Result "], "role": "th", "extent": [1819, 1843]}], "divider": false}], "body": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["MtlX Disjointover "], "role": "td", "extent": [1843, 1863], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["F+B"]}, " if ", {"type": "code", "text": ["f+b<=1"]}, ", and\n    ", {"type": "code", "text": ["F+B(1-f)/b"]}, " if ", {"type": "code", "text": ["f+b>1"]}, " "], "role": "td", "extent": [1863, 1920], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": [{"type": "code", "text": ["min(f+b,1)"]}], "extent": [1920, 1945]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["MtlX In "], "role": "td", "extent": [1945, 1955], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["Fb"]}, " "], "role": "td", "extent": [1955, 1966], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": [{"type": "code", "text": ["fb"]}], "extent": [1966, 1979]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["MtlX Mask "], "role": "td", "extent": [1979, 1991], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["Bf"]}, " "], "role": "td", "extent": [1991, 2002], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": [{"type": "code", "text": ["bf"]}], "extent": [2002, 2015]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["MtlX Matte "], "role": "td", "extent": [2015, 2028], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["Ff+B(1-f)"]}, " "], "role": "td", "extent": [2028, 2046], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": [{"type": "code", "text": ["f+b(1-f)"]}], "extent": [2046, 2065]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["MtlX Out "], "role": "td", "extent": [2065, 2076], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["F(1-b) "]}, " "], "role": "td", "extent": [2076, 2092], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": [{"type": "code", "text": ["f(1-b)"]}], "extent": [2092, 2109]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["MtlX Over "], "role": "td", "extent": [2109, 2121], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["F+B(1-f)"]}, " "], "role": "td", "extent": [2121, 2138], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": [{"type": "code", "text": ["f+b(1-f)"]}], "extent": [2138, 2175]}]}], "divider": false}]}], "text": "Mtlx_color4_merge"}, {"level": 1, "id": "mtlx_blends", "container": true, "type": "mtlx_blends_section", "indent": 0, "role": "section", "extent": [2175, 2188], "body": [{"type": "para", "indent": 0, "text": ["MaterialX Blend nodes take two 1-4 Channel inputs and apply the same operation to all channels. The math for Alpha is the same as for R or RGB."], "extent": [2188, 2333]}, {"type": "para", "indent": 0, "text": ["In the Blend Operator tabel, ", {"type": "q", "text": ["F"]}, " and ", {"type": "q", "text": ["B"]}, " refer to any individual channel of the ", {"type": "code", "text": ["fg"]}, " and ", {"type": "code", "text": ["bg"]}, " inputs respectively. They optionally support a ", {"type": "code", "text": ["mix"]}, " input Float. This allows for blending the original ", {"type": "code", "text": ["bg"]}, " (where ", {"type": "code", "text": ["mix"]}, " is 0) with the result of the operation (where ", {"type": "code", "text": ["mix"]}, " is 1)."], "extent": [2333, 2610]}, {"type": "table", "thead": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["Blend Operator "], "role": "th", "extent": [2610, 2628], "container": true}, {"type": "cell", "indent": 4, "text": ["Result per Channel "], "role": "th", "extent": [2628, 2654]}], "divider": false}], "body": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["MtlX Plus "], "role": "td", "extent": [2654, 2666], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": [{"type": "code", "text": ["B+F "]}], "extent": [2666, 2677]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["MtlX Minus "], "role": "td", "extent": [2677, 2690], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": [{"type": "code", "text": ["B-F "]}], "extent": [2690, 2701]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["MtlX Difference "], "role": "td", "extent": [2701, 2719], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": [{"type": "code", "text": ["abs(B-F)"]}], "extent": [2719, 2734]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["MtlX Burn "], "role": "td", "extent": [2734, 2746], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": [{"type": "code", "text": ["1-(1-B)/F"]}], "extent": [2746, 2762]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["MtlX Dodge "], "role": "td", "extent": [2762, 2775], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": [{"type": "code", "text": ["B/(1-F) "]}], "extent": [2775, 2790]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["MtlX Screen "], "role": "td", "extent": [2790, 2804], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": [{"type": "code", "text": ["1-(1-F)(1-B) "]}], "extent": [2804, 2824]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["MtlX Overlay "], "role": "td", "extent": [2824, 2839], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": [{"type": "code", "text": ["2FB"]}, " if ", {"type": "code", "text": ["F<0.5"]}, ", and ", {"type": "code", "text": ["1-(1-F)(1-B)"]}, " if ", {"type": "code", "text": ["F>=0.5"]}], "extent": [2839, 2893]}]}], "divider": false}]}], "text": "Mtlx_blends"}, {"level": 1, "id": "mtlx_common_image_parms", "container": true, "type": "mtlx_common_image_parms_section", "indent": 0, "role": "section", "extent": [2893, 2918], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["File Name"], "extent": [2918, 2929], "body": [{"type": "para", "indent": 4, "text": ["The URI or path of an image file."], "extent": [2944, 2983]}, {"type": "warning_group", "body": [{"type": "warning", "indent": 4, "role": "item", "extent": [2983, 2996], "body": [{"type": "para", "indent": 8, "text": ["UsdMaterialX does not currently support the filename substitution tokens that MaterialX provides."], "extent": [2996, 3103]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "file"}}, {"type": "dt", "indent": 0, "text": ["Default"], "extent": [3103, 3112], "body": [{"type": "para", "indent": 4, "text": ["A default value to use if the given ", {"type": "ui", "text": ["file"]}, " can not be resolved, or if the specified ", {"type": "ui", "text": ["layer"]}, " does not exist in the file. The default value must be the same type as the ", {"type": "em", "text": ["image"]}, " element itself, and must be a constant color (i.e. it cannot be a varying primvar or some other pattern or image)."], "extent": [3130, 3429]}, {"type": "para", "indent": 4, "text": ["If default is not defined, the default color value will be 0.0 in all channels."], "extent": [3429, 3514]}], "container": true, "attrs": {"id": "default"}}, {"type": "dt", "indent": 0, "text": ["Texture Coordinate"], "extent": [3514, 3534], "body": [{"type": "para", "indent": 4, "text": ["The name of a vector2-type node specifying the 2D texture coordinate at which the image data is read. Default is to use the current u,v coordinate."], "extent": [3557, 3710]}], "container": true, "attrs": {"id": "texcoord"}}, {"type": "dt", "indent": 0, "text": ["UV Address Mode"], "extent": [3710, 3727], "body": [{"type": "para", "indent": 4, "text": ["Determines how UV coordinates outside the 0-1 range are processed before sampling the image. Each UV component can be set independently to one of these modes:"], "extent": [3751, 3915]}, {"type": "para", "indent": 4, "text": [{"scheme": "Image", "value": "/images/nodes/vop/mtlx_uvaddress_modes.jpg", "type": "img", "text": ""}], "extent": [3915, 3971]}, {"type": "table", "thead": [], "body": [{"type": "row", "body": [{"type": "cell", "indent": 4, "text": [{"type": "em", "text": ["Constant"]}, " "], "role": "td", "extent": [3971, 3988], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Texture coordinates outside the 0-1 range return the value of the node\u2019s ", {"type": "em", "text": ["default"]}, " color or float parameter."], "extent": [3988, 4105]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 4, "text": [{"type": "em", "text": ["Clamp"]}, " "], "role": "td", "extent": [4105, 4119], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Texture coordinates are clamped to the 0-1 range before sampling the image."], "extent": [4119, 4203]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 4, "text": [{"type": "em", "text": ["Periodic"]}, " "], "role": "td", "extent": [4203, 4220], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Texture coordinates outside the 0-1 range ", {"type": "q", "text": ["wrap around"]}, ", effectively being processed by a modulo 1 operation before sampling the image."], "extent": [4220, 4364]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 4, "text": [{"type": "em", "text": ["Mirror"]}, " "], "role": "td", "extent": [4364, 4379], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Texture coordinates outside the 0-1 range will be mirrored back into the 0-1 range, e.g. u=-0.01 will return the u=0.01 texture coordinate value, and u=1.01 will return the u=0.99 texture coordinate value."], "extent": [4379, 4594]}]}], "divider": false}]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["U Address Mode"], "extent": [4594, 4614], "body": [{"type": "para", "indent": 8, "text": ["Determines how U coordinates outside the 0-1 range are processed before sampling the image. Default is ", {"type": "em", "text": ["periodic"]}, "."], "extent": [4641, 4765]}], "container": true, "attrs": {"id": "uaddressmode"}}, {"type": "dt", "indent": 4, "text": ["V Address Mode"], "extent": [4765, 4785], "body": [{"type": "para", "indent": 8, "text": ["Determines how V coordinates outside the 0-1 range are processed before sampling the image. Default is ", {"type": "em", "text": ["periodic"]}, "."], "extent": [4812, 4936]}], "container": true, "attrs": {"id": "vaddressmode"}}], "container": true}], "container": true, "attrs": {"id": "uvaddressmode"}}, {"type": "dt", "indent": 0, "text": ["Filter Type"], "extent": [4936, 4949], "body": [{"type": "para", "indent": 4, "text": ["The type of texture filtering to use; standard values include 'closest' (nearest-neighbor single-sample), 'linear', and 'cubic'.  If not specified, an application may use its own default texture filtering method."], "extent": [4974, 5192]}], "container": true, "attrs": {"id": "filtertype"}}, {"type": "dt", "indent": 0, "text": ["Frame Range"], "extent": [5192, 5205], "body": [{"type": "para", "indent": 4, "text": ["A string 'minframe-maxframe', e.g. '10-99', to specify the range of frames that the image file is allowed to have, usually the range of image files on disk.  Default is unbounded"], "extent": [5230, 5414]}], "container": true, "attrs": {"id": "framerange"}}, {"type": "dt", "indent": 0, "text": ["Frame Offset"], "extent": [5414, 5428], "body": [{"type": "para", "indent": 4, "text": ["A number that is added to the current frame number to get the image file frame number.  E.g. if frameoffset is 25, then processing frame 100 will result in reading frame 125 from the imagefile sequence.  Default is no frame offset."], "extent": [5454, 5691]}], "container": true, "attrs": {"id": "frameoffset"}}, {"type": "dt", "indent": 0, "text": ["Frame End Action"], "extent": [5691, 5709], "body": [{"type": "para", "indent": 4, "text": ["What to do when the resolved image frame number is outside the framerange range."], "extent": [5738, 5822]}], "container": true, "attrs": {"id": "frameendaction"}}], "container": true}], "text": "Mtlx_common_image_parms"}], "title": ["MaterialX"], "summary": ["MaterialX VOP nodes let you build MaterialX shaders for use with the Karma renderer."]}