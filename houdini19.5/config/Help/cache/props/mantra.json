{"type": "root", "attrs": {"type": "properties"}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Mantra rendering properties"], "extent": [0, 32]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Overview"], "extent": [52, 67], "body": [{"type": "para", "indent": 0, "text": ["These properties control rendering in mantra. They are in the ", {"type": "code", "text": ["mantra"]}, " folder in the list of properties available under the ", {"type": "ui", "text": ["Render Properties"]}, " tab of the ", {"scheme": null, "value": "/ref/windows/edit_parameter_interface", "type": "link", "text": ["Edit parameter interface window"], "fullpath": "/ref/windows/edit_parameter_interface"}, ". Select a node, and in the parameter editor click the ", {"scheme": "Smallicon", "value": "BUTTONS/gear", "type": "link", "text": "", "fullpath": "/props/BUTTONS/gear"}, " Gear menu and choose ", {"type": "ui", "text": ["Edit rendering properties"]}, " to add or remove properties to a render driver, camera, object, shader, or properties node."], "extent": [67, 520]}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [520, 526], "body": [{"type": "para", "indent": 4, "text": ["All command line options to mantra (except ", {"type": "code", "text": ["-H"]}, " and ", {"type": "code", "text": ["-P"]}, ") now have property equivalents, so you can add them to the driver node instead of specifying them on the command line."], "extent": [526, 707]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 0, "text": ["For advanced users, to get a complete list of all properties defined in mantra (including undocumented properties), you can run the ", {"type": "code", "text": ["ray_show"]}, " command in mantra.  For example:"], "extent": [707, 884]}, {"lang": "sh", "type": "pre", "indent": 0, "text": ["\necho ray_show object | mantra\necho ray_show renderer | mantra\n"], "extent": [884, 959]}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [959, 966], "body": [{"type": "para", "indent": 4, "text": ["Mantra reads default values from the ", {"type": "code", "text": ["RenderProperties.json"]}, " file at startup (unless the ", {"type": "code", "text": ["-D"]}, " option is specified).  This can let studios change mantra\u2019s default values for properties."], "extent": [966, 1156]}], "container": true}], "container": true, "role": "item_group"}, {"type": "warning_group", "body": [{"type": "warning", "indent": 0, "role": "item", "extent": [1156, 1165], "body": [{"type": "para", "indent": 4, "text": ["Any undocumented properties may change at any time and may not be fully supported."], "extent": [1165, 1254]}], "container": true}], "container": true, "role": "item_group"}]}, {"level": 1, "id": "properties", "container": true, "type": "properties_section", "indent": 0, "role": "section", "extent": [1254, 1266], "body": [{"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Deep Output"], "extent": [1266, 1285], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Deep Resolver"], "role": "item", "extent": [1285, 1303], "body": [{"type": "para", "indent": 4, "text": ["When generating an image, mantra runs the sample filter to composite samples to a single color. Mantra then runs the pixel filter to produce the final color for a pixel. A deep resolver is used to store information about each sample prior to sample filtering. This allows the image resolver to store information about each individual sample before compositing. "], "extent": [1369, 1740]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["No Deep Resolver"], "extent": [1740, 1763], "body": [{"type": "para", "indent": 8, "text": ["Deep image will not be output."], "extent": [1763, 1807]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Deep Shadow Map"], "extent": [1807, 1828], "body": [{"type": "para", "indent": 8, "text": ["Only the opacity (", {"type": "code", "text": ["Of"]}, ") and depth (", {"type": "code", "text": ["Pz"]}, ") image planes will be written out."], "extent": [1828, 1916]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Deep Camera Map"], "extent": [1916, 1937], "body": [{"type": "para", "indent": 8, "text": ["All planes selected for deep images will be written out. Use ", {"type": "ui", "text": ["Exclude from DCM"]}, " to leave a specific image plane from the deep image output."], "extent": [1937, 2088]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_deepresolver", "ifdprop": "image:deepresolver"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["DCM Filename"], "role": "item", "extent": [2088, 2104], "body": [{"type": "para", "indent": 4, "text": ["The file to generate when the Deep Camera Map resolver is used."], "extent": [2131, 2204]}], "container": true, "attrs": {"hprop": "vm_dcmfilename"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["DCM Interpolation"], "role": "item", "extent": [2204, 2225], "body": [{"type": "para", "indent": 4, "text": ["Deprecated in Houdini 14.5. Specifies how each pixel sample should be interpreted. Unlike some other deep image formats, mantra only writes out a single depth value for each sample."], "extent": [2255, 2446]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["discrete"]}], "extent": [2446, 2462], "body": [{"type": "para", "indent": 8, "text": ["Each depth sample represents a discrete surface."], "extent": [2462, 2519]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["continuous"]}], "extent": [2519, 2537], "body": [{"type": "para", "indent": 8, "text": ["Each depth sample is part of a continuum (i.e. volume)."], "extent": [2537, 2602]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_dcmdepthinterp"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["DCM Compression"], "role": "item", "extent": [2602, 2621], "body": [{"type": "para", "indent": 4, "text": ["Compression value between 0 and 10. Used to limit the number of samples which are stored in a lossy compression mode for volume samples.  The compression parameter applies to opacity values, and determines the maximum possible error in opacity for each sample.  For compression greater than 0, the following relationship holds: ", {"type": "code", "text": ["OfError = 1/(2^(10-compression))"]}], "extent": [2651, 3027]}], "container": true, "attrs": {"hprop": "vm_dcmcompression"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["DCM Pre-Composite Samples"], "role": "item", "extent": [3027, 3056], "body": [{"type": "para", "indent": 4, "text": ["The samples stored in the deep file can be stored as either uncomposited, meaning that each sample is independent of any other sample for the same pixel; or it can be stored pre-composited, meaning that each sample stores the accumulated opacity of the sample behind it and the opacity of the sample itself."], "extent": [3086, 3399]}], "container": true, "attrs": {"hprop": "vm_dcmcompositing"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Force DCM Pixel Filter on Image Planes"], "role": "item", "extent": [3399, 3441], "body": [{"type": "para", "indent": 4, "text": ["When rendering DCM, force regular/non-deep image planes to have the same pixel filtering as DCM\u2019s (i.e. Unit Box filter)."], "extent": [3519, 3650]}], "container": true, "attrs": {"hprop": "vm_matchdeeppixelfilter", "ifdprop": "image:matchdeeppixelfilter"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["DCM Of Storage"], "role": "item", "extent": [3650, 3668], "body": [{"type": "para", "indent": 4, "text": ["Specifies the amount of bits to use to store opacity samples. The default is 16 bits. Larger values may cause the file size to increase substantially, with little gain in fidelty."], "extent": [3696, 3889]}], "container": true, "attrs": {"hprop": "vm_dcmofstorage"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["DCM Z Storage"], "role": "item", "extent": [3889, 3906], "body": [{"type": "para", "indent": 4, "text": ["Specifies the amount of bits to use to store opacity samples. The default is 32 bits. Smaller values may cause unnecessary discretization of samples of sample far away from the camera, but can save substantially on file size."], "extent": [3934, 4169]}], "container": true, "attrs": {"hprop": "vm_dcmpzstorage"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["DCM Z-Bias"], "role": "item", "extent": [4169, 4183], "body": [{"type": "para", "indent": 4, "text": ["Used in compression to merge together samples which are closer than the given threshold. Samples that are closer together than this bias value, are merged into a single sample and stored at the average z value of all the merged samples."], "extent": [4207, 4453]}], "container": true, "attrs": {"hprop": "vm_dcmzbias"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["DCM Of Size"], "role": "item", "extent": [4453, 4468], "body": [{"type": "para", "indent": 4, "text": ["Opacity is usually computed as a full-color value and stored as such. To cut down on file size, if full color is not needed, this settings can be used to store a monochromatic version of the full color value."], "extent": [4493, 4711]}, {"type": "para", "indent": 4, "text": [{"type": "code", "text": ["Monochrome"]}, ":\n    The opacity is stored as a single, grayscale channel.0\n    ", {"type": "code", "text": ["Full Color"]}, ":\n    The opacity is stored with full red, green and blue separation."], "extent": [4711, 4879]}], "container": true, "attrs": {"hprop": "vm_dcmofsize"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["DCM Z-Sample Filter"], "role": "item", "extent": [4879, 4902], "body": [{"type": "para", "indent": 4, "text": ["Deprecated in Houdini 14.5. Used in compression to determine whether to keep the nearest, the farthest or the midpoint of samples."], "extent": [4930, 5070]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Nearest sample"], "extent": [5070, 5090], "body": [{"type": "para", "indent": 8, "text": ["Choose the smallest ", {"type": "code", "text": ["Pz"]}, " value."], "extent": [5090, 5139]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Midpoint sampling"], "extent": [5139, 5162], "body": [{"type": "para", "indent": 8, "text": ["Choose the midpoint of ", {"type": "code", "text": ["Pz"]}, " values."], "extent": [5162, 5215]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Farthest sample"], "extent": [5215, 5237], "body": [{"type": "para", "indent": 8, "text": ["Choose the largest ", {"type": "code", "text": ["Pz"]}, " value."], "extent": [5237, 5277]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_dcmdepthmode"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["DCM Special Planes"], "role": "item", "extent": [5277, 5299], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Deep camera images can contain several ", {"type": "q", "text": ["special"]}, " image planes.  These can be used to improve compositing of deep images.  The special planes currently recognized are:\n    ", {"type": "code", "text": ["zfront"]}], "extent": [5330, 5515], "body": [{"type": "para", "indent": 8, "text": ["The z value of the depth sample."], "extent": [5515, 5556]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["zback"]}], "extent": [5556, 5569], "body": [{"type": "para", "indent": 8, "text": ["For volume samples, this specifies the farthest extent of the sample."], "extent": [5569, 5647]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["deepcover"]}], "extent": [5647, 5664], "body": [{"type": "para", "indent": 8, "text": ["Store sample coverage as a bit mask."], "extent": [5664, 5709]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["deepflags"]}], "extent": [5709, 5726], "body": [{"type": "para", "indent": 8, "text": ["Store flags indicating whether the shading sample is a volume or a matte surface."], "extent": [5726, 5817]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_dcmdepthplanes"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["DCM Create MIP Maps"], "role": "item", "extent": [5817, 5840], "body": [{"type": "para", "indent": 4, "text": ["Whether to create MIP mapped images for deep camera images."], "extent": [5867, 5932]}, {"type": "para", "indent": 4, "text": ["By default, MIP maps are not created for deep camera images, since deep camera images tend to be used for deep compositing (which doesn\u2019t require MIP maps)."], "extent": [5932, 6094]}], "container": true, "attrs": {"hprop": "vm_dcmmipmaps"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["DSM Filename"], "role": "item", "extent": [6094, 6110], "body": [{"type": "para", "indent": 4, "text": ["See ", {"scheme": null, "value": "#vm_dcmfilename", "type": "link", "text": ["DCM Filename"], "fullpath": "/props/mantra#vm_dcmfilename", "fragment": "#vm_dcmfilename"}, " for details."], "extent": [6137, 6190]}], "container": true, "attrs": {"hprop": "vm_dsmfilename"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["DSM Interpolation"], "role": "item", "extent": [6190, 6211], "body": [{"type": "para", "indent": 4, "text": ["See ", {"scheme": null, "value": "#vm_dcmdepthinterp", "type": "link", "text": ["DCM Interpolation"], "fullpath": "/props/mantra#vm_dcmdepthinterp", "fragment": "#vm_dcmdepthinterp"}, " for details."], "extent": [6241, 6302]}], "container": true, "attrs": {"hprop": "vm_dsmdepthinterp"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["DSM Compression"], "role": "item", "extent": [6302, 6321], "body": [{"type": "para", "indent": 4, "text": ["See ", {"scheme": null, "value": "#vm_dcmcompression", "type": "link", "text": ["DCM Compression"], "fullpath": "/props/mantra#vm_dcmcompression", "fragment": "#vm_dcmcompression"}, " for details."], "extent": [6351, 6410]}], "container": true, "attrs": {"hprop": "vm_dsmcompression"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["DSM Pre-Composite Samples"], "role": "item", "extent": [6410, 6439], "body": [{"type": "para", "indent": 4, "text": ["See ", {"scheme": null, "value": "#vm_dcmcompositing", "type": "link", "text": ["DCM Pre-Composite Samples"], "fullpath": "/props/mantra#vm_dcmcompositing", "fragment": "#vm_dcmcompositing"}, " for details."], "extent": [6469, 6538]}, {"type": "para", "indent": 4, "text": ["Mantra expects deep shadow images to be pre-composited.\n    If you use un-composited shadow maps, rendering may be slower or\n    generate bad results."], "extent": [6538, 6694]}], "container": true, "attrs": {"hprop": "vm_dsmcompositing"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["DSM Of Storage"], "role": "item", "extent": [6694, 6712], "body": [{"type": "para", "indent": 4, "text": ["See ", {"scheme": null, "value": "#vm_dcmofstorage", "type": "link", "text": ["DCM Of Storage"], "fullpath": "/props/mantra#vm_dcmofstorage", "fragment": "#vm_dcmofstorage"}, " for details."], "extent": [6740, 6800]}], "container": true, "attrs": {"hprop": "vm_dsmofstorage"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["DSM Z Storage"], "role": "item", "extent": [6800, 6817], "body": [{"type": "para", "indent": 4, "text": ["See ", {"scheme": null, "value": "#vm_dcmpzstorage", "type": "link", "text": ["DCM Z Storage"], "fullpath": "/props/mantra#vm_dcmpzstorage", "fragment": "#vm_dcmpzstorage"}, " for details."], "extent": [6845, 6900]}], "container": true, "attrs": {"hprop": "vm_dsmpzstorage"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["DSM Z-Bias"], "role": "item", "extent": [6900, 6914], "body": [{"type": "para", "indent": 4, "text": ["See ", {"scheme": null, "value": "#vm_dcmzbias", "type": "link", "text": ["DCM Z-Bias"], "fullpath": "/props/mantra#vm_dcmzbias", "fragment": "#vm_dcmzbias"}, " for details."], "extent": [6938, 6986]}], "container": true, "attrs": {"hprop": "vm_dsmzbias"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["DSM Of Size"], "role": "item", "extent": [6986, 7001], "body": [{"type": "para", "indent": 4, "text": ["See ", {"scheme": null, "value": "#vm_dcmofsize", "type": "link", "text": ["DCM Of Size"], "fullpath": "/props/mantra#vm_dcmofsize", "fragment": "#vm_dcmofsize"}, " for details."], "extent": [7026, 7080]}], "container": true, "attrs": {"hprop": "vm_dsmofsize"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["DSM Z-Sample Filter"], "role": "item", "extent": [7080, 7103], "body": [{"type": "para", "indent": 4, "text": ["See ", {"scheme": null, "value": "#vm_dcmdepthmode", "type": "link", "text": ["DCM Z-Sample Filter"], "fullpath": "/props/mantra#vm_dcmdepthmode", "fragment": "#vm_dcmdepthmode"}, " for details."], "extent": [7131, 7192]}], "container": true, "attrs": {"hprop": "vm_dsmdepthmode"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["DSM Special Planes"], "role": "item", "extent": [7192, 7214], "body": [{"type": "para", "indent": 4, "text": ["Deep shadow images can contain several ", {"type": "q", "text": ["special"]}, " image planes.  These can be used to improve compositing of deep images.  The special planes currently recognized are:"], "extent": [7245, 7421]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["zfront"]}], "extent": [7421, 7435], "body": [{"type": "para", "indent": 8, "text": ["The z value of the depth sample."], "extent": [7435, 7485]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["zback"]}], "extent": [7485, 7498], "body": [{"type": "para", "indent": 8, "text": ["For volume samples, this specifies the farthest extent of the sample."], "extent": [7498, 7585]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["deepcover"]}], "extent": [7585, 7602], "body": [{"type": "para", "indent": 8, "text": ["Store sample coverage as a bit mask."], "extent": [7602, 7656]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["deepflags"]}], "extent": [7656, 7673], "body": [{"type": "para", "indent": 8, "text": ["Store flags indicating whether the shading sample is a volume or a matte surface."], "extent": [7673, 7768]}], "container": true}], "container": true}, {"type": "para", "indent": 4, "text": ["These special channels are discussed in: ", {"scheme": null, "value": "http://research.dreamworks.com/papers/Improved_Deep_Compositing_DWA_2015.pdf", "type": "link", "text": ["Improved Deep Compositing"], "exists": true}], "extent": [7768, 7919]}], "container": true, "attrs": {"hprop": "vm_dsmdepthplanes"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["DSM Create MIP Maps"], "role": "item", "extent": [7919, 7942], "body": [{"type": "para", "indent": 4, "text": ["Whether to create MIP mapped images for deep shadow images."], "extent": [7969, 8034]}, {"type": "para", "indent": 4, "text": ["By default, MIP maps are created for deep shadow images, since shadow evaluation can make use of MIP maps for filtering."], "extent": [8034, 8160]}], "container": true, "attrs": {"hprop": "vm_dsmmipmaps"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Cryptomatte"], "extent": [8160, 8178], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Cryptomatte Layers"], "role": "item", "extent": [8178, 8201], "body": [{"type": "para", "indent": 4, "text": ["The number of cryptomatte layers to output. This must be set to 1 or higher to enable the cryptomatte resolver. The cryptomatte resolver is used to store the ID (based on hash of user-specified string property) and opacity pair of each sample prior to sample filtering."], "extent": [8234, 8509]}], "container": true, "attrs": {"hprop": "vm_cryptolayers"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Property"], "role": "item", "extent": [8509, 8521], "body": [{"type": "para", "indent": 4, "text": ["Property to generate IDs from. ", {"type": "code", "text": ["materialname"]}, " and ", {"type": "code", "text": ["name"]}, " are built-in property names for material path and object path respectively. It can also be any object property of string type, including user property."], "extent": [8557, 8771]}], "container": true, "attrs": {"hprop": "vm_cryptolayerprop"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Channel Name"], "role": "item", "extent": [8771, 8787], "body": [{"type": "para", "indent": 4, "text": ["Channel name used to store current layer."], "extent": [8823, 8870]}], "container": true, "attrs": {"hprop": "vm_cryptolayername"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Overlap limit"], "role": "item", "extent": [8870, 8887], "body": [{"type": "para", "indent": 4, "text": ["Maximum number of IDs that can be stored in a single pixel. A value of 6 is recommended."], "extent": [8923, 9017]}], "container": true, "attrs": {"hprop": "vm_cryptolayerrank"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Different File"], "role": "item", "extent": [9017, 9035], "body": [{"type": "para", "indent": 4, "text": ["Output path of the cryptomatte layer. OpenEXR format recommended. If this path is not specified, then this layer will be stored along with primary output. It\u2019s also possible to have multiple layers with identical ", {"type": "ui", "text": ["Different File"]}, " path to write a cryptomatte image with multiple layers, but ", {"type": "ui", "text": ["Channel Name"]}, " should be unique to avoid confusion (a temporary channel name will be generated if more than one layer tries to write to same file with identical channel name)."], "extent": [9073, 9548]}], "container": true, "attrs": {"hprop": "vm_cryptolayeroutput"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Manifest File"], "role": "item", "extent": [9548, 9565], "body": [{"type": "para", "indent": 4, "text": ["Optional external manifest file. It will be saved into same directory as the ", {"type": "ui", "text": ["Output Picture"]}, ". If this path is unspecified, the manifest will be embedded into ", {"type": "ui", "text": ["Output Picture"]}, " as metadata."], "extent": [9604, 9806]}], "container": true, "attrs": {"hprop": "vm_cryptolayersidecar"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Dicing"], "extent": [9806, 9819], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Shading quality multiplier"], "role": "item", "extent": [9819, 9850], "body": [{"type": "para", "indent": 4, "text": ["A global multiplier on all per-object ", {"scheme": null, "value": "/props/mantra#vm_shadingquality", "type": "link", "text": ["shading quality"], "fullpath": "/props/mantra#vm_shadingquality", "fragment": "#vm_shadingquality"}, " (", {"type": "code", "text": ["vm_shadingquality"]}, ") parameters in the scene.  This parameter can be used to globally increase or decrease shading quality.  The shading quality used for an object is determined by\u2026"], "extent": [9917, 10199]}, {"lang": null, "type": "pre", "indent": 4, "text": ["\n    shadingquality = object:shadingquality * renderer:shadingfactor\n    "], "extent": [10199, 10283]}], "container": true, "attrs": {"hprop": "vm_shadingfactor", "ifdprop": "renderer:shadingfactor"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Shading quality"], "role": "item", "extent": [10283, 10303], "body": [{"type": "para", "indent": 4, "text": ["This parameter controls the geometric subdivision resolution for all rendering engines and additionally controls the shading resolution for micropolygon rendering.  With all other parameters at their defaults, a value of 1 means that approximately 1 micropolygon will be created per pixel.  A higher value will generate smaller micropolygons meaning that more shading will occur - but the quality will be higher."], "extent": [10374, 10792]}, {"type": "para", "indent": 4, "text": ["In ray tracing engines, shading quality only affects the geometric subdivision quality for smooth surfaces (NURBS, render as subdivision) and for displacements - without changing the amount of surface shading.  When using ray tracing, pixel samples and ray sampling parameters must be used to improve surface shading quality."], "extent": [10792, 11123]}, {"type": "para", "indent": 4, "text": ["The effect of changing the shading quality is to increase or decrease the amount of shading by a factor of ", {"type": "code", "text": ["vm_shadingquality"]}, " ", {"type": "strong", "text": ["squared"]}, " - so a shading quality of 2 will perform 4 times as much shading and a shading quality of 0.5 will perform 1/4 times as much shading."], "extent": [11123, 11399]}], "container": true, "attrs": {"hprop": "vm_shadingquality", "ifdprop": "object:shadingquality"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Shade curves as surfaces"], "role": "item", "extent": [11399, 11427], "body": [{"type": "para", "indent": 4, "text": ["When rendering a curve, turns the curve into a surface and dices the surface, running the surface shader on multiple points across the surface. This may be useful when the curves become curved surfaces, but is less efficient. The default is to simply run the shader on the points of the curve and duplicate those shaded points across the created surface."], "extent": [11494, 11854]}], "container": true, "attrs": {"hprop": "vm_curvesurface", "ifdprop": "object:curvesurface"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Motion factor"], "role": "item", "extent": [11854, 11871], "body": [{"type": "para", "indent": 4, "text": ["Fast moving objects which have significant amounts of motion blur are rendered with the same sampling quality as slow moving or static objects. However, in cases where objects are very blurry, small details are usually lost. In these cases, it is a useful optimization to reduce the shading quality on those objects which are moving quickly since the loss in detail is hidden in the motion blur."], "extent": [11934, 12335]}, {"type": "para", "indent": 4, "text": ["Increasing the Motion Factor will dynamically reduce the shading quality of an object based on the rate of motion. This optimization is primarily useful for objects which are refined at render time like subdivision surfaces or objects with displacement-based shading."], "extent": [12335, 12608]}, {"type": "para", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/blur/MotionFactorSimple.jpg", "type": "img", "text": ""}], "extent": [12608, 12668]}, {"type": "para", "indent": 4, "text": ["In the above example, you can see that the motion factor does not have a large impact on the quality of the final render."], "extent": [12668, 12795]}, {"type": "para", "indent": 4, "text": ["However, sometimes too much detail can be lost, especially in cases where much of the surface detail is generated by the shader. Objects whose shape is derived through significant amounts of displacement, for example."], "extent": [12795, 13018]}, {"type": "para", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/blur/MotionFactorComplex.jpg", "type": "img", "text": ""}], "extent": [13018, 13079]}, {"type": "para", "indent": 4, "text": ["In these cases, the Motion Factor value must be adjusted carefully to retain a believable amount of surface detail."], "extent": [13079, 13200]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [13200, 13210], "body": [{"type": "para", "indent": 8, "text": ["The exact motion factor used will depend on the degree of motion in your scene. For more information, see ", {"scheme": null, "value": "/props/mantra", "type": "link", "text": ["Motion factor"], "fullpath": "/props/mantra"}, " on the mantra rendering properties page."], "extent": [13210, 13396]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 4, "text": ["Automatically adjusts the shading quality for objects which are significantly blurred. Increasing the motion factor of an object will dynamically decrease the shading quality based on the rate of motion. This can significantly speed up renderings of rapid moving objects. It also affects depth of field and may improve speed of scenes with deep depth of focus."], "extent": [13396, 13762]}, {"type": "para", "indent": 4, "text": ["Motion factor reduces shading quality using the following formula:"], "extent": [13762, 13834]}, {"lang": null, "type": "pre", "indent": 4, "text": ["\n    new_shading_quality = shading_quality / max(motion_factor * pixels_of_motion/16, 1)\n    "], "extent": [13834, 13938]}, {"type": "para", "indent": 4, "text": ["This is only true if ", {"type": "code", "text": ["motion_factor > 0"]}, "."], "extent": [13938, 13998]}, {"type": "para", "indent": 4, "text": ["Objects traveling more than 16 pixels within the frame will have their shading quality reduced by the above factor. For example, an object blurred over 32 pixels with a shading quality of 1 will have the quality reduced to 0.5. You should not use very large values for this parameter. Values between 0 and 1 are reasonable."], "extent": [13998, 14327]}, {"type": "para", "indent": 4, "text": ["When using the Ray Tracing or Physically Based Rendering rendering engine, motion factor will only affect the geometric subdivision for subdivision surfaces, NURBS/Beziers, or displacements and will not change the amount of shading."], "extent": [14327, 14569]}], "container": true, "attrs": {"hprop": "vm_motionfactor", "ifdprop": "object:motionfactor"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Geometry measuring"], "role": "item", "extent": [14569, 14591], "body": [{"type": "para", "indent": 4, "text": ["When primitives are rendered in mantra, they are split into smaller primitives if they are too big to be rendered. The primitives are measured to determine if they are too big using the measurer."], "extent": [14648, 14853]}, {"type": "para", "indent": 4, "text": ["There are several different measurers available, each which take some optional arguments."], "extent": [14853, 14952]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Non-Raster Measuring (", {"type": "code", "text": ["nonraster [-z importance]"]}, ")"], "extent": [14952, 15008], "body": [{"type": "para", "indent": 8, "text": ["This measures geometry in 3D. The ", {"type": "ui", "text": ["Z-Importance"]}, " can be used to bias the z-component of the surface. A ", {"type": "ui", "text": ["Z-Importance"]}, " of 0 means that the x and y components of the object will be the only metric in determining the size of the object. This is roughly equivalent to raster space measurement."], "extent": [15008, 15311]}, {"type": "para", "indent": 8, "text": ["By increasing the ", {"type": "ui", "text": ["Z-Importance"]}, " to 1, the z measurement becomes more meaningful. It is possible to increase the ", {"type": "ui", "text": ["Z-Importance"]}, " beyond 1."], "extent": [15311, 15462]}, {"type": "para", "indent": 8, "text": ["If you think of a grid in the XY plane, the z-importance has no effect. However, if the grid is nearly in the XZ plane, z-importance has more influence on the dicing. With a ", {"type": "ui", "text": ["Z-Importance"]}, " of 0, only the projected measurements will be used, which will result in long, thin strips being created. With a ", {"type": "ui", "text": ["Z-Importance"]}, " of 1, the grid will be more uniformly sub-divided. With a value greater than 1, more divisions will be performed in Z."], "extent": [15462, 15911]}, {"type": "para", "indent": 8, "text": ["This is important when displacement mapping is being performed. Increasing the ", {"type": "ui", "text": ["Z-Importance"]}, " will improve quality on displacement shaded ground planes (for example). The default value of 1 generally will result in sharp, high quality displacements at a shading quality of 1 for all incident angles."], "extent": [15911, 16222]}, {"type": "para", "indent": 8, "text": ["This is mantra\u2019s equivalent to prman\u2019s ", {"type": "code", "text": ["raster-orient"]}, " flag."], "extent": [16222, 16292]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Raster Space Measuring (", {"type": "code", "text": ["raster"]}, ")"], "extent": [16292, 16331], "body": [{"type": "para", "indent": 8, "text": ["Measures geometry in screen space. This is roughly equivalent to the ", {"type": "code", "text": ["\"nonraster -z 0\""]}, " measurer, so is deprecated in favor of that approach."], "extent": [16331, 16482]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Uniform Measuring (", {"type": "code", "text": ["uniform"]}, ")"], "extent": [16482, 16517], "body": [{"type": "para", "indent": 8, "text": ["Generates uniform divisions. The size of the divisions is controlled by the ", {"type": "ui", "text": ["Geometry Quality"]}, " or ", {"type": "ui", "text": ["Shading Quality"]}, " in micropolygon renders."], "extent": [16517, 16671]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_measure", "ifdprop": "object:measure"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Z-importance"], "role": "item", "extent": [16671, 16687], "body": [{"type": "para", "indent": 4, "text": ["This parameter controls the z-importance for nonraster measuring.  See ", {"type": "code", "text": ["vm_measure"]}, " above."], "extent": [16756, 16852]}], "container": true, "attrs": {"hprop": "vm_measurezimportance", "ifdprop": "measure:zimportance"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Offscreen Quality"], "role": "item", "extent": [16852, 16873], "body": [{"type": "para", "indent": 4, "text": ["This parameter controls the shading quality scale factor for geometry that is not directly visible to the camera. For geometry that is outside the field of view (ie. visible only to secondary rays), mantra will smoothly reduce the shading quality based on the angle between the geometry and the edge of the viewing frustum.  Smaller values can increase performance particularly in scenes where the camera is within the displacement bound of nearby geometry, where it permits the hidden primitives to be diced more coarsely than those that are directly visible."], "extent": [16952, 17518]}], "container": true, "attrs": {"hprop": "vm_measureoffscreenquality", "ifdprop": "measure:offscreenquality"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Geometry Filter Width"], "role": "item", "extent": [17518, 17543], "body": [{"type": "para", "indent": 4, "text": ["This parameter sets a minimum rendering width, in raster space, for curves and points. \n    Any point, or curve segment, smaller than this value, at the projected point, will \n    instead have its opacity scaled down as a ratio of the minimum width and\n    the actual width. This helps rendering very small points and thin curves, \n    such as hair and fur, without having to adversely increase the pixel samples to \n    compensate."], "extent": [17614, 18056]}, {"type": "para", "indent": 4, "text": ["This value should be kept at around 0.5 to 1.0. Larger values may significantly \n    increase render time, since the geometry is wider and more transparent samples \n    may be taken. A value of 0 disables the option."], "extent": [18056, 18282]}, {"type": "para", "indent": 4, "text": ["This option can be used in conjunction with ", {"scheme": null, "value": "#vm_transparent", "type": "link", "text": ["Stochastic Transparency"], "fullpath": "/props/mantra#vm_transparent", "fragment": "#vm_transparent"}, "\n    for additional performance."], "extent": [18282, 18405]}], "container": true, "attrs": {"hprop": "vm_geofilterwidth", "ifdprop": "object:geofilterwidth"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Dicing flatness"], "role": "item", "extent": [18405, 18424], "body": [{"type": "para", "indent": 4, "text": ["This property controls the tesselation levels for nearly flat primitives. By increasing the value, more primitives will be considered flat and will be sub-divided less. Turn this option ", {"type": "em", "text": ["down"]}, " for more accurate (less optimized) nearly-flat surfaces."], "extent": [18479, 18734]}], "container": true, "attrs": {"hprop": "vm_flatness", "ifdprop": "object:flatness"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Ray predicing"], "role": "item", "extent": [18734, 18751], "body": [{"type": "para", "indent": 4, "text": ["This property will cause this object to generate all displaced and subdivided geometry before the render begins. Ray tracing can be significantly faster when this setting is enabled at the cost of potentially huge memory requirements."], "extent": [18810, 19050]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Disable Predicing"], "extent": [19050, 19073], "body": [{"type": "para", "indent": 8, "text": ["Geometry is diced when it is hit by a ray."], "extent": [19073, 19133]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Full Predicing"], "extent": [19133, 19153], "body": [{"type": "para", "indent": 8, "text": ["Generate and store all diced geometry at once."], "extent": [19153, 19217]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Precompute Bounds"], "extent": [19217, 19240], "body": [{"type": "para", "indent": 8, "text": ["Generate all diced geometry just to compute accurate bounding boxes.  This setting will discard the diced geometry as soon as the box has been computed, so it is very memory efficient.  This can be useful to improve efficiency when using displacements with a large displacement bound without incurring the memory cost of full predicing."], "extent": [19240, 19586]}], "container": true}], "container": true}, {"type": "para", "indent": 4, "text": ["When ray-tracing, if all polygons on the model are visible (either to primary or secondary rays) it can be more efficient to pre-dice all the geometry in that model rather than caching portions of the geometry and re-generating the geometry on the fly. This is especially true when global illumination is being computed (since there is less coherency among rays)."], "extent": [19586, 19955]}, {"type": "para", "indent": 4, "text": ["Currently not supported for per-primitive material assignment (material SOP)."], "extent": [19955, 20038]}], "container": true, "attrs": {"hprop": "vm_raypredice", "ifdprop": "object:raypredice"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Heightfield Tessellation Mode"], "role": "item", "extent": [20038, 20071], "body": [{"type": "para", "indent": 4, "text": ["This property is used to select different tessellation style for heightfield objects."], "extent": [20140, 20231]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Uniform"], "extent": [20231, 20244], "body": [{"type": "para", "indent": 8, "text": ["Uniform mesh grid whose the number of rows and columns depend on its distance to camera."], "extent": [20244, 20346]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Edge Length"], "extent": [20346, 20363], "body": [{"type": "para", "indent": 8, "text": ["Adaptively split each face based on projected edge length in raster space."], "extent": [20363, 20448]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_heightfieldtess", "ifdprop": "object:heightfieldtess"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Driver"], "extent": [20448, 20461], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Save Binary Geometry"], "role": "item", "extent": [20461, 20486], "body": [{"type": "para", "indent": 4, "text": ["Saves binary geometry in the IFD. If this option is turned off, ASCII geometry is saved in the IFD. Binary is much more efficient. ASCII is readable."], "extent": [20517, 20672]}], "container": true, "attrs": {"hprop": "vm_binarygeometry"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Save Geometry Inline"], "role": "item", "extent": [20672, 20696], "body": [{"type": "para", "indent": 4, "text": ["Writes geometry into the IFD file. When this is off, Houdini writes geometry to external temporary files instead. Leaving this option off (the default) makes rendering faster and uses less disk space. See ", {"scheme": null, "value": "/render/geometry", "type": "link", "text": ["IFD geometry"], "fullpath": "/render/geometry"}, " for more information."], "extent": [20750, 21018]}, {"type": "para", "indent": 4, "text": ["See also ", {"scheme": "Mantra", "value": "/props/mantra#vm_tmpsharedstorage", "type": "link", "text": ["Shared temp storage"], "fallback_text": "vm_tmpsharedstorage", "fullpath": "/props/mantra#vm_tmpsharedstorage", "fragment": "#vm_tmpsharedstorage"}, " and ", {"scheme": "Mantra", "value": "/props/mantra#vm_tmplocalstorage", "type": "link", "text": ["Local temp storage"], "fallback_text": "vm_tmplocalstorage", "fullpath": "/props/mantra#vm_tmplocalstorage", "fragment": "#vm_tmplocalstorage"}, "."], "extent": [21018, 21133]}], "container": true, "attrs": {"hprop": "vm_inlinestorage", "default": "False"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Reuse cached outlined geometry"], "role": "item", "extent": [21133, 21167], "body": [{"type": "para", "indent": 4, "text": ["Normally, when ", {"scheme": "Mantra", "value": "/props/mantra#vm_inlinestorage", "type": "link", "text": ["Save inline geometry"], "fallback_text": "vm_inlinestorage", "fullpath": "/props/mantra#vm_inlinestorage", "fragment": "#vm_inlinestorage"}, " is off, Houdini always writes geometry files during IFD generation, overwriting any existing files. When this option is on, if a file of the same name already exists, Houdini will re-use the existing geometry files instead of overwriting it. This does ", {"type": "em", "text": ["not"]}, " compare file modification times, it ", {"type": "em", "text": ["only"]}, " checks the file name, so after geometry is generated once it will never be updated as long as this is on. Turning this on can speed up lighting significantly, as long as you know you won\u2019t be updating your geometry."], "extent": [21205, 21793]}, {"type": "para", "indent": 4, "text": ["If you add this property, remember to always turn it off for final renders to ensure you get the up-to-date geometry."], "extent": [21793, 21916]}], "container": true, "attrs": {"hprop": "vm_reuseoutlinecache"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Shared temp storage"], "role": "item", "extent": [21916, 21939], "body": [{"type": "para", "indent": 4, "text": ["When ", {"scheme": "Mantra", "value": "/props/mantra#vm_inlinestorage", "type": "link", "text": ["Save inline geometry"], "fallback_text": "vm_inlinestorage", "fullpath": "/props/mantra#vm_inlinestorage", "fragment": "#vm_inlinestorage"}, " is off, Houdini saves geometry files to this directory when you save an IFD."], "extent": [21976, 22114]}, {"type": "para", "indent": 4, "text": ["You can use ", {"type": "code", "text": ["$F"]}, " (for example ", {"type": "code", "text": ["$HIP/ifds/storage/frame$F4"]}, ") to create separate directories for each frame. This helps avoid filename collisions and makes cleanup easier."], "extent": [22114, 22293]}, {"type": "para", "indent": 4, "text": ["See also ", {"scheme": "Mantra", "value": "/props/mantra#vm_tmplocalstorage", "type": "link", "text": ["Local temp storage"], "fallback_text": "vm_tmplocalstorage", "fullpath": "/props/mantra#vm_tmplocalstorage", "fragment": "#vm_tmplocalstorage"}, "."], "extent": [22293, 22355]}], "container": true, "attrs": {"hprop": "vm_tmpsharedstorage"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Local temp storage"], "role": "item", "extent": [22355, 22377], "body": [{"type": "para", "indent": 4, "text": ["When ", {"scheme": null, "value": "#vm_inlinestorage", "type": "link", "text": ["Save inline geometry"], "fullpath": "/props/mantra#vm_inlinestorage", "fragment": "#vm_inlinestorage"}, " is off, Houdini saves geometry files to  this directory when you pipe an IFD ", {"type": "em", "text": ["directly"]}, " to Mantra (as opposed to saving the IFD to disk). This is useful because you may be saving IFDs to a network disk, but when you pipe directly to Mantra you want to always use fast local storage and avoid slow network storage."], "extent": [22460, 22829]}, {"type": "para", "indent": 4, "text": ["Temporary files stored for pipes should automatically be cleaned up, but due to crashes or interrupted jobs, Houdini might leave these files on disk. You should periodically remove any old files left in this directory."], "extent": [22829, 23057]}, {"type": "para", "indent": 4, "text": ["See also ", {"scheme": "Mantra", "value": "/props/mantra#vm_tmpsharedstorage", "type": "link", "text": ["Shared temp storage"], "fallback_text": "vm_tmpsharedstorage", "fullpath": "/props/mantra#vm_tmpsharedstorage", "fragment": "#vm_tmpsharedstorage"}, "."], "extent": [23057, 23121]}], "container": true, "attrs": {"hprop": "vm_tmplocalstorage", "default": "\"$HOUDINI_TEMP_DIR/ifds/storage\""}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Abort on missing texture"], "role": "item", "extent": [23121, 23149], "body": [{"type": "para", "indent": 4, "text": ["Enabling this option will cause mantra to abort the render with an error if it encounters a missing texture map."], "extent": [23230, 23348]}], "container": true, "attrs": {"hprop": "vm_abort_missing_texture", "ifdprop": "renderer:abortmissingtexture"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Mantra Defaults"], "role": "item", "extent": [23348, 23367], "body": [{"type": "para", "indent": 4, "text": ["This parameter can be used to specify a JSON file containing overrides for default property values.  See also the ", {"type": "code", "text": ["-D"]}, "command line option on mantra and the default render properties in ", {"type": "code", "text": ["$HH/RenderProperties.json"]}], "extent": [23392, 23610]}], "container": true, "attrs": {"hprop": "vm_defaults"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Extra image planes"], "extent": [23610, 23635], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Fit P To Object Bounding Box"], "role": "item", "extent": [23635, 23668], "body": [{"type": "para", "indent": 4, "text": ["When baking, instead of writing shading position ", {"type": "code", "text": ["P"]}, " raw, it will be normalized to 0~1 based on bounding cube of the UV Object."], "extent": [23738, 23871]}], "container": true, "attrs": {"hprop": "vm_bake_normalizep", "ifdprop": "renderer:bake_normalizep"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Extract image planes"], "role": "item", "extent": [23871, 23895], "body": [{"type": "para", "indent": 4, "text": ["When enabled, image planes contained in the output image will be extracted to separate files. The files will be saved alongside the output image, in the format: ", {"type": "code", "text": ["$<basename>>.", {"type": "var", "text": ["plane_name"]}, ".", {"type": "var", "text": ["extension"]}]}, "."], "extent": [23972, 24183]}], "container": true, "attrs": {"hprop": "vm_extractimageplanes", "ifdprop": "renderer:extractimageplanes"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Extract image planes format"], "role": "item", "extent": [24183, 24214], "body": [{"type": "para", "indent": 4, "text": ["Determines the file format to use when extracting image planes to separate files."], "extent": [24303, 24390]}], "container": true, "attrs": {"hprop": "vm_extractimageplanesformat", "ifdprop": "renderer:extractimageplanesformat"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Remove Intermediate Output"], "role": "item", "extent": [24390, 24420], "body": [{"type": "para", "indent": 4, "text": ["When enabled, intermediate output file (vm_uvoutputpicture) will be deleted after the image planes have been extracted."], "extent": [24511, 24636]}], "container": true, "attrs": {"hprop": "vm_extractremoveintermediate", "ifdprop": "renderer:extractremoveintermediate"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Extract linear planes"], "role": "item", "extent": [24636, 24661], "body": [{"type": "para", "indent": 4, "text": ["This pattern specifies planes which should be extracted in linear color space rather than the color space of the image format.  For example, if gamma correction is applied to tangent planes when saving to JPG or Targa images, there can be significant precision lost."], "extent": [24740, 25012]}], "container": true, "attrs": {"hprop": "vm_extractlinearplanes", "ifdprop": "renderer:extractlinearplanes"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Copy alpha to planes"], "role": "item", "extent": [25012, 25036], "body": [{"type": "para", "indent": 4, "text": ["Comma-separated list of planes that will have the alpha channel (copied from the primary plane). Alpha data comes from before the UDIM post-processing. Note that alpha will not be premultiplied, even if the extract format expects it (such as EXR format)."], "extent": [25117, 25377]}], "container": true, "attrs": {"hprop": "vm_bake_alphadestplanes", "ifdprop": "renderer:bake_alphadestplanes"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Name Separator"], "role": "item", "extent": [25377, 25395], "body": [{"type": "para", "indent": 4, "text": ["When extracting images for baking, this is the separator string that\u2019s inserted between the filename and the channel name.  For with a separator of ", {"type": "code", "text": ["."]}, ", the extracted image might be ", {"type": "code", "text": ["texture.Nt.png"]}, " instead of ", {"type": "code", "text": ["texture_Nt.png"]}, "."], "extent": [25468, 25701]}], "container": true, "attrs": {"hprop": "vm_extractseparator", "ifdprop": "renderer:extractseparator"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Export components"], "role": "item", "extent": [25701, 25722], "body": [{"type": "para", "indent": 4, "text": ["A whitespace-separated list of shading component names that will be computed for export. If you have defined new component labels in your materials, these can be added to the list so that they are exported for per-component export planes. If you are not using some components, remove them from the list to improve render efficiency."], "extent": [25795, 26133]}, {"type": "para", "indent": 4, "text": ["PBR light exports assume that this list is complete - that is, all components created by shaders are listed. If there are unlisted components, light exports may be missing illumination from these components."], "extent": [26133, 26346]}], "container": true, "attrs": {"hprop": "vm_exportcomponents", "ifdprop": "renderer:exportcomponents"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Show extra image plane parameters"], "role": "item", "extent": [26346, 26383], "body": [], "container": true, "attrs": {"hprop": "vm_showextraplaneparms", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Shading position (P)"], "role": "item", "extent": [26435, 26459], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_P", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Shading depth (Pz)"], "role": "item", "extent": [26504, 26526], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_Pz", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Shading normal (N)"], "role": "item", "extent": [26572, 26594], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_N", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Shading tangent-space normal (Nt)"], "role": "item", "extent": [26639, 26676], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_Nt", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Direct lighting (per-component)"], "role": "item", "extent": [26722, 26757], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_direct_comp", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Indirect lighting (per-component)"], "role": "item", "extent": [26812, 26849], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_indirect_comp", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Combined emission"], "role": "item", "extent": [26906, 26927], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_all_emission", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Direct unshadowed"], "role": "item", "extent": [26983, 27004], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_direct_noshadow", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Direct Unshadowed (per-component, PBR only)"], "role": "item", "extent": [27063, 27110], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_direct_noshadow_comp", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Direct ray samples"], "role": "item", "extent": [27174, 27196], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_direct_samples", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Indirect ray samples"], "role": "item", "extent": [27254, 27278], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_indirect_samples", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["SSS single/multi"], "role": "item", "extent": [27338, 27358], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_sss", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Surface Unlit Base Color (basecolor)"], "role": "item", "extent": [27405, 27445], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_basecolor", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Surface Unlit Diffuse Color (diffcolor)"], "role": "item", "extent": [27498, 27541], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_diffcolor", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Surface Unlit Specular Color (speccolor)"], "role": "item", "extent": [27594, 27638], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_speccolor", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Surface Emission Color (emitcolor)"], "role": "item", "extent": [27691, 27729], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_emitcolor", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Surface SSS color (ssscolor)"], "role": "item", "extent": [27782, 27814], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_ssscolor", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Surface Metallic (metallic)"], "role": "item", "extent": [27866, 27897], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_metallic", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Surface Roughness (specrough)"], "role": "item", "extent": [27949, 27982], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_specrough", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Nt Channel Name"], "role": "item", "extent": [28035, 28054], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_Nt_channel", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Ds Channel Name"], "role": "item", "extent": [28108, 28127], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_Ds_channel", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Vd Channel Name"], "role": "item", "extent": [28181, 28200], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_Vd_channel", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Vdt Channel Name"], "role": "item", "extent": [28254, 28274], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_Vdt_channel", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Oc Channel Name"], "role": "item", "extent": [28329, 28348], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_Oc_channel", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Cv Channel Name"], "role": "item", "extent": [28402, 28421], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_Cv_channel", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Th Channel Name"], "role": "item", "extent": [28475, 28494], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_Th_channel", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Cu Channel Name"], "role": "item", "extent": [28548, 28567], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_Cu_channel", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["P Channel Name"], "role": "item", "extent": [28621, 28639], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_P_channel", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["N Channel Name"], "role": "item", "extent": [28692, 28710], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_N_channel", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Pz Channel Name"], "role": "item", "extent": [28763, 28782], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_Pz_channel", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Ab Channel Name"], "role": "item", "extent": [28836, 28855], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_Ab_channel", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["basecolor Channel Name"], "role": "item", "extent": [28909, 28935], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_basecolor_channel", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["diffcolor Channel Name"], "role": "item", "extent": [28996, 29022], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_diffcolor_channel", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["speccolor Channel Name"], "role": "item", "extent": [29083, 29109], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_speccolor_channel", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["emitcolor Channel Name"], "role": "item", "extent": [29170, 29196], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_emitcolor_channel", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["ssscolor Channel Name"], "role": "item", "extent": [29257, 29282], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_ssscolor_channel", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["metallic Channel Name"], "role": "item", "extent": [29342, 29367], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_metallic_channel", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["specrough Channel Name"], "role": "item", "extent": [29427, 29453], "body": [], "container": true, "attrs": {"hprop": "vm_quickplane_specrough_channel", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Generate Op IDs for objects"], "role": "item", "extent": [29514, 29545], "body": [], "container": true, "attrs": {"hprop": "vm_generate_opid"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Fog"], "extent": [29575, 29585], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Add background for fog"], "role": "item", "extent": [29585, 29612], "body": [{"type": "para", "indent": 4, "text": ["Mantra only runs atmosphere shaders after surface shaders have been run. This means that there are no atmosphere shaders run if there are no objects rendered. When this setting is true, a giant box is created surrounding the scene. The box has a matte shader applied. The size of the box is determined by ", {"type": "code", "text": ["sqrt(1/3) * ", {"type": "var", "text": ["far_clip"]}]}, " (the camera\u2019s far clipping plane)."], "extent": [29679, 30051]}], "container": true, "attrs": {"hprop": "vm_fogbackground", "ifdprop": "renderer:fogbackground"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Formatting"], "extent": [30051, 30068], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Float precision"], "role": "item", "extent": [30068, 30088], "body": [], "container": true, "attrs": {"hprop": "soho_precision", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Safe object names"], "role": "item", "extent": [30132, 30153], "body": [], "container": true, "attrs": {"hprop": "soho_almostzero", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Indent step"], "role": "item", "extent": [30198, 30213], "body": [], "container": true, "attrs": {"hprop": "soho_indentstep", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Line wrap"], "role": "item", "extent": [30258, 30271], "body": [], "container": true, "attrs": {"hprop": "soho_linewrap", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Almost zero"], "role": "item", "extent": [30314, 30329], "body": [], "container": true, "attrs": {"hprop": "soho_almostzero", "status": "nd"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Geometry"], "extent": [30374, 30389], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Ignore geometry attribute shaders"], "role": "item", "extent": [30389, 30427], "body": [{"type": "para", "indent": 4, "text": ["When geometry has shaders defined on a per-primitive basis, this parameter will override these shaders and use only the object\u2019s shader. This is useful when performing matte shading on objects."], "extent": [30494, 30693]}, {"type": "para", "indent": 4, "text": ["Not supported for per-primitive material assignment (material SOP)."], "extent": [30693, 30766]}], "container": true, "attrs": {"hprop": "vm_overridedetail", "ifdprop": "object:overridedetail"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Volume Velocity Names"], "role": "item", "extent": [30766, 30791], "body": [{"type": "para", "indent": 4, "text": ["Specifies comma separated list of names for the velocity field for volume primitives."], "extent": [30870, 30961]}], "container": true, "attrs": {"hprop": "vm_volumevelocitynames", "ifdprop": "geometry:volumevelocitynames"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Just In Time Curve Creation"], "role": "item", "extent": [30961, 30992], "body": [{"type": "para", "indent": 4, "text": ["Normally, mantra will create an internal representation for curve primitives which can be used to accelerate curve intersection.  However, this internal representation consumes memory.  This setting will avoid creation of the internal representation until it\u2019s actually required by mantra.  This improves start-up time and keeps memory down but requires more compute cycles to perform intersections."], "extent": [31049, 31454]}, {"type": "para", "indent": 4, "text": ["For IPR, turning on JIT curves can improve interactivity for scenes with a lot of curves (i.e. hair or fur)."], "extent": [31454, 31568]}], "container": true, "attrs": {"hprop": "vm_jitcurves", "ifdprop": "object:jitcurves"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Material Override"], "role": "item", "extent": [31568, 31589], "body": [{"type": "para", "indent": 4, "text": ["Controls how material overrides are evaluated and output to the IFD. "], "extent": [31666, 31745]}, {"type": "para", "indent": 4, "text": ["When set to ", {"type": "ui", "text": ["Evaluate Once"]}, ", any parameter on the material, that\n    uses channels or expressions, will be evaluated only once\n    for the entire detail. This results in significantly faster IFD \n    generation, due to the material parameter assignment being handled\n    entirely by Mantra, rather than Houdini. \n    Setting the parameter value to ", {"type": "ui", "text": ["Evaluate for Each Primitive/Point"]}, "  \n    will evaluate those parameters for each primitive and/or point. \n    It\u2019s also possible to skip material overrides entirely by setting \n    the parameter value to ", {"type": "ui", "text": ["Disabled"]}, "."], "extent": [31745, 32321]}], "container": true, "attrs": {"hprop": "vm_materialoverride", "ifdprop": "geometry:materialoverride"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Procedural shader"], "role": "item", "extent": [32321, 32342], "body": [{"type": "para", "indent": 4, "text": ["Geometry SHOP used by the renderer to generate render geometry for this object."], "extent": [32377, 32462]}], "container": true, "attrs": {"hprop": "shop_geometrypath"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Auto-archiving"], "role": "item", "extent": [32462, 32480], "body": [], "container": true, "attrs": {"hprop": "vm_auto_archive", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Geometry disk file"], "role": "item", "extent": [32525, 32547], "body": [], "container": true, "attrs": {"hprop": "vm_archive", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Render Polygon Curves as Subdivision (Mantra)"], "role": "item", "extent": [32587, 32636], "body": [{"type": "para", "indent": 4, "text": ["Mantra supports rendering polygonal curves as subdivision curves. Subdivision curves are similar to subdivision surfaces but for curve geometry. Mantra will refine subdivision curves based on their shading quality (similar to how mantra will refine subdivision surfaces based on the shading quality). Subdivision curves render smoothly like other spline types, but are end-interpolating and also handle branching (as extraordinary points on the geometry)."], "extent": [32707, 33168]}], "container": true, "attrs": {"hprop": "vm_rendersubdcurves", "ifdprop": "object:rendersubdcurves"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Render as points (Mantra)"], "role": "item", "extent": [33168, 33197], "body": [{"type": "para", "indent": 4, "text": ["Controls how points from geometry are rendered. At the default settings, ", {"type": "ui", "text": ["No Point Rendering"]}, ", only points from particle systems are rendered. \n    Setting this value to ", {"type": "ui", "text": ["Render Only Points"]}, ", will render the geometry using only the point attributes, ignoring all vertex and primitive information.\n    ", {"type": "ui", "text": ["Render Unconnected Points"]}, " works in a similar way, but only for points not used by any of the geometry\u2019s primitives."], "extent": [33260, 33694]}, {"type": "para", "indent": 4, "text": ["Two attributes control the point primitives if they exist."], "extent": [33694, 33762]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["orient"]}], "extent": [33762, 33776], "body": [{"type": "para", "indent": 8, "text": ["A vector which determines the normal of the point geometry. If the attribute doesn\u2019t exist, points are oriented to face the incoming ray (the VEX ", {"type": "code", "text": ["I"]}, " variable)."], "extent": [33776, 33954]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["width"]}], "extent": [33954, 33967], "body": [{"type": "para", "indent": 8, "text": ["Determines the 3D size of the points (defaults to 0.05)."], "extent": [33967, 34033]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_renderpoints", "ifdprop": "object:renderpoints"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Render points as (Mantra)"], "role": "item", "extent": [34033, 34062], "body": [{"type": "para", "indent": 4, "text": ["Determines the interpretation of how point primitives are rendered.  The light-weight point primitives can be rendered as either spheres or circles."], "extent": [34129, 34283]}], "container": true, "attrs": {"hprop": "vm_renderpointsas", "ifdprop": "object:renderpointsas"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Point Scale"], "role": "item", "extent": [34283, 34298], "body": [{"type": "para", "indent": 4, "text": ["Scales the width of point primitives by the value given. This is applied \n    on top of any point width attribute specified on the geometry."], "extent": [34361, 34507]}], "container": true, "attrs": {"hprop": "vm_pointscale", "ifdprop": "object:pointscale"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Treat point scale as diameter instead of radius"], "role": "item", "extent": [34507, 34558], "body": [], "container": true, "attrs": {"hprop": "vm_pscalediameter", "ifdprop": "object:pscalediameter", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Auto-Instancing Of Alembic/Packed Primitives"], "role": "item", "extent": [34641, 34689], "body": [{"type": "para", "indent": 4, "text": ["Detect common Alembic shapes (or other shared packed primitives) and share\n    the geometry when rendering in mantra."], "extent": [34752, 34879]}, {"type": "para", "indent": 4, "text": ["With this option enabled, most attributes defined on the packed primitive\n    cannot be passed to shaders.  Since the underlying geometry is shared,\n    there\u2019s no way to change the attribute values for each instance.  For\n    example, a Packed Alembic Primitive with a ", {"type": "code", "text": ["Cd"]}, " attribute may not render as\n    expected.  The exceptions to this are the ", {"type": "code", "text": ["shop_materialpath"]}, " and\n    ", {"type": "code", "text": ["material_override"]}, " attributes which work as expected (since mantra is able\n    to change these properties independently for each instance)."], "extent": [34879, 35402]}], "container": true, "attrs": {"hprop": "vm_packinstance", "ifdprop": "object:packinstance"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Merge packed fragments into single geometry"], "role": "item", "extent": [35402, 35449], "body": [{"type": "para", "indent": 4, "text": ["For efficiency, mantra usually merges separate fragments into a single piece of geometry.  This typically uses less geometry and renders more efficiently."], "extent": [35526, 35686]}, {"type": "para", "indent": 4, "text": ["However, since the geometry is merged into a single piece of geometry for rendering, the individual packed fragments are not available for material stylesheets and their attributes aren\u2019t available for the ", {"type": "code", "text": ["renderstate()"]}, " function."], "extent": [35686, 35923]}, {"type": "para", "indent": 4, "text": ["Disabling this option will cause each fragment primitive to be rendered as a separate mantra object.  This will typically take more memory and may impact rendering performance."], "extent": [35923, 36105]}], "container": true, "attrs": {"hprop": "vm_pack_mergefragments", "ifdprop": "object:pack_mergefragments"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Packed Sequence Segments"], "role": "item", "extent": [36105, 36133], "body": [{"type": "para", "indent": 4, "text": ["When rendering packed disk sequence primitives, mantra will automatically\n    blend sub-frame geometry to create accurate motion blur.  When there are a\n    large number of packed disk sequence primitives, this can use significant\n    memory.  By limiting the number of sub-frame blending samples, memory can\n    be decreased."], "extent": [36214, 36546]}], "container": true, "attrs": {"hprop": "vm_pack_sequencesubsteps", "ifdprop": "object:pack_sequencesubsteps"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Packed refinement options"], "role": "item", "extent": [36546, 36575], "body": [{"type": "para", "indent": 4, "text": ["This option is for very advanced users only."], "extent": [36650, 36700]}, {"type": "para", "indent": 4, "text": ["It\u2019s typically only used for debugging (or possibly for HDK users)."], "extent": [36700, 36773]}, {"type": "para", "indent": 4, "text": ["When packed geometry is refined by mantra using the GT HDK classes, this option can be used to specify a Python style dictionary of options that are passed through the ", {"type": "code", "text": ["GT_RefineParms"]}, ".  This dictionary is loaded into a ", {"type": "code", "text": ["UT_Options"]}, " object and passed to the ", {"type": "code", "text": ["GT_RefineParms::load()"]}, " method."], "extent": [36773, 37073]}], "container": true, "attrs": {"hprop": "vm_pack_refineoptions", "ifdprop": "object:pack_refineoptions"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Flatten Procedurals"], "role": "item", "extent": [37073, 37096], "body": [{"type": "para", "indent": 4, "text": ["When rendering multiple instances as subdivision or displaced surfaces,\n    mantra chooses the ", {"type": "q", "text": ["best"]}, " level of detail for rendering.  Procedurals are\n    only evaluated when they are actually rendered.  So, if procedurals share\n    underlying geometry (i.e. Alembic primitives), it\u2019s possible that the level\n    of detail will be chosen before all procedurals have been evaluated.  This\n    means that the level of detail may be chosen incorrectly (depending on\n    rendering order)."], "extent": [37169, 37658]}, {"type": "para", "indent": 4, "text": ["This option can be set on a per-object basis and will cause all required\n    procedurals to be evaluated so the proper level of detail can be chosen\n    for instanced geometry."], "extent": [37658, 37840]}, {"type": "para", "indent": 4, "text": ["If this option is disabled, mantra will emit warnings when it detects a\n    potential level of detail issue."], "extent": [37840, 37954]}, {"type": "para", "indent": 4, "text": ["Enabling this option may increase render start up time and memory\n    requirements."], "extent": [37954, 38043]}], "container": true, "attrs": {"hprop": "vm_flattenprocedural", "ifdprop": "object:flattenprocedural"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Flatten Procedurals To Root Level"], "role": "item", "extent": [38043, 38080], "body": [{"type": "para", "indent": 4, "text": ["When there are nested procedurals, this optimizes the layout of the acceleration structure."], "extent": [38145, 38242]}], "container": true, "attrs": {"hprop": "vm_flattentoroot", "ifdprop": "object:flattentoroot"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Proc Use Root Transform"], "role": "item", "extent": [38242, 38269], "body": [{"type": "para", "indent": 4, "text": ["Enabling this option will cause procedurals to use their root transform. The default behavior is to use the leaf\u2019s transform."], "extent": [38348, 38479]}, {"type": "para", "indent": 4, "text": ["This will most notably impact the transform space on packed primitives.  If the ", {"type": "code", "text": ["vm_procuseroottransform"]}, " is turned on, the object space for the packed primitive will be the space of the object containing the geometry.  If the option is turned off, the transform space for a packed primitive will be the local space of the packed primitive (i.e. combining the packed primitive\u2019s transform with the object that contains the geometry)."], "extent": [38479, 38918]}, {"type": "para", "indent": 4, "text": ["See also ", {"type": "code", "text": ["vm_sharedisplace"]}, "."], "extent": [38918, 38952]}], "container": true, "attrs": {"hprop": "vm_procuseroottransform", "ifdprop": "object:procuseroottransform"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Use N for point rendering"], "role": "item", "extent": [38952, 38981], "body": [{"type": "para", "indent": 4, "text": ["Mantra will initialize the ", {"type": "code", "text": ["N"]}, " global from the ", {"type": "code", "text": ["N"]}, " attribute when rendering point primitives. When disabled (the default), point normals will be initialized to face the camera."], "extent": [39046, 39228]}], "container": true, "attrs": {"hprop": "vm_usenforpoints", "ifdprop": "object:usenforpoints"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Metaballs as volume"], "role": "item", "extent": [39228, 39251], "body": [{"type": "para", "indent": 4, "text": ["Render metaballs as volumes as opposed to surfaces.  The volume quality for metaballs will be set based on the average size of all metaballs in the geometry, so increasing or decreasing the metaball size will automatically adjust the render quality to match."], "extent": [39310, 39574]}], "container": true, "attrs": {"hprop": "vm_metavolume", "ifdprop": "object:metavolume"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Use unit s/t for curves"], "role": "item", "extent": [39574, 39601], "body": [{"type": "para", "indent": 4, "text": ["Enables unit s/t values when rendering curves.  Unit t values start at 0 at one end of the curve, and increase to 1 at the tip regardless of the number of bezier segments that comprise the curve.  Non-unit t values restart at 0 for each curve segment.  Unit s/t values are required for correct shading of fur."], "extent": [39662, 39977]}], "container": true, "attrs": {"hprop": "vm_curveunitst", "ifdprop": "object:curveunitst"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Compute Volume Normals"], "role": "item", "extent": [39977, 40003], "body": [{"type": "para", "indent": 4, "text": ["Typically, mantra doesn\u2019t automatically fill in the normal variable for\n    volume primitives.  This is because it\u2019s not usually required for lighting\n    and can be expensive to compute."], "extent": [40066, 40259]}, {"type": "para", "indent": 4, "text": ["However, when generating deep raster planes for normals, it\u2019s sometimes\n    useful to have the normals computed, which this option enables."], "extent": [40259, 40404]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [40404, 40414], "body": [{"type": "para", "indent": 8, "text": ["Photon map generation relies on having 0 length normals for volume primitives, so this option should be turned off during photon map generation."], "extent": [40414, 40568]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"hprop": "vm_volumenormal", "ifdprop": "object:volumenormal"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Normalize dPdz over FOV"], "role": "item", "extent": [40568, 40595], "body": [{"type": "para", "indent": 4, "text": ["Toggles the weighting of the global ", {"type": "code", "text": ["dPdz"]}, " parameter across the field of view of the camera. This has the effect of normalizing opacity across the projected field."], "extent": [40660, 40829]}], "container": true, "attrs": {"hprop": "vm_volumedpdzfov", "ifdprop": "object:volumedpdzfov"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Force procedural geometry output"], "role": "item", "extent": [40829, 40865], "body": [{"type": "para", "indent": 4, "text": ["Enables output of geometry when a procedural shader is assigned.  If you know that the procedural you have assigned does not rely on geometry being present for the procedural to operate correctly, you can disable this toggle."], "extent": [40895, 41126]}], "container": true, "attrs": {"hprop": "vm_forcegeometry"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Coving"], "role": "item", "extent": [41126, 41136], "body": [{"type": "para", "indent": 4, "text": ["Whether Mantra will try to prevent cracks."], "extent": [41187, 41239]}, {"type": "para", "indent": 4, "text": ["Coving is the process of filling cracks in diced geometry\n    at render time, where different levels of dicing side-by-side\n    create gaps at T-junctions."], "extent": [41239, 41404]}, {"type": "para", "indent": 4, "text": ["The default setting, ", {"type": "ui", "text": ["Coving for displacement/sub-d"]}, ", only does\n    coving for surfaces with a displacement shader and subdivision\n    surfaces, where the displacement of points can potentially create\n    large cracks. This is sufficient for more rendering, however\n    you may want to use ", {"type": "ui", "text": ["Coving for all primitives"]}, " if you are\n    using a very low shading rate or see cracks in the alpha of the\n    rendered image."], "extent": [41404, 41834]}, {"type": "para", "indent": 4, "text": ["Do not use ", {"type": "ui", "text": ["Disable coving"]}, ". It has no performance\n    benefit, and may actually harm performance since Houdini has to\n    render any geometry visible through the crack."], "extent": [41834, 42015]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["0"]}], "extent": [42015, 42024], "body": [{"type": "para", "indent": 8, "text": ["No coving."], "extent": [42024, 42043]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["1"]}], "extent": [42043, 42052], "body": [{"type": "para", "indent": 8, "text": ["Only displaced surfaces and sub-division surfaces will be coved."], "extent": [42052, 42125]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["2"]}], "extent": [42125, 42134], "body": [{"type": "para", "indent": 8, "text": ["All primitives will be coved."], "extent": [42134, 42173]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_coving", "ifdprop": "object:coving"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Use Sample Coving"], "role": "item", "extent": [42173, 42194], "body": [{"type": "para", "indent": 4, "text": ["When coving is enabled, this indicates to perform coving by implicitly\n    expanding diced geometry, instead of by creating new polygons, to\n    fill cracks caused by T-junctions where different levels of dicing\n    are side-by-side."], "extent": [42257, 42500]}, {"type": "para", "indent": 4, "text": ["Because no additional polygons are required, this can save memory,\n    but if geometry is expanded too far, it can result in slow raytracing.\n    The ", {"type": "ui", "text": ["Sample Coving Expansion Factor"]}, " parameter indicates how much to\n    implicitly expand the geometry, relative to the size of each diced piece."], "extent": [42500, 42800]}, {"type": "para", "indent": 4, "text": ["Sample coving does not apply to micropolygon rendering."], "extent": [42800, 42861]}], "container": true, "attrs": {"hprop": "vm_samplecoving", "ifdprop": "object:samplecoving"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Sample Coving Expansion Factor"], "role": "item", "extent": [42861, 42895], "body": [{"type": "para", "indent": 4, "text": ["When sample coving is enabled with the ", {"type": "ui", "text": ["Use Sample Coving"]}, " parameter,\n    this dictates how much to implicitly expand diced geometry, relative\n    to the size of each diced piece, to fill cracks caused by T-junctions\n    where different levels of dicing are side-by-side."], "extent": [42976, 43255]}, {"type": "para", "indent": 4, "text": ["If geometry is expanded too far, it can result in slow raytracing.\n    For example, a value of 10 can be quite slow.  Setting small negative\n    values, e.g. -0.1, or the minimum allowed value, -1, can help visualize\n    how geometry is diced."], "extent": [43255, 43504]}], "container": true, "attrs": {"hprop": "vm_samplecovingexpansion", "ifdprop": "object:samplecovingexpansion"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Backface removal (Mantra)"], "role": "item", "extent": [43504, 43533], "body": [{"type": "para", "indent": 4, "text": ["If enabled, geometry that are facing away from the camera are not\n    rendered."], "extent": [43592, 43677]}], "container": true, "attrs": {"hprop": "vm_rmbackface", "ifdprop": "object:rmbackface"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Render group"], "role": "item", "extent": [43677, 43693], "body": [{"type": "para", "indent": 4, "text": ["Each object references a geometry object. Houdini geometry allows multiple primitive groups to be defined. If the ", {"type": "code", "text": ["object:geometrygroup"]}, " parameter is set to a string, only the primitives which are members of the named group will be rendered by this instance. This allows multiple objects to instance the same geometry, but render different parts."], "extent": [43758, 44110]}, {"type": "para", "indent": 4, "text": ["Not supported for per-primitive material assignment (material SOP)."], "extent": [44110, 44183]}], "container": true, "attrs": {"hprop": "vm_geometrygroup", "ifdprop": "object:geometrygroup"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Add Normals to Geometry"], "role": "item", "extent": [44183, 44210], "body": [{"type": "para", "indent": 4, "text": ["If there are no normals on an object, this indicates what type of normals to compute before saving the geometry, if any.  If this is set to ", {"type": "ui", "text": ["Vertex Normals"]}, ", any edges with dihedral angles greater than the ", {"type": "ui", "text": ["Cusp Angle for Vertex Normals"]}, " parameter will be cusped."], "extent": [44239, 44512]}], "container": true, "attrs": {"hprop": "vm_addnormalsto"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Cusp Angle for Vertex Normals"], "role": "item", "extent": [44512, 44545], "body": [{"type": "para", "indent": 4, "text": ["If there are no normals on an object, and ", {"type": "ui", "text": ["Add Normals To Geometry"]}, " is set to ", {"type": "ui", "text": ["Vertex Normals"]}, ", any edges with dihedral angles greater than this parameter will be cusped."], "extent": [44571, 44751]}], "container": true, "attrs": {"hprop": "vm_cuspangle"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Automatically Compute Normals (Old)"], "role": "item", "extent": [44751, 44790], "body": [{"type": "para", "indent": 4, "text": ["Whether mantra should compute the N attribute automatically. If the N attribute exists, the value will remain unchanged. However, if no N attribute exists, it will be created. This allows polygon geometry which doesn\u2019t have the N attribute already computed to be smooth shaded."], "extent": [44847, 45130]}, {"type": "para", "indent": 4, "text": ["Not supported for per-primitive material assignment (material SOP)."], "extent": [45130, 45203]}], "container": true, "attrs": {"hprop": "vm_computeN", "ifdprop": "geometry:computeN"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Motion Blurred Attributes"], "role": "item", "extent": [45203, 45232], "body": [{"type": "para", "indent": 4, "text": ["Specifies the geometry attributes that will have segments created when\n    computing motion blur. The ", {"type": "code", "text": ["P"]}, " attribute is included by default."], "extent": [45297, 45442]}], "container": true, "attrs": {"hprop": "vm_segmentattrs", "ifdprop": "geometry:segmentattrs"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Instance"], "extent": [45442, 45457], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Point instancing"], "role": "item", "extent": [45457, 45478], "body": [{"type": "para", "indent": 4, "text": ["Turns point instancing on."], "extent": [45506, 45542]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["0"]}], "extent": [45542, 45551], "body": [{"type": "para", "indent": 8, "text": ["Instance the target object in place of this object."], "extent": [45551, 45611]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["1"]}], "extent": [45611, 45620], "body": [{"type": "para", "indent": 8, "text": ["Instance the target object ", {"type": "em", "text": ["on each point"]}, " of this object."], "extent": [45620, 45688]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "ptinstance"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Instance object"], "role": "item", "extent": [45688, 45707], "body": [{"type": "para", "indent": 4, "text": ["Path to the object to instance (may be a subnetwork, light, etc.)."], "extent": [45737, 45813]}], "container": true, "attrs": {"hprop": "instancepath"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Point motion blur"], "role": "item", "extent": [45813, 45834], "body": [{"type": "para", "indent": 4, "text": ["Controls how the point position will be evaluated when transformation blur is enabled on the objects.  It does not turn motion blur on for the points. Possible values are ", {"type": "code", "text": ["off"]}, " (no motion blur), ", {"type": "code", "text": ["deform"]}, " (compute sub-frame geometry), or ", {"type": "code", "text": ["velocity"]}, " (use point velocity attribute)."], "extent": [45864, 46149]}], "container": true, "attrs": {"hprop": "ptmotionblur"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Instance Transform"], "role": "item", "extent": [46149, 46171], "body": [{"type": "para", "indent": 4, "text": ["When this option is on (1), the transform of the target (instanced) object is combined with the transform of this object. When this option is off (0), only this object\u2019s transform is used."], "extent": [46202, 46396]}], "container": true, "attrs": {"hprop": "instancexform"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Irradiance"], "extent": [46396, 46413], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Enable irradiance cache"], "role": "item", "extent": [46413, 46441], "body": [{"type": "para", "indent": 4, "text": ["Enables the irradiance cache, which can significantly improve the performance of the irradiance and occlusion VEX function calls."], "extent": [46496, 46635]}, {"type": "para", "indent": 4, "text": ["This has no effect when using area lights or the PBR rendering engines.  Normally the irradiance cache should only be used with a VEX Global Illumination light or with shaders that use the occlusion() or irradiance() functions."], "extent": [46635, 46868]}], "container": true, "attrs": {"hprop": "vm_gienable", "ifdprop": "object:gienable"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Irradiance cache file"], "role": "item", "extent": [46868, 46893], "body": [{"type": "para", "indent": 4, "text": ["The file to store the irradiance cache. If multiple objects specify the same file, the cache file will contain samples from all objects."], "extent": [46944, 47086]}], "container": true, "attrs": {"hprop": "vm_gifile", "ifdprop": "object:gifile"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Read/write mode"], "role": "item", "extent": [47086, 47105], "body": [{"type": "para", "indent": 4, "text": ["The read-write mode for the global irradiance file."], "extent": [47164, 47225]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["r"]}], "extent": [47225, 47234], "body": [{"type": "para", "indent": 8, "text": ["Read only."], "extent": [47234, 47253]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["w"]}], "extent": [47253, 47262], "body": [{"type": "para", "indent": 8, "text": ["Write only. This will generate a new irradiance cache file on disk at the specified sampling rate"], "extent": [47262, 47368]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["rw"]}], "extent": [47368, 47378], "body": [{"type": "para", "indent": 8, "text": ["Read and write. This will load an irradiance cache file from disk and use the pre-existing results where they exist It will also generate new samples for parts of the image that were not rendered in the original cache file generation."], "extent": [47378, 47622]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_gifilemode", "ifdprop": "object:gifilemode"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Default samples"], "role": "item", "extent": [47622, 47641], "body": [{"type": "para", "indent": 4, "text": ["The default number of samples used to compute irradiance when the shader doesn\u2019t specify it. In most cases, the shader does specify the value."], "extent": [47696, 47844]}], "container": true, "attrs": {"hprop": "vm_gisample", "ifdprop": "object:gisample"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Irradiance error"], "role": "item", "extent": [47844, 47864], "body": [{"type": "para", "indent": 4, "text": ["The maximum error tolerance between samples in the irradiance map.  Normally you should only decrease this value from the default of 0.1 if there are artifacts in the render."], "extent": [47917, 48097]}], "container": true, "attrs": {"hprop": "vm_gierror", "ifdprop": "object:gierror"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Min spacing (pixels)"], "role": "item", "extent": [48097, 48121], "body": [{"type": "para", "indent": 4, "text": ["In some cases, you can get a very dense clustering of irradiance samples in the cache. This parameter prevents the clustering by ensuring that there are at least this many pixels between samples. Clustering usually occurs between non-smooth intersections between different primitives."], "extent": [48188, 48478]}], "container": true, "attrs": {"hprop": "vm_giminspacing", "ifdprop": "object:giminspacing"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Max spacing (pixels)"], "role": "item", "extent": [48478, 48502], "body": [{"type": "para", "indent": 4, "text": ["The maximum screen space between irradiance samples. Lowering this value will force more samples to be computed, creating a more accurate representation of the irradiance information."], "extent": [48565, 48754]}], "container": true, "attrs": {"hprop": "vm_gimaxspacing", "ifdprop": "object:gimaxspacing"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Light"], "extent": [48754, 48766], "body": [{"type": "para", "indent": 0, "text": ["Lights objects inherit many of the geometry object properties in addition to the special light properties."], "extent": [48766, 48875]}, {"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Light color"], "role": "item", "extent": [48875, 48890], "body": [], "container": true, "attrs": {"hprop": "light_color", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Export plane prefix"], "role": "item", "extent": [48931, 48954], "body": [], "container": true, "attrs": {"hprop": "vm_export_prefix", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Export plane suffix"], "role": "item", "extent": [49000, 49023], "body": [], "container": true, "attrs": {"hprop": "vm_export_suffix", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Area shape"], "role": "item", "extent": [49069, 49083], "body": [{"type": "para", "indent": 4, "text": ["The shape of an area light."], "extent": [49139, 49176]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["point"]}], "extent": [49176, 49189], "body": [{"type": "para", "indent": 8, "text": ["No area shape."], "extent": [49189, 49221]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["line"]}], "extent": [49221, 49233], "body": [{"type": "para", "indent": 8, "text": ["Line light (unit line along x-axis)."], "extent": [49233, 49287]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["grid"]}], "extent": [49287, 49299], "body": [{"type": "para", "indent": 8, "text": ["Grid light (unit square in XY plane)."], "extent": [49299, 49354]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["disk"]}], "extent": [49354, 49366], "body": [{"type": "para", "indent": 8, "text": ["Circle shaped light (radius 0.5 in XY plane)."], "extent": [49366, 49429]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["sphere"]}], "extent": [49429, 49443], "body": [{"type": "para", "indent": 8, "text": ["Sphere shaped light (radius 0.5)."], "extent": [49443, 49494]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["environment"]}], "extent": [49494, 49513], "body": [{"type": "para", "indent": 8, "text": ["Sphere shaped light (infinite radius)."], "extent": [49513, 49561]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_areashape", "ifdprop": "light:areashape"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Area size"], "role": "item", "extent": [49561, 49574], "body": [{"type": "para", "indent": 4, "text": ["The size of the area light. The sizes are interpreted slightly differently for each shape."], "extent": [49628, 49728]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["line"]}], "extent": [49728, 49740], "body": [{"type": "para", "indent": 8, "text": ["Only the X size is used."], "extent": [49740, 49782]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["grid"]}], "extent": [49782, 49794], "body": [{"type": "para", "indent": 8, "text": ["The X & Y size of the grid."], "extent": [49794, 49839]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["disk"]}], "extent": [49839, 49851], "body": [{"type": "para", "indent": 8, "text": ["The X & Y radii of the circle."], "extent": [49851, 49899]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["sphere"]}], "extent": [49899, 49913], "body": [{"type": "para", "indent": 8, "text": ["The average of the sizes is used as the radius."], "extent": [49913, 49978]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["environment"]}], "extent": [49978, 49997], "body": [{"type": "para", "indent": 8, "text": ["Ignored."], "extent": [49997, 50015]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_areasize", "ifdprop": "light:areasize"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Area texture"], "role": "item", "extent": [50015, 50031], "body": [{"type": "para", "indent": 4, "text": ["Only used for the environment light. This specifies an environment map which is used for illuminating the scene. The map may be an HDRI map."], "extent": [50083, 50233]}, {"type": "para", "indent": 4, "text": ["See ", {"scheme": null, "value": "/render/envmaps", "type": "link", "text": ["how to create an environment/reflection map"], "fullpath": "/render/envmaps"}, "."], "extent": [50233, 50305]}], "container": true, "attrs": {"hprop": "vm_areamap", "ifdprop": "light:areamap"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Full sphere environment"], "role": "item", "extent": [50305, 50332], "body": [{"type": "para", "indent": 4, "text": ["For the environment light, whether the light source represents the full sphere or the upper hemisphere"], "extent": [50398, 50506]}], "container": true, "attrs": {"hprop": "vm_areafullsphere", "ifdprop": "light:areafullsphere"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Light importance levels"], "role": "item", "extent": [50506, 50533], "body": [{"type": "para", "indent": 4, "text": ["This parameter controls the resolution of the internally generated image used for environment map sampling.  The value is the logarithm of the image resolution in the x and y dimensions.  The default value of 8 produces a sampling image of resolution 256\u00d7256 pixels.  Larger values will produce a more accurate render when using high resolution environment maps for environment lighting, but may require additional memory and processing time during startup."], "extent": [50603, 51066]}], "container": true, "attrs": {"hprop": "vm_importancelevels", "ifdprop": "light:importancelevels"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Active radius"], "role": "item", "extent": [51066, 51083], "body": [{"type": "para", "indent": 4, "text": ["The active radius of the light source can be used to optimize renders. When illuminating a surface, only surfaces within the active radius will be considered."], "extent": [51145, 51309]}, {"type": "para", "indent": 4, "text": ["Example: Consider a car tunnel with lights every 10 meters. If the light has a sharp falloff, then it\u2019s possible to have thousands of lights and still render in a reasonable amount of time. No shaders will be run (neither the illumination nor the shadow shader)."], "extent": [51309, 51577]}], "container": true, "attrs": {"hprop": "vm_activeradius", "ifdprop": "light:activeradius"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Non diffuse light"], "role": "item", "extent": [51577, 51598], "body": [{"type": "para", "indent": 4, "text": ["When true, the light will not contribute to ", {"type": "code", "text": ["diffuse()"]}, " calls."], "extent": [51662, 51730]}], "container": true, "attrs": {"hprop": "vm_nondiffuse", "ifdprop": "light:__nondiffuse"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Non specular light"], "role": "item", "extent": [51730, 51752], "body": [{"type": "para", "indent": 4, "text": ["When true, the light will not contribute to ", {"type": "code", "text": ["specular()"]}, " calls."], "extent": [51818, 51887]}], "container": true, "attrs": {"hprop": "vm_nonspecular", "ifdprop": "light:__nonspecular"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Light stores cached illumination"], "role": "item", "extent": [51887, 51923], "body": [{"type": "para", "indent": 4, "text": ["Typically handled automatically during IFD generation.  A boolean indicating whether the light stores a cache (i.e. indirect and point cloud lights)."], "extent": [51981, 52136]}], "container": true, "attrs": {"hprop": "vm_lightcache", "ifdprop": "light:lightcache"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Ray tracing background"], "role": "item", "extent": [52136, 52162], "body": [{"type": "para", "indent": 4, "text": ["This is typically handled automatically for light sources.  It\u2019s set to true if the ", {"type": "code", "text": ["env_mode"]}, " parameter on environment light is set to ", {"type": "code", "text": ["background"]}, ".  That is, whether rays are traced against the environment light."], "extent": [52226, 52446]}], "container": true, "attrs": {"hprop": "vm_raybackground", "ifdprop": "light:raybackground"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Sun angle"], "role": "item", "extent": [52446, 52459], "body": [{"type": "para", "indent": 4, "text": ["This is typically handled automatically for Sun lights.  It is the solid angle (specified in degrees) used to sample the ", {"type": "q", "text": ["sun"]}, " light."], "extent": [52513, 52652]}], "container": true, "attrs": {"hprop": "vm_envangle", "ifdprop": "light:envangle"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["MIS Bias"], "role": "item", "extent": [52652, 52664], "body": [{"type": "para", "indent": 4, "text": ["Controls whether multiple importance sampling samples from the BSDF, the light, or both the BSDF and light."], "extent": [52688, 52805]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["-1"]}], "extent": [52805, 52815], "body": [{"type": "para", "indent": 8, "text": ["Sample only from the BSDF."], "extent": [52815, 52859]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["0"]}], "extent": [52859, 52868], "body": [{"type": "para", "indent": 8, "text": ["Sample from both the BSDF and the light."], "extent": [52868, 52926]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["1"]}], "extent": [52926, 52935], "body": [{"type": "para", "indent": 8, "text": ["Sample only from the light."], "extent": [52935, 52972]}], "container": true}], "container": true}, {"type": "para", "indent": 4, "text": ["The default ", {"type": "code", "text": ["vm_misbias"]}, " for area lights and environment lights with an\n    environment map is 0."], "extent": [52972, 53075]}, {"type": "para", "indent": 4, "text": ["Environment lights that have no environment map assigned will use a\n    default ", {"type": "code", "text": ["vm_misbias"]}, " of -1. This means that sampling will only use BSDF\n    samples for constant environment illumination - which can speed up\n    renders substantially in this situation. As soon as a map is assigned,\n    the MIS bias default is set back to 0. If you add the ", {"type": "code", "text": ["vm_misbias"]}, "\n    property it will always override the default."], "extent": [53075, 53491]}], "container": true, "attrs": {"hprop": "vm_misbias"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Limits"], "extent": [53768, 53781], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Opacity limit"], "role": "item", "extent": [53781, 53799], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/limits_tab/OpacityLimitDiagram.jpg", "type": "img", "text": ""}], "role": "item", "extent": [53861, 53932], "body": [{"type": "para", "indent": 8, "text": ["As a ray travels through many transparent surfaces, or through a volume, it will calculate the cumulative amount of Opacity. When this value exceeds the Opacity Limit mantra will assume all surfaces beyond this point are opaque."], "extent": [53932, 54178]}, {"type": "para", "indent": 8, "text": ["This parameter behaves in a similar fashion to both the Reflect and Refract Limit but operates on accumulated values rather than simply the number of surfaces the ray has passed through."], "extent": [54178, 54378]}], "container": true}, {"ext": null, "type": "fig", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/limits_tab/OpacityLimit.jpg", "type": "img", "text": ""}], "role": "item", "extent": [54378, 54447], "body": [{"type": "para", "indent": 8, "text": ["In this example, each grid has a shader attached with an opacity value of 0.1. It is important to remember that in this case \u201ctransparent\u201d refers to objects whose opacity is less than 100% and does not include refractive objects which can appear transparent."], "extent": [54447, 54719]}], "container": true}, {"ext": null, "type": "fig", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/limits_tab/OpacityVsRefract.jpg", "type": "img", "text": ""}], "role": "item", "extent": [54719, 54792], "body": [{"type": "para", "indent": 8, "text": ["In this example, the sphere of the left has an opacity of 0.5, with no refraction. The sphere on the right has an Opacity of 1 with refraction enabled. You can see that the Opacity Limit has no effect on the amount of refraction, only affecting objects whose opacity value is less than 1."], "extent": [54792, 55094]}, {"type": "para", "indent": 8, "text": ["While reducing the Opacity Limit may save a small amount of render time (1 \u2013 5%) using low values may result in banding and other artifacts when your camera is moving or an animation is evolving. This can be especially noticeable in smoke simulations where opacity values are constantly changing."], "extent": [55094, 55404]}], "container": true}, {"ext": null, "type": "fig", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/limits_tab/BadOpacityLimit.jpg", "type": "img", "text": ""}], "role": "item", "extent": [55404, 55476], "body": [{"type": "para", "indent": 8, "text": ["The default value for Opacity Limit is quite aggressive, changing this value should be done carefully and the results inspected across a range of frames in an animated sequence."], "extent": [55476, 55663]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"hprop": "vm_opacitylimit", "ifdprop": "image:opacitylimit"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Color limit"], "role": "item", "extent": [55663, 55678], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/limits_tab/ColorLimit.jpg", "type": "img", "text": ""}], "role": "item", "extent": [55736, 55803], "body": [{"type": "para", "indent": 8, "text": ["The maximum value a shading sample is allowed to return from indirect sources. When rendering using PBR the path\u2019s total illumination is also constrained."], "extent": [55803, 55971]}, {"type": "para", "indent": 8, "text": ["Physically Based Rendering can cause \u201cspikes\u201d in color values when extremely bright indirect light sources are under sampled. This results in \u201cfireflies\u201d in the final rendered image which can be very difficult to remove without very high sampling rates."], "extent": [55971, 56238]}], "container": true}, {"ext": null, "type": "fig", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/limits_tab/ColorLimitPixelSamples.jpg", "type": "img", "text": ""}], "role": "item", "extent": [56238, 56317], "body": [{"type": "para", "indent": 8, "text": ["You can see in this example that even at 12\u00d712 pixel samples, the \u201cfireflies\u201d still remain. Adjusting Min and Max indirect rays sample settings could remove this noise, but at the cost of longer render times."], "extent": [56317, 56539]}], "container": true}, {"ext": null, "type": "fig", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/limits_tab/ColorLimitCompare.jpg", "type": "img", "text": ""}], "role": "item", "extent": [56539, 56613], "body": [{"type": "para", "indent": 8, "text": ["Decreasing the Color Limit parameter clamps the color values in these indirect samples and can help to avoid these \u201cspikes\u201d."], "extent": [56613, 56751]}], "container": true}, {"ext": null, "type": "fig", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/limits_tab/ColorLimitCompareLight.jpg", "type": "img", "text": ""}], "role": "item", "extent": [56751, 56830], "body": [{"type": "para", "indent": 8, "text": ["Reducing the color Limit can be an effective way of removing \u201cfireflies\u201d without increasing sampling rates. However, clamping the values in indirect lighting can result in an overall reduction in the amount of light in your scene. This is especially evident in scenes which are mostly illuminated by indirect light."], "extent": [56830, 57155]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"hprop": "vm_colorlimit", "ifdprop": "image:colorlimit"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Color limit depth"], "role": "item", "extent": [57155, 57176], "body": [{"type": "para", "indent": 4, "text": ["This parameter controls the path depth beyond which Color Limit clamping is applied."], "extent": [57244, 57334]}], "container": true, "attrs": {"hprop": "vm_colorlimitdepth", "ifdprop": "image:colorlimitdepth"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Ray Unshaded limit"], "role": "item", "extent": [57334, 57356], "body": [{"type": "para", "indent": 4, "text": ["To improve efficiency when shading transparent objects, mantra will queue a number of transparent surfaces before shading.  This specifies the number of surfaces to queue.  This can have a dramatic effect on volume rendering for example."], "extent": [57423, 57666]}], "container": true, "attrs": {"hprop": "vm_unshadedlimit", "ifdprop": "renderer:unshadedlimit"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["At ray limit"], "role": "item", "extent": [57666, 57682], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/limits_tab/AtRayLimitCompare.jpg", "type": "img", "text": ""}], "role": "item", "extent": [57747, 57816], "body": [{"type": "para", "indent": 8, "text": ["Controls how Mantra deals with rays that reach the ray tracing limit (For example the ", {"type": "ui", "text": ["Reflect Limit"]}, " or ", {"type": "ui", "text": ["Refract Limit"]}, ")."], "extent": [57816, 57956]}, {"type": "para", "indent": 8, "text": ["In this example, the refract Limit has been set to 2."], "extent": [57956, 58023]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 4, "text": ["Setting At Ray Limit to ", {"type": "ui", "text": ["Use Black Background"]}, " will simply render black once the limits are reached. This is the default setting and will work in most scenes since the Reflect or Refract Limit is unlikely to be reached. However, in scenes where the limit is noticeable in the rendered image, the black color can be quite noticeable and stand out against the colors in the scene."], "extent": [58023, 58413]}, {"type": "para", "indent": 4, "text": ["In this case, increase the limit until the effect is avoided or use the ", {"type": "ui", "text": ["Use Direct Lighting as Background Color"]}, " option. This will replace the black color with whichever color or image is used in your direct lighting, for instance an Environment Light."], "extent": [58413, 58678]}, {"type": "para", "indent": 4, "text": ["For More Information about how the settings on an Environment Light affect this parameter see ", {"scheme": null, "value": "/render/lights", "type": "link", "text": ["lighting"], "fullpath": "/render/lights"}, "."], "extent": [58678, 58804]}], "container": true, "attrs": {"hprop": "vm_raylimiteval", "ifdprop": "renderer:raylimiteval"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Ray limit components"], "role": "item", "extent": [58804, 58828], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["At Ray Limit"]}, " is set to ", {"type": "ui", "text": ["Use Direct Lighting as Background Color"]}, ", direct lighting will be used for components in this list that have exceeded their limit. For example, if set to ", {"type": "code", "text": ["refract reflect"]}, " only rays that have exceeded the refract/reflect limits would use direct lighting."], "extent": [58905, 59200]}], "container": true, "attrs": {"hprop": "vm_raylimitcomponents", "ifdprop": "renderer:raylimitcomponents"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Ray limit light mask"], "role": "item", "extent": [59200, 59224], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["At Ray Limit"]}, " is set to ", {"type": "ui", "text": ["Use Direct Lighting as Background Color"]}, " this mask controls which lights contribute to direct lighting. "], "extent": [59299, 59448]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [59448, 59458], "body": [{"type": "para", "indent": 8, "text": ["This mask is intersected with lights affecting the material being shaded. Lights not found in both masks are ignored."], "extent": [59458, 59585]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"hprop": "vm_raylimitlightmask", "ifdprop": "renderer:raylimitlightmask"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Reflect limit"], "role": "item", "extent": [59585, 59602], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/limits_tab/ReflectLimit.jpg", "type": "img", "text": ""}], "role": "item", "extent": [59665, 59729], "body": [{"type": "para", "indent": 8, "text": ["The number of times a ray can be reflected in your scene."], "extent": [59729, 59800]}], "container": true}, {"ext": null, "type": "fig", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/limits_tab/ReflectSceneSetup.png", "type": "img", "text": ""}], "role": "item", "extent": [59800, 59874], "body": [{"type": "para", "indent": 8, "text": ["This example shows a classic \u201cHall of Mirrors\u201d scenario with the subject placed between two mirrors."], "extent": [59874, 59984]}], "container": true}, {"ext": null, "type": "fig", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/limits_tab/ReflectLimitCompare.jpg", "type": "img", "text": ""}], "role": "item", "extent": [59984, 60064], "body": [{"type": "para", "indent": 8, "text": ["This effectively creates an infinite series of reflections."], "extent": [60064, 60133]}], "container": true}, {"ext": null, "type": "fig", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/limits_tab/ReflectSubtleCompare.jpg", "type": "img", "text": ""}], "role": "item", "extent": [60133, 60210], "body": [{"type": "para", "indent": 8, "text": ["From this camera angle the reflection limits are very obvious and have a large impact on the accuracy of the final image. However, in most cases the reflection limit will be more subtle, allowing you to reduce the number of reflections in your scene and optimize the time it takes to render them."], "extent": [60210, 60520]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 4, "text": ["Remember that the first time a light source is reflected in an object, it is considered a direct reflection. Therefore, even with Reflect Limit set to 0, you will still see specular reflections of light sources."], "extent": [60520, 60741]}, {"type": "para", "indent": 4, "text": ["To control what happens when the maximum number of reflections is exceeded, use ", {"type": "ui", "text": ["At Ray Limit"]}, "."], "extent": [60741, 60844]}], "container": true, "attrs": {"hprop": "vm_reflectlimit", "ifdprop": "object:reflectlimit"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Refract limit"], "role": "item", "extent": [60844, 60861], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/limits_tab/RefractLimit.jpg", "type": "img", "text": ""}], "role": "item", "extent": [60924, 60997], "body": [{"type": "para", "indent": 8, "text": ["This parameter control the number of times a ray be refracted in your scene."], "extent": [60997, 61087]}], "container": true}, {"ext": null, "type": "fig", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/limits_tab/RefractSceneSetup.png", "type": "img", "text": ""}], "role": "item", "extent": [61087, 61161], "body": [{"type": "para", "indent": 8, "text": ["This example shows a simple scene with ten grids all in a row."], "extent": [61161, 61237]}], "container": true}, {"ext": null, "type": "fig", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/limits_tab/RefractLimitCompare.jpg", "type": "img", "text": ""}], "role": "item", "extent": [61237, 61313], "body": [{"type": "para", "indent": 8, "text": ["By applying a refractive shader, we will be able see through the grids to an image of a sunset in the background."], "extent": [61313, 61440]}], "container": true}, {"ext": null, "type": "fig", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/limits_tab/RefractSubtleCompare.jpg", "type": "img", "text": ""}], "role": "item", "extent": [61440, 61517], "body": [{"type": "para", "indent": 8, "text": ["From this camera angle, in order for the image to be accurate, the refraction limit must match the number of grids that that are in the scene. However, most scenes will not have this number of refractive objects all in a row and so it is possible to reduce the refract limit without affecting the final image while also reducing the time it takes to render them."], "extent": [61517, 61893]}], "container": true}, {"ext": null, "type": "fig", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/limits_tab/RefractLimitSurfaces.jpg", "type": "img", "text": ""}], "role": "item", "extent": [61893, 61970], "body": [{"type": "para", "indent": 8, "text": ["Keep in mind that this Refract Limit refers to the number of surfaces that the ray must travel through, not the number of objects."], "extent": [61970, 62114]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 4, "text": ["Remember that the first time a light source is refracted through a surface, it is considered a direct refraction. Therefore, even with Refract Limit set to 0, you will see refractions of Light Sources. However, since most objects in your scene will have at least two surfaces between it and the light source, direct refractions are often not evident in your final render."], "extent": [62114, 62495]}, {"type": "para", "indent": 4, "text": ["To control what happens when the maximum number of refraction is exceeded, use ", {"type": "ui", "text": ["At Ray Limit"]}, "."], "extent": [62495, 62597]}], "container": true, "attrs": {"hprop": "vm_refractlimit", "ifdprop": "object:refractlimit"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Diffuse limit"], "role": "item", "extent": [62597, 62614], "body": [{"type": "para", "indent": 4, "text": ["The number of times diffuse rays can propagate through your scene."], "extent": [62677, 62753]}, {"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/limits_tab/DiffuseLimit.jpg", "type": "img", "text": ""}], "role": "item", "extent": [62753, 62822]}], "container": true, "role": "item_group"}, {"type": "para", "indent": 4, "text": ["Unlike the Reflect and Refract Limits, this parameter will increase the overall amount of light in your scene and contribute to the majority of global illumination. With this parameter set above zero diffuse surfaces will accumulate light from other objects in addition to direct light sources."], "extent": [62822, 63126]}, {"type": "para", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/limits_tab/DiffuseLimitCompare.jpg", "type": "img", "text": ""}], "extent": [63126, 63197]}, {"type": "para", "indent": 4, "text": ["In this example, increasing the Diffuse Limit has a dramatic effect on the appearance of the final image. To replicate realistic lighting conditions, it is often necessary to increase the Diffuse Limit. However, since the amount of light contribution usually decreases with each diffuse bounce, increasing the Diffuse Limit beyond 4 does little to improve the visual fidelity of a scene. Additionally, increasing the Diffuse Limit can dramatically increase noise levels and render times."], "extent": [63197, 63694]}, {"type": "para", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/limits_tab/DiffuseSubtleCompare.jpg", "type": "img", "text": ""}], "extent": [63694, 63762]}], "container": true, "attrs": {"hprop": "vm_diffuselimit", "ifdprop": "object:diffuselimit"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["SSS limit"], "role": "item", "extent": [63762, 63775], "body": [{"type": "para", "indent": 4, "text": ["The number of times sub-surface scattering rays can propagate through your scene."], "extent": [63830, 63917]}], "container": true, "attrs": {"hprop": "vm_ssslimit", "ifdprop": "object:ssslimit"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Volume limit"], "role": "item", "extent": [63917, 63933], "body": [{"type": "para", "indent": 4, "text": ["The number of times a volumetric ray can propagate through a scene. It functions in a similar fashion to the ", {"type": "ui", "text": ["Diffuse Limit"]}, " parameter."], "extent": [63994, 64141]}, {"type": "para", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/limits_tab/VolumeLimit.jpg", "type": "img", "text": ""}], "extent": [64141, 64204]}, {"type": "para", "indent": 4, "text": ["Increasing the Volume Limit parameter will result in much more realistic volumetric effects. This is especially noticeable in situations where only part of a volume is receiving direct lighting. Also, in order for a volumetric object to receive indirect light from other objects, the Volume Limit parameter must be set above 0."], "extent": [64204, 64541]}, {"type": "para", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/limits_tab/VolumeLimitCompare.jpg", "type": "img", "text": ""}], "extent": [64541, 64611]}, {"type": "para", "indent": 4, "text": ["With the Volume Limit set to values above zero, the fog volume takes on the characteristic light scattering you would expect from light traveling through a volume. However, as with the Diffuse Limit, the light contribution generally decreases with each bounced ray and therefore using values above 4 does not necessarily result in a noticeably more realistic image."], "extent": [64611, 64986]}, {"type": "para", "indent": 4, "text": ["Also, increasing the value of this parameter can dramatically increase the amount of time spent rendering volumetric images."], "extent": [64986, 65116]}], "container": true, "attrs": {"hprop": "vm_volumelimit", "ifdprop": "object:volumelimit"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Contribution limit"], "role": "item", "extent": [65116, 65138], "body": [{"type": "para", "indent": 4, "text": ["As rays propagate through the scene, they contribute less and less to the final color of the surface. When the contribution becomes less than the ray weight, no further rays will be sent. This is similar to the ", {"type": "code", "text": ["renderer:opacitylimit"]}, ". ", {"type": "code", "text": ["vm_rayweight"]}, " will not affect volume renders."], "extent": [65195, 65483]}], "container": true, "attrs": {"hprop": "vm_rayweight", "ifdprop": "object:rayweight"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Stochastic Path Early Cut Off"], "role": "item", "extent": [65483, 65516], "body": [{"type": "para", "indent": 4, "text": ["Enables random early cut off of ray paths when path tracing.  This lets you increase overall path limits (i.e. the ", {"type": "ui", "text": ["Diffuse Limit"]}, ") while trading off a little stochastic noise for rendering efficiency."], "extent": [65577, 65786]}], "container": true, "attrs": {"hprop": "vm_pathcutoff", "ifdprop": "renderer:pathcutoff"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Cut Off Method"], "role": "item", "extent": [65786, 65804], "body": [{"type": "para", "indent": 4, "text": ["Controls the method used to determine for early cut off of ray paths."], "extent": [65877, 65956]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Probability"], "extent": [65956, 65973], "body": [{"type": "para", "indent": 8, "text": ["The chance for termination is determined by the ", {"type": "ui", "text": ["Cut Off Threshold"]}, " value."], "extent": [65973, 66058]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Albedo"], "extent": [66058, 66070], "body": [{"type": "para", "indent": 8, "text": ["The albedo of the surface at each bounce is used as the probability to cut short ray paths.  This means that darker surfaces will result in earlier cut off."], "extent": [66070, 66235]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Throughput"], "extent": [66235, 66251], "body": [{"type": "para", "indent": 8, "text": ["The path\u2019s combined throughput divided by the value of the ", {"type": "ui", "text": ["Cut Off Threshold"]}, " determines the probability."], "extent": [66251, 66369]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_pathcutoffmethod", "ifdprop": "renderer:pathcutoffmethod"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Cut Off Threshold"], "role": "item", "extent": [66369, 66390], "body": [{"type": "para", "indent": 4, "text": ["This value affects the probability that ray paths will be cut short.  Smaller values will cause paths to be cut off earlier (faster renders)."], "extent": [66463, 66610]}], "container": true, "attrs": {"hprop": "vm_pathcutoffthresh", "ifdprop": "renderer:pathcutoffthresh"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Cut Off Depth"], "role": "item", "extent": [66610, 66627], "body": [{"type": "para", "indent": 4, "text": ["This parameter specifies the minimum number of bounces that occur before paths can be cut off."], "extent": [66695, 66795]}], "container": true, "attrs": {"hprop": "vm_pathcutoffdepth", "ifdprop": "image:pathcutoffdepth"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Shading queue size"], "role": "item", "extent": [66795, 66817], "body": [], "container": true, "attrs": {"hprop": "vm_shadingqueuesize", "status": "nd"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Meta data"], "extent": [66866, 66882], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Save settings"], "role": "item", "extent": [66882, 66900], "body": [{"type": "para", "indent": 4, "text": ["A string containing a space-separated list of property values to save into the output ", {"type": "code", "text": [".rat"]}, "/", {"type": "code", "text": [".tbf"]}, " file (such as a texture or ", {"scheme": null, "value": "/render/lights", "type": "link", "text": ["deep shadow map"], "fullpath": "/render/lights"}, "). You can read the saved values out of a texture using the ", {"scheme": "Vex", "value": "/vex/functions/teximport", "type": "link", "text": "", "fallback_text": "teximport()", "fullpath": "/vex/functions/teximport"}, " VEX function in a shader."], "extent": [66964, 67234]}, {"type": "para", "indent": 4, "text": ["The defaults save mostly camera- and image-related properties, but you can save the value of any mantra property, such as ", {"type": "code", "text": ["renderer:version"]}, "."], "extent": [67234, 67381]}], "container": true, "attrs": {"hprop": "vm_saveoptions", "ifdprop": "image:saveoptions"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Artist"], "role": "item", "extent": [67381, 67391], "body": [{"type": "para", "indent": 4, "text": ["The name of the image creator. By default uses the current user\u2019s log in name."], "extent": [67420, 67504]}, {"type": "para", "indent": 4, "text": ["Houdini, TIFF, PNG formats"], "extent": [67504, 67540]}], "container": true, "attrs": {"hprop": "vm_image_artist"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Comment"], "role": "item", "extent": [67540, 67551], "body": [{"type": "para", "indent": 4, "text": ["A text comment to include in the output file."], "extent": [67585, 67640]}, {"type": "para", "indent": 4, "text": ["Houdini, OpenEXR, PNG formats"], "extent": [67640, 67679]}], "container": true, "attrs": {"hprop": "vm_image_comment"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Hostname"], "role": "item", "extent": [67679, 67691], "body": [{"type": "para", "indent": 4, "text": ["The name of the computer where this image was created."], "extent": [67726, 67786]}], "container": true, "attrs": {"hprop": "vm_image_hostname"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Enable EXR Post Processing"], "role": "item", "extent": [67786, 67816], "body": [{"type": "para", "indent": 4, "text": ["By default, after rendering an EXR image, Mantra will post-process the image to set the data window, render time, and other metadata. Turn this off to prevent Mantra from adding metadata to EXR images."], "extent": [67854, 68061]}], "container": true, "attrs": {"hprop": "vm_image_exr_postprocess"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Set EXR Data Window"], "role": "item", "extent": [68061, 68084], "body": [{"type": "para", "indent": 4, "text": ["After rendering an EXR image, Mantra will determine and record the rectangle of data whose values are above ", {"type": "ui", "text": ["EXR Data Window Threshold"]}, " in the image planes specified by ", {"type": "ui", "text": ["EXR Data Window Planes"]}, ", with an added padding of ", {"type": "ui", "text": ["EXR Data Window Padding"]}, " pixels on each side of the rectangle.  This is equivalent to running the ", {"type": "code", "text": ["iautocrop"]}, " program on the output image."], "extent": [68155, 68526]}], "container": true, "attrs": {"hprop": "vm_setexrdatawindow", "ifdprop": "global:setexrdatawindow"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["EXR Data Window Padding"], "role": "item", "extent": [68526, 68553], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Set EXR Data Window"]}, " is on, the number of pixels to expand the computed data window on each side. This can give a bit of padding around the data window, if it is needed for filtering purposes in another application."], "extent": [68638, 68867]}], "container": true, "attrs": {"hprop": "vm_exrdatawindowpadding", "ifdprop": "renderer:exrdatawindowpadding"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["EXR Data Window Threshold"], "role": "item", "extent": [68867, 68896], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Set EXR Data Window"]}, " is on, include all pixels in any planes specified by ", {"type": "ui", "text": ["EXR Data Window Planes"]}, " whose values are strictly greater than this value. For example, if the value is 0 and only the A plane is selected, the data window rectangle will include all pixels with opacity greater than zero."], "extent": [68985, 69297]}], "container": true, "attrs": {"hprop": "vm_exrdatawindowthreshold", "ifdprop": "renderer:exrdatawindowthreshold"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["EXR Data Window Planes"], "role": "item", "extent": [69297, 69323], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Set EXR Data Window"]}, " is on, include all pixels whose values are strictly greater than ", {"type": "ui", "text": ["EXR Data Window Threshold"]}, " in any of these image planes. This field supports wildcards and removals, like ", {"type": "code", "text": ["*"]}, ", to specify all planes, or ", {"type": "code", "text": ["diffuse* ^diffuse3"]}, ", to specify all planes whose names start with diffuse, except the diffuse3 plane."], "extent": [69406, 69748]}], "container": true, "attrs": {"hprop": "vm_exrdatawindowplanes", "ifdprop": "renderer:exrdatawindowplanes"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["TIFF compression"], "role": "item", "extent": [69748, 69768], "body": [{"type": "para", "indent": 4, "text": ["Type of image compression to use in TIFF files. Possible values are ", {"type": "code", "text": ["\"None\", \"LZW\", \"AdobeDeflate\", \"Deflate\", \"PackBits\", \"JPEG\", \"PixarLog\", \"SGILog\", \"SGILog24\""]}, "."], "extent": [69811, 69982]}], "container": true, "attrs": {"hprop": "vm_image_tiff_compression"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["TIFF predictor"], "role": "item", "extent": [69982, 70000], "body": [{"type": "para", "indent": 4, "text": ["Parameter to TIFF compressor. Leave this set to ", {"type": "q", "text": ["auto"]}, ". Possible values are ", {"type": "code", "text": ["\"auto\", \"none\", \"horizontal\""]}, "."], "extent": [70041, 70154]}], "container": true, "attrs": {"hprop": "vm_image_tiff_predictor"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["RAT compression"], "role": "item", "extent": [70154, 70173], "body": [{"type": "para", "indent": 4, "text": ["Type of image compression to use in RAT (Houdini texture) files. Possible values are ", {"type": "code", "text": ["\"deflate\", \"none\""]}, "."], "extent": [70215, 70326]}], "container": true, "attrs": {"hprop": "vm_image_rat_compression"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["RAT generate MIP maps"], "role": "item", "extent": [70326, 70351], "body": [{"type": "para", "indent": 4, "text": ["Enable generation of MIP MAPS when creating RAT files."], "extent": [70390, 70450]}], "container": true, "attrs": {"hprop": "vm_image_rat_makemips"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["JPEG quality"], "role": "item", "extent": [70450, 70466], "body": [{"type": "para", "indent": 4, "text": ["JPEG Quality, integer from ", {"type": "code", "text": ["10"]}, " to ", {"type": "code", "text": ["100"]}, "."], "extent": [70505, 70552]}], "container": true, "attrs": {"hprop": "vm_image_jpeg_quality"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Cineon color space"], "role": "item", "extent": [70552, 70574], "body": [{"type": "para", "indent": 4, "text": ["Color space for Cineon format images. Possible values are ", {"type": "code", "text": ["\"log\""]}, " (unconverted), and ", {"type": "code", "text": ["\"lin\""]}, " (linear)."], "extent": [70613, 70721]}], "container": true, "attrs": {"hprop": "vm_image_cineon_space"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Cineon LUT"], "role": "item", "extent": [70721, 70735], "body": [{"type": "para", "indent": 4, "text": ["Filename of a Look Up Table file to use for display of Cineon images in MPlay."], "extent": [70772, 70856]}], "container": true, "attrs": {"hprop": "vm_image_cineon_lut"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Cineon white point"], "role": "item", "extent": [70856, 70878], "body": [{"type": "para", "indent": 4, "text": ["White point for Cineon format images, integer from ", {"type": "code", "text": ["0"]}, " to ", {"type": "code", "text": ["1023"]}, ". The white-point of the image used during quantization.  Normally you should leave this parameter at the default value of 1 unless you wish to darken or lighten the image."], "extent": [70922, 71164]}], "container": true, "attrs": {"hprop": "vm_image_cineon_whitepoint"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Cineon gamma"], "role": "item", "extent": [71164, 71180], "body": [], "container": true, "attrs": {"hprop": "vm_image_cineon_gamma", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["EXR Compression"], "role": "item", "extent": [71231, 71250], "body": [{"type": "para", "indent": 4, "text": ["Compression type for EXR format images. Possible values are ", {"type": "code", "text": ["\"none\", \"rle\", \"zips\", \"zip\", \"piz\", \"pix\", \"b44\", \"b44a\", \"dwaa\", \"dwab\""]}, "."], "extent": [71292, 71434]}], "container": true, "attrs": {"hprop": "vm_image_exr_compression"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["DWA Compression Level"], "role": "item", "extent": [71434, 71459], "body": [{"type": "para", "indent": 4, "text": ["Sets the amount of compression to use with OpenEXR\u2019s DWAA or DWAB compression type. \n    Higher values result in better compression and faster reads, but lower quality."], "extent": [71499, 71673]}], "container": true, "attrs": {"hprop": "vm_image_exr_dwa_level"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["EXR Storage"], "role": "item", "extent": [71673, 71688], "body": [{"type": "para", "indent": 4, "text": ["Storage method for EXR format images. Possible values are ", {"type": "code", "text": ["\"scan\""]}, " (scanline) and ", {"type": "code", "text": ["\"tile\""]}, "."], "extent": [71726, 71823]}], "container": true, "attrs": {"hprop": "vm_image_exr_storage"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["EXR Attributes"], "role": "item", "extent": [71823, 71841], "body": [{"type": "para", "indent": 4, "text": ["Additional attributes to set on EXR format images. The string is interpreted as \n    a Python dictionary, such as ", {"type": "code", "text": ["{'int_attr':1, 'flt_attr':2.3, 'vec3_attr':(0,1,2), 'str_attr':'foo'}"]}, ".\n    Any values that cannot be parsed or isn\u2019t recognized, will be silently ignored. The set of Python\n    value types recognized for use as an EXR attributes are: ", {"type": "code", "text": ["bool"]}, ", ", {"type": "code", "text": ["int"]}, ", ", {"type": "code", "text": ["float"]}, ", ", {"type": "code", "text": ["string"]}, ", and\n    3-, 4-, 9-, 16-value ", {"type": "code", "text": ["tuple"]}, " and ", {"type": "code", "text": ["list"]}, " of ", {"type": "code", "text": ["float"]}, ". Due to lack of 4-value vector attributes in the\n    EXR format, the ", {"type": "code", "text": ["Box"]}, " type attribute is used instead."], "extent": [71882, 72441]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "text": [" "], "role": "item", "extent": [72441, 72452], "body": [{"type": "para", "indent": 8, "text": ["The standard attributes cannot be overridden by this attribute string."], "extent": [72452, 72532]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"hprop": "vm_image_exr_attributes"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["PNG premultiplied"], "role": "item", "extent": [72532, 72553], "body": [{"type": "para", "indent": 4, "text": ["How to interpret mantra\u2019s framebuffer when saving out PNG. Possible values are ", {"type": "code", "text": ["\"premult\""]}, " or ", {"type": "code", "text": ["\"unpremult\""]}, ". "], "extent": [72595, 72714]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [72714, 72724], "body": [{"type": "para", "indent": 8, "text": ["Mantra\u2019s framebuffer always stores colors premultiplied by alpha, whereas PNG expects unpremultiplied colors, so using the default setting of ", {"type": "code", "text": ["\"premult\""]}, ", it will correctly interpret the data and predivide RGB channels upon write. If set to ", {"type": "code", "text": ["\"unpremult\""]}, ", then it will assume that the alpha is unassociated and will not touch RGB channels. "], "extent": [72724, 73074]}, {"type": "para", "indent": 8, "text": ["The ", {"type": "code", "text": ["\"unpremult\""]}, " option may be used for storing certain effects losslessly (such as emission that\u2019s not tied to opacity and thus does not contribute to alpha), however keep in mind that it will be outside the PNG specification and will be interpreted incorrectly without user intervention."], "extent": [73074, 73374]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"hprop": "vm_image_png_frompremult"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["MPlay render mode"], "role": "item", "extent": [73374, 73395], "body": [{"type": "para", "indent": 4, "text": ["Controls how MPlay deals with new frames. Possible values are ", {"type": "code", "text": ["\"current\""]}, " (add rendered frames to MPlay\u2019s current sequence) or ", {"type": "code", "text": ["\"new\""]}, " (have MPlay start a new sequence)."], "extent": [73438, 73613]}], "container": true, "attrs": {"hprop": "vm_image_mplay_rendermode"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["MPlay frame mode"], "role": "item", "extent": [73613, 73633], "body": [{"type": "para", "indent": 4, "text": ["Controls how MPlay inserts new frames into the current sequence. Possible values are ", {"type": "code", "text": ["\"append\""]}, " (add new frames on to the end of the current sequence), or ", {"type": "code", "text": ["\"match\""]}, " (replace frames with the same number in the current sequence)."], "extent": [73675, 73908]}], "container": true, "attrs": {"hprop": "vm_image_mplay_framemode"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["MPlay background image"], "role": "item", "extent": [73908, 73934], "body": [{"type": "para", "indent": 4, "text": ["Sets the background image, which will appear behind the rendered image."], "extent": [73970, 74047]}], "container": true, "attrs": {"hprop": "vm_image_mplay_bgimage"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["MPlay session label"], "role": "item", "extent": [74047, 74070], "body": [{"type": "para", "indent": 4, "text": ["When rendering to MPlay, all Houdini sessions will send the output to the same MPlay flipbook. This can be problematic when running multiple Houdini sessions. The MPlay Label lets you specify a label for the MPlay associated with the output driver. Only renders which match the given label will be sent to that MPlay."], "extent": [74104, 74431]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Houdini Process ID"], "extent": [74431, 74455], "body": [{"type": "para", "indent": 8, "text": ["Uses the operating system process identifier so that the MPlay flipbook will only accept renders from that Houdini session."], "extent": [74455, 74588]}], "container": true}, {"type": "dt", "indent": 4, "text": ["HIP Name"], "extent": [74588, 74602], "body": [{"type": "para", "indent": 8, "text": ["Uses the ", {"type": "code", "text": ["$HIPNAME"]}, " variable so the MPlay will only accept renders from the running ", {"type": "code", "text": ["$HIP"]}, " file."], "extent": [74602, 74708]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Output Driver Name"], "extent": [74708, 74732], "body": [{"type": "para", "indent": 8, "text": ["The MPlay flipbook will only accept renders from the given output driver. For example, if you copy paste the output driver, each output driver will be sent to different MPlay flipbooks because the operators will have different names. "], "extent": [74732, 74988]}, {"type": "para", "indent": 8, "text": ["If there are multiple Houdini sessions, there may be output drivers in the other session which match the same operator name."], "extent": [74988, 75122]}, {"type": "para", "indent": 8, "text": ["For example, say you have two output drivers: ", {"type": "q", "text": ["High quality"]}, " and ", {"type": "q", "text": ["Low Quality"]}, ". If you set the MPlay Label to different values for the two output drivers, each render will be sent to different MPlay sessions."], "extent": [75122, 75340]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_image_mplay_label"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["MPlay remote host"], "role": "item", "extent": [75340, 75361], "body": [], "container": true, "attrs": {"hprop": "vm_image_mplay_sockethost", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["MPlay remote host port"], "role": "item", "extent": [75416, 75442], "body": [], "container": true, "attrs": {"hprop": "vm_image_mplay_socketport", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["MPlay tile order"], "role": "item", "extent": [75497, 75517], "body": [{"type": "para", "indent": 4, "text": ["The direction in which MPlay renders the image. Possible values are ", {"type": "code", "text": ["\"middle\""]}, " (middle out), ", {"type": "code", "text": ["\"top\""]}, " (top down), or ", {"type": "code", "text": ["\"bottom\""]}, " (bottom up)."], "extent": [75559, 75704]}], "container": true, "attrs": {"hprop": "vm_image_mplay_direction"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["MPlay gamma"], "role": "item", "extent": [75704, 75719], "body": [{"type": "para", "indent": 4, "text": ["Display gamma for MPlay, from ", {"type": "code", "text": ["0.0"]}, " to ", {"type": "code", "text": ["4.0"]}, "."], "extent": [75757, 75808]}], "container": true, "attrs": {"hprop": "vm_image_mplay_gamma"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["MPlay display LUT"], "role": "item", "extent": [75808, 75829], "body": [{"type": "para", "indent": 4, "text": ["Filename of a Look Up Table file for MPlay."], "extent": [75865, 75914]}], "container": true, "attrs": {"hprop": "vm_image_mplay_lut"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Objects"], "extent": [75914, 75928], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Force headlight creation"], "role": "item", "extent": [75928, 75957], "body": [], "container": true, "attrs": {"hprop": "soho_forceheadlight", "status": "nd"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Output"], "extent": [76006, 76019], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Output picture"], "role": "item", "extent": [76019, 76038], "body": [{"type": "para", "indent": 4, "text": ["The image or device where the resulting image will be rendered. You can set this value to ", {"type": "code", "text": ["ip"]}, " which renders the image in MPlay, or you can save it to an image. The following image types are supported: ", {"type": "code", "text": [".pic"]}, ", ", {"type": "code", "text": [".tif"]}, ", ", {"type": "code", "text": [".sgi"]}, ", ", {"type": "code", "text": [".pic.gz"]}, ", ", {"type": "code", "text": [".rat"]}, ", ", {"type": "code", "text": [".jpg"]}, ", ", {"type": "code", "text": [".cin"]}, ", ", {"type": "code", "text": [".rta"]}, ", ", {"type": "code", "text": [".bmp"]}, ", ", {"type": "code", "text": [".tga"]}, ", ", {"type": "code", "text": [".rad"]}, ", ", {"type": "code", "text": [".exr"]}, ", and ", {"type": "code", "text": [".png"]}, "."], "extent": [76095, 76417]}, {"type": "para", "indent": 4, "text": ["Include ", {"type": "code", "text": ["$F"]}, " in the file name to insert the frame number. This is necessary when rendering animation. See ", {"scheme": null, "value": "/render/expressions", "type": "link", "text": ["expressions in file names"], "fullpath": "/render/expressions"}, " for more information."], "extent": [76417, 76598]}], "container": true, "attrs": {"hprop": "vm_picture", "ifdprop": "image:filename"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Output device"], "role": "item", "extent": [76598, 76615], "body": [{"type": "para", "indent": 4, "text": ["The image format or device for the output image.  If you leave this at the default value of ", {"type": "ui", "text": ["Infer from filename"]}, ", the image format will be selected based on the file extension (eg. .pic will automatically generate a Houdini format image.)"], "extent": [76669, 76916]}], "container": true, "attrs": {"hprop": "vm_device", "ifdprop": "image:device"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Skip Rendered Frames"], "role": "item", "extent": [76916, 76940], "body": [{"type": "para", "indent": 4, "text": ["Determine how the output driver should deal with existing rendered frames."], "extent": [76969, 77053]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["no"]}], "extent": [77053, 77063], "body": [{"type": "para", "indent": 8, "text": ["Overwrite any existing files."], "extent": [77063, 77110]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["exist:vm_picture"]}], "extent": [77110, 77134], "body": [{"type": "para", "indent": 8, "text": ["Skip rendering when a disk file already exists."], "extent": [77134, 77199]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["valid:vm_picture"]}], "extent": [77199, 77223], "body": [{"type": "para", "indent": 8, "text": ["Skip rendering only when the disk file that exists is a valid image file."], "extent": [77223, 77314]}], "container": true}], "container": true}, {"type": "para", "indent": 4, "text": ["This parameter checks only the main image, not any deep raster or secondary images."], "extent": [77314, 77403]}], "container": true, "attrs": {"hprop": "soho_skip_frame"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Sample filter"], "role": "item", "extent": [77403, 77420], "body": [{"type": "para", "indent": 4, "text": ["Controls how transparent samples are combined to produce the color values for individual pixel samples. The sample filter is used to composite transparent surfaces before the pixel filter produces final pixel colors."], "extent": [77476, 77702]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Opacity Filtering (", {"type": "code", "text": ["alpha"]}, ")"], "extent": [77702, 77735], "body": [{"type": "para", "indent": 8, "text": ["Uses the opacity (Of) values for transparent samples for compositing. This option should be used whenever correct transparent compositing is required. For example, when rendering volumes, sprites, or transparency."], "extent": [77735, 77958]}], "container": true}], "container": true}, {"type": "para", "indent": 4, "text": ["Full Opacity Filtering (", {"type": "code", "text": ["fullopacity"]}, "):\n    When stochastic transparency is enabled, this option causes a channel to be evaluated and composited with every opacity evaluation - as opposed to only being composited with the samples that are selected for full shading.  It can be used to produce smoother results for channels that are fast to evaluate such as ", {"type": "code", "text": ["Ce"]}, " or ", {"type": "code", "text": ["direct_emission"]}, ".  When stochastic transparency is disabled, this option behaves the same way as ", {"type": "ui", "text": ["Opacity Filtering"]}, "."], "extent": [77958, 78449]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Closest Surface (", {"type": "code", "text": ["closest"]}, ")"], "extent": [78449, 78482], "body": [{"type": "para", "indent": 8, "text": ["Ignores the opacity values and just copies the color for the closest transparent sample into the image. This option disables transparency for a given deep raster plane and will only produce the closest sample results."], "extent": [78482, 78717]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_sfilter", "ifdprop": "plane:sfilter"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Pixel filter"], "role": "item", "extent": [78717, 78733], "body": [{"type": "para", "indent": 4, "text": ["Specifies the pixel filter used to combine sub-pixel samples to generate the value for the single pixel.  The filter is normally specified as a filter type (eg. ", {"type": "code", "text": ["gauss"]}, ") followed by an x and y filter width in pixels.  To blur the image, increase the filter width."], "extent": [78789, 79058]}, {"type": "para", "indent": 4, "text": ["There are several different pixel filters available."], "extent": [79058, 79116]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["minmax ", {"type": "var", "text": ["style"]}]}], "extent": [79116, 79140], "body": [{"type": "para", "indent": 0, "text": ["The style may be one of:"], "extent": [16, 42]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "code", "text": ["min"]}, " \u2013 Choose the value of the sample with the smallest z value (closest to camera)."], "extent": [42, 132]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "code", "text": ["max"]}, " \u2013 Choose the value of the sample with the maximum z value (farthest from camera)."], "extent": [132, 224]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "code", "text": ["median"]}, " \u2013 Choose the value of the sample that has the median z value of all samples."], "extent": [224, 314]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "code", "text": ["edge"]}, " \u2013 Filter using a unit box but only averages samples with object coverage.  This filter will have the effect of disabling external edge antialiasing."], "extent": [314, 474]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "code", "text": ["ocover"]}, " \u2013 First, choose the object which covers most of the pixel, then take the average value from the sub-pixels of that object only.  This filter is similar to ", {"type": "code", "text": ["edge"]}, " but it also disables internal edge antialiasing between object boundaries."], "extent": [474, 724]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "code", "text": ["idcover"]}, " \u2013 First, choose the object which covers most of the pixel, then select a single sample from that object for the pixel value.  This filter is similar to ", {"type": "code", "text": ["ocover"]}, " but it will not average any samples.  Use this filter mode for planes that will be interpreted as integers, such as object or primitive identifiers.  The sample chosen will be unordered."], "extent": [724, 1086]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "code", "text": ["omin"]}, " \u2013 First, choose the object which covers most of the pixel, then choose a single sample from that object for the pixel value.  Chooses the sample with the smallest z value (closest to camera)."], "extent": [1086, 1289]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "code", "text": ["omax"]}, " \u2013 First, choose the object which covers most of the pixel, then choose a single sample from that object for the pixel value.  Chooses the sample with the maximum z value (farthest)."], "extent": [1289, 1482]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "code", "text": ["omedian"]}, " \u2013 First, choose the object which covers most of the pixel, then choose a single sample from that object for the pixel value.  Chooses the sample with the median z value."], "extent": [1482, 1665]}], "container": true}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["point"]}], "extent": [79178, 79191], "body": [{"type": "para", "indent": 8, "text": ["Choose the sub-pixel closest to the center of the pixel."], "extent": [79191, 79265]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["box [", {"type": "var", "text": ["width"]}, " ", {"type": "var", "text": ["height"]}, "]"]}], "extent": [79265, 79299], "body": [{"type": "para", "indent": 8, "text": ["Use a box filter to combine the sub-pixels with a filter size given by width/height."], "extent": [79299, 79401]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["gaussian [", {"type": "var", "text": ["width"]}, " ", {"type": "var", "text": ["height"]}, "]"]}], "extent": [79401, 79440], "body": [{"type": "para", "indent": 8, "text": ["Use a Gaussian filter to combine the sub-pixels with a filter size given by width/height."], "extent": [79440, 79547]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["bartlett [", {"type": "var", "text": ["width"]}, " ", {"type": "var", "text": ["height"]}, "]"]}], "extent": [79547, 79586], "body": [{"type": "para", "indent": 8, "text": ["Use a Bartlett (cone)  filter to combine the sub-pixels with a size width given by width/height."], "extent": [79586, 79700]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["blackman [", {"type": "var", "text": ["width"]}, " ", {"type": "var", "text": ["height"]}, "]"]}], "extent": [79700, 79739], "body": [{"type": "para", "indent": 8, "text": ["Use a Blackman filter to combine the sub-pixels with a filter size given by width/height."], "extent": [79739, 79846]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["catrom [", {"type": "var", "text": ["width"]}, " ", {"type": "var", "text": ["height"]}, "]"]}], "extent": [79846, 79883], "body": [{"type": "para", "indent": 8, "text": ["Use a Catmull-Rom filter to combine the sub-pixels with a size width given by width/height."], "extent": [79883, 79992]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["hanning [", {"type": "var", "text": ["width"]}, " ", {"type": "var", "text": ["height"]}, "]"]}], "extent": [79992, 80030], "body": [{"type": "para", "indent": 8, "text": ["Use a Hanning filter to combine the sub-pixels with a filter size given by width/height."], "extent": [80030, 80136]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["mitchell [", {"type": "var", "text": ["width"]}, " ", {"type": "var", "text": ["height"]}, "]"]}], "extent": [80136, 80175], "body": [{"type": "para", "indent": 8, "text": ["Use a Mitchell filter to combine the sub-pixels with a filter size given by width/height."], "extent": [80175, 80282]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["sinc [", {"type": "var", "text": ["width"]}, " ", {"type": "var", "text": ["height"]}, "]"]}], "extent": [80282, 80317], "body": [{"type": "para", "indent": 8, "text": ["Use a sinc filter to combine the sub-pixels with a filter size given by width/height."], "extent": [80317, 80420]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["edgedetect"]}], "extent": [80420, 80438], "body": [{"type": "para", "indent": 8, "text": ["Use an edge detection filter to find edges based on z-depth, object boundaries, and color gradients."], "extent": [80438, 80556]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["combine -t ", {"type": "var", "text": ["tolerance"]}]}], "extent": [80556, 80588], "body": [{"type": "para", "indent": 8, "text": ["Use a Ray Histogram Fusion-based filter to combine the sub-pixels with the given similarity tolerance."], "extent": [80588, 80708]}, {"type": "note_group", "body": [{"type": "note", "indent": 8, "role": "item", "extent": [80708, 80722], "body": [{"type": "para", "indent": 12, "text": ["This option is very slow and may eliminate some noise in an image, even if the noise is supposed to be there (ie, not just noise due to undersampling), resulting in loss of detail. "], "extent": [80722, 80921]}], "container": true}], "container": true, "role": "item_group"}], "container": true}], "container": true}, {"type": "para", "indent": 4, "text": [{"type": "code", "text": ["denoise optix [-a ", {"type": "var", "text": ["AOV"]}, "]"]}], "extent": [80921, 80954], "body": [{"type": "para", "indent": 8, "text": ["Apply the ", {"scheme": null, "value": "/render/optixdenoiser", "type": "link", "text": ["NVIDIA OptiX denoiser"], "fullpath": "/render/optixdenoiser"}, ", if it is installed. The ", {"type": "code", "text": ["-a"]}, " option specifies which image plane to use as the albedo input."], "extent": [80954, 81112]}], "container": true}], "container": true, "attrs": {"hprop": "vm_pfilter", "ifdprop": "plane:pfilter"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Gamma"], "role": "item", "extent": [81112, 81121], "body": [], "container": true, "attrs": {"hprop": "vm_gamma", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Gain"], "role": "item", "extent": [81159, 81167], "body": [], "container": true, "attrs": {"hprop": "vm_gain", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Dither"], "role": "item", "extent": [81204, 81214], "body": [{"type": "para", "indent": 4, "text": ["Dither amount for the image plane."], "extent": [81268, 81308]}], "container": true, "attrs": {"hprop": "vm_dither", "ifdprop": "plane:dither"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Quantization"], "role": "item", "extent": [81308, 81324], "body": [{"type": "para", "indent": 4, "text": ["The storage type for the main image.  The type of quantization used will affect image quality and size.  If you need to adjust the image\u2019s dynamic range in compositing, you should normally leave this value at the default of 16-bit floating point."], "extent": [81349, 81605]}, {"type": "para", "indent": 4, "text": ["The default is ", {"type": "code", "text": ["\"float16\""]}, " for the first plane, and ", {"type": "code", "text": ["\"float\""]}, " for secondary planes. You can override the first plane\u2019s value with the ", {"type": "code", "text": ["-b"]}, " command line argument to mantra."], "extent": [81605, 81782]}], "container": true, "attrs": {"hprop": "vm_quantize"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["White point"], "role": "item", "extent": [81782, 81797], "body": [{"type": "para", "indent": 4, "text": ["White point for the image plane."], "extent": [81859, 81897]}], "container": true, "attrs": {"hprop": "vm_whitepoint", "ifdprop": "plane:whitepoint"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Override camera resolution"], "role": "item", "extent": [81897, 81927], "body": [{"type": "para", "indent": 4, "text": ["Normally the image resolution is set on the camera object. Turn this on to enable controls that modify or override the camera\u2019s settings."], "extent": [81963, 82106]}], "container": true, "attrs": {"hprop": "override_camerares"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Resolution override"], "role": "item", "extent": [82106, 82129], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Override camera resolution"]}, " is on and ", {"type": "ui", "text": ["Resolution scale"]}, " is ", {"type": "q", "text": ["User specified resolution"]}, ", lets you set the resolution of the output image, overriding the settings on the camera."], "extent": [82159, 82351]}], "container": true, "attrs": {"hprop": "res_override"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Choose resolution"], "role": "item", "extent": [82351, 82372], "body": [], "container": true, "attrs": {"hprop": "res_overrideMenu", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Resolution scale"], "role": "item", "extent": [82418, 82438], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Override camera resolution"]}, " is on, allows you to scale whatever resolution is set on the camera. To completely override the camera\u2019s resolution, choose ", {"type": "q", "text": ["User specified resolution"]}, "."], "extent": [82468, 82662]}], "container": true, "attrs": {"hprop": "res_fraction"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Pixel Aspect Ratio"], "role": "item", "extent": [82662, 82684], "body": [{"type": "para", "indent": 4, "text": ["The pixel aspect ratio represents the width of a pixel divided by the height of a pixel. It is not the aspect ratio of the image (which is determined by the resolution of the image). This parameter does not affect rendering, it is only used to change how images are displayed, by stretching the pixels by this factor."], "extent": [82717, 83040]}], "container": true, "attrs": {"hprop": "aspect_override"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Tiled render"], "role": "item", "extent": [83040, 83056], "body": [{"type": "para", "indent": 4, "text": ["When you render a target node with this option on using HQueue, the server will split frames to render into separate tiles and render each tile as a separate job. When you render locally with this option on, Mantra will render a single tile instead of the entire frame."], "extent": [83088, 83363]}, {"type": "para", "indent": 4, "text": ["Tiled render can also be enabled using ", {"type": "code", "text": ["-t"]}, " command line option to mantra, which can be used to render a tile locally without having to generate an IFD for each tile with ", {"type": "ui", "text": ["Tiled render"]}, " enabled."], "extent": [83363, 83565]}], "container": true, "attrs": {"hprop": "vm_tile_render"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Horizontal tiles"], "role": "item", "extent": [83565, 83585], "body": [{"type": "para", "indent": 4, "text": ["Split the frame into this number of tiles horizontally, when ", {"type": "ui", "text": ["Tile render"]}, " is on."], "extent": [83655, 83744]}], "container": true, "attrs": {"hprop": "vm_tile_count_x", "ifdprop": "image:tiledrendercount"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Vertical tiles"], "role": "item", "extent": [83744, 83762], "body": [{"type": "para", "indent": 4, "text": ["Split the frame into this number of tiles vertically, when ", {"type": "ui", "text": ["Tile render"]}, " is on."], "extent": [83832, 83919]}], "container": true, "attrs": {"hprop": "vm_tile_count_y", "ifdprop": "image:tiledrendercount"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Tile index"], "role": "item", "extent": [83919, 83933], "body": [{"type": "para", "indent": 4, "text": ["Which tile to render, when rendering locally with ", {"type": "ui", "text": ["Tile render"]}, " on. Tile numbers start at 0 in the top left and increase left to right, top to bottom."], "extent": [84001, 84163]}], "container": true, "attrs": {"hprop": "vm_tile_index", "ifdprop": "image:tiledrenderindex"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Output Checkpoint Files"], "role": "item", "extent": [84163, 84190], "body": [{"type": "para", "indent": 4, "text": ["When enabled, image tile data will be frequently written out to a checkpoint file in the same directory as the output file.  If the process is terminated before completing the render, it can then be resumed by turning on ", {"type": "ui", "text": ["Resume from Checkpoint Files"]}, " and restarting.  To specify an alternative checkpoint file name, enable __Checkpoint File Name___."], "extent": [84262, 84624]}, {"type": "warning_group", "body": [{"type": "warning", "indent": 4, "role": "item", "extent": [84624, 84637], "body": [{"type": "para", "indent": 8, "text": ["Checkpointing does not work when creating a deep shadow map or deep camera map."], "extent": [84637, 84730]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 4, "text": ["The checkpoint file will be deleted if the render completes successfully."], "extent": [84730, 84809]}], "container": true, "attrs": {"hprop": "vm_writecheckpoint", "ifdprop": "image:writecheckpoint"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Resume from Checkpoint Files"], "role": "item", "extent": [84809, 84841], "body": [{"type": "para", "indent": 4, "text": ["When enabled, before rendering, Mantra will look for a checkpoint file corresponding with the current output file, generated by a previous partial render that had ", {"type": "ui", "text": ["Output Checkpoint Files"]}, " enabled.  If possible, Mantra will only render areas that are needed for remaining regions of the output image.  To specify an alternative checkpoint file name, enable __Checkpoint File Name___."], "extent": [84911, 85306]}, {"type": "para", "indent": 4, "text": ["If both ", {"type": "ui", "text": ["Output Checkpoint Files"]}, " and ", {"type": "ui", "text": ["Resume from Checkpoint Files"]}, " are enabled and a valid checkpoint file is loaded, any additional image tile data rendered will be appended to the checkpoint file."], "extent": [85306, 85516]}], "container": true, "attrs": {"hprop": "vm_readcheckpoint", "ifdprop": "image:readcheckpoint"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Override Checkpoint File Name"], "role": "item", "extent": [85516, 85549], "body": [{"type": "para", "indent": 4, "text": ["When enabled, checkpoint files used by ", {"type": "ui", "text": ["Output Checkpoint Files"]}, " and ", {"type": "ui", "text": ["Resume from Checkpoint Files"]}, " will be named based on ", {"type": "ui", "text": ["Checkpoint File Name"]}, "."], "extent": [85635, 85793]}], "container": true, "attrs": {"hprop": "vm_overridecheckpointname", "ifdprop": "image:overridecheckpointname"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Checkpoint File Name"], "role": "item", "extent": [85793, 85817], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Override Checkpoint File Name"]}, " is enabled, this specifies the names for checkpoint files used by ", {"type": "ui", "text": ["Output Checkpoint Files"]}, " and ", {"type": "ui", "text": ["Resume from Checkpoint Files"]}, ".  It can contain expressions."], "extent": [85887, 86092]}], "container": true, "attrs": {"hprop": "vm_checkpointname", "ifdprop": "image:checkpointname"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Checkpoint Cache Size (MB)"], "role": "item", "extent": [86092, 86122], "body": [{"type": "para", "indent": 4, "text": ["When the amount of data queued to write to a checkpoint file reaches this many megabytes, the data will be flushed to the checkpoint file, even if it has been less than ", {"type": "ui", "text": ["Checkpoint Period"]}, " seconds since the last write."], "extent": [86202, 86428]}], "container": true, "attrs": {"hprop": "vm_checkpointcachesize", "ifdprop": "image:checkpointcachesize"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Checkpoint Period (s)"], "role": "item", "extent": [86428, 86453], "body": [{"type": "para", "indent": 4, "text": ["When a render tile completes and it has been at least this many seconds since the last write to the checkpoint file, the data will be flushed to the checkpoint file, even if it is less than ", {"type": "ui", "text": ["Checkpoint Cache Size"]}, " megabytes of data."], "extent": [86527, 86767]}], "container": true, "attrs": {"hprop": "vm_checkpointperiod", "ifdprop": "image:checkpointperiod"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Tile suffix"], "role": "item", "extent": [86767, 86782], "body": [], "container": true, "attrs": {"hprop": "vm_tile_filename_suffix", "ifdprop": "image:tiledrendersuffix", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Sub-pixel output"], "role": "item", "extent": [86873, 86893], "body": [{"type": "para", "indent": 4, "text": ["Normally, sub-pixel samples are filtered using the pixel filter defined on an image plane. When this is turned on, each sub-pixel is output without any pixel filtering performed. "], "extent": [86947, 87132]}, {"type": "para", "indent": 4, "text": ["The ", {"type": "code", "text": ["image:resolution"]}, " property will be scaled by the ", {"type": "code", "text": ["image:samples"]}, " property to determine the actual output image resolution. For example, if ", {"type": "code", "text": ["image:resolution"]}, " was ", {"type": "code", "text": ["(1024,512)"]}, " and ", {"type": "code", "text": ["image:samples"]}, " was ", {"type": "code", "text": ["(4,6)"]}, ", the image rendered would have a resolution of 4096 by 3072. Each pixel would represent a single unfiltered sub-pixel sample."], "extent": [87132, 87475]}], "container": true, "attrs": {"hprop": "vm_subpixel", "ifdprop": "image:subpixel"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Disable rendering to MPlay"], "role": "item", "extent": [87475, 87505], "body": [], "container": true, "attrs": {"hprop": "vm_imagebatchmode", "ifdprop": "image:batchmode", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Video field"], "role": "item", "extent": [87582, 87597], "body": [], "container": true, "attrs": {"hprop": "vm_field"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Create image from viewing camera"], "role": "item", "extent": [87619, 87655], "body": [{"type": "para", "indent": 4, "text": ["Renders an image from the viewing camera. Sometimes, it is useful to skip this render, for example, when rendering shadow maps."], "extent": [87690, 87823]}], "container": true, "attrs": {"hprop": "render_viewcamera"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Auto-generate shadow maps"], "role": "item", "extent": [87823, 87852], "body": [{"type": "para", "indent": 4, "text": ["Enable or disable shadow map generation. Each light also has its own controls to determine whether shadow maps will be generated."], "extent": [87890, 88025]}], "container": true, "attrs": {"hprop": "render_any_shadowmap"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Auto-generate environment maps"], "role": "item", "extent": [88025, 88059], "body": [{"type": "para", "indent": 4, "text": ["Enable or disable environment map generation. Each object can be set up to generate an environment map of all the other objects in the scene."], "extent": [88094, 88241]}], "container": true, "attrs": {"hprop": "render_any_envmap"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Auto-generate photon maps"], "role": "item", "extent": [88241, 88270], "body": [{"type": "para", "indent": 4, "text": ["Enable or disable photon map generation."], "extent": [88308, 88354]}], "container": true, "attrs": {"hprop": "render_any_photonmap"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Auto-generate light point clouds"], "role": "item", "extent": [88354, 88390], "body": [], "container": true, "attrs": {"hprop": "render_any_pointcloud", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Auto-generate shadow map"], "role": "item", "extent": [88441, 88469], "body": [], "container": true, "attrs": {"hprop": "render_shadowmap", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Auto-generate environment map"], "role": "item", "extent": [88515, 88548], "body": [], "container": true, "attrs": {"hprop": "render_envmap", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Auto-generate photon map"], "role": "item", "extent": [88591, 88619], "body": [], "container": true, "attrs": {"hprop": "render_photonmap", "status": "nd"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["PBR"], "extent": [88665, 88675], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["PBR shader"], "role": "item", "extent": [88675, 88690], "body": [{"type": "para", "indent": 4, "text": ["The shader used to evaluate samples for the PBR rendering engine. If no shader is specified, the default VEX Pathtracer shader is used.  Normally you should not need to assign a shader for this parameter unless you are a shader writer and need to make adjustments to the PBR shading algorithm."], "extent": [88753, 89052]}], "container": true, "attrs": {"hprop": "vm_pbrshader", "ifdprop": "renderer:pbrshader"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Photon"], "extent": [89052, 89065], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Photon storage count"], "role": "item", "extent": [89065, 89090], "body": [{"type": "para", "indent": 4, "text": ["The number of photons sent when ", {"type": "code", "text": ["renderer:renderengine"]}, " is set to ", {"type": "q", "text": ["photon"]}, "."], "extent": [89151, 89232]}], "container": true, "attrs": {"hprop": "vm_photoncount", "ifdprop": "photon:photoncount"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Minimum photon storage ratio"], "role": "item", "extent": [89232, 89264], "body": [{"type": "para", "indent": 4, "text": ["Add this property to control the minimum photon acceptance ratio. This parameter is a value between 0 and 1 to control the minimum proportion of photons sent that must be stored before mantra will bail out on photon generation from that light."], "extent": [89333, 89582]}], "container": true, "attrs": {"hprop": "vm_photonminratio", "ifdprop": "renderer:photonminratio"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Global photon file"], "role": "item", "extent": [89582, 89604], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "code", "text": ["renderer:renderengine"]}, " is ", {"type": "q", "text": ["photon"]}, ", this determines the photon map file for diffuse photons (irradiance)."], "extent": [89665, 89782]}], "container": true, "attrs": {"hprop": "vm_photongfile", "ifdprop": "photon:photongfile"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Caustic photon file"], "role": "item", "extent": [89782, 89805], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "code", "text": ["renderer:renderengine"]}, " is ", {"type": "q", "text": ["photon"]}, ", this determines the photon map file for caustic photons (specular bounces)."], "extent": [89866, 89989]}], "container": true, "attrs": {"hprop": "vm_photoncfile", "ifdprop": "photon:photoncfile"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Photon target"], "role": "item", "extent": [89989, 90006], "body": [{"type": "para", "indent": 4, "text": ["When sending photons from this light source, this is the category expression to determine which objects will receive photons."], "extent": [90068, 90199]}], "container": true, "attrs": {"hprop": "vm_photontarget", "ifdprop": "light:photontarget"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Photon weight"], "role": "item", "extent": [90199, 90216], "body": [{"type": "para", "indent": 4, "text": ["Controls the proportion of photons that should be generated by this light relative to other lights in the scene.  By default, all lights have an equal weight of 1."], "extent": [90278, 90447]}], "container": true, "attrs": {"hprop": "vm_photonweight", "ifdprop": "light:photonweight"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Photon modifier"], "role": "item", "extent": [90447, 90466], "body": [{"type": "para", "indent": 4, "text": ["Affects the way that photons are traced through the scene. When a photon hits a surface the parameter affects it depending on the selected option. This is only used if the scene has a light (such as the GI Light) that uses photon mapping."], "extent": [90533, 90777]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["None"], "extent": [90777, 90787], "body": [{"type": "para", "indent": 8, "text": ["Photon is not modified, bouncing as usual (this is the default)."], "extent": [90787, 90860]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Pass Through"], "extent": [90860, 90878], "body": [{"type": "para", "indent": 8, "text": ["Photon passes through the surface, not being stored."], "extent": [90878, 90939]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Block"], "extent": [90939, 90950], "body": [{"type": "para", "indent": 8, "text": ["Photon is stopped, ending the path trace for that photon."], "extent": [90950, 91017]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_photonmodifier", "ifdprop": "object:photonmodifier"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Preview"], "extent": [91017, 91031], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Enable preview"], "role": "item", "extent": [91031, 91050], "body": [{"type": "para", "indent": 4, "text": ["Enable IPR rendering"], "extent": [91105, 91131]}], "container": true, "attrs": {"hprop": "vm_preview", "ifdprop": "renderer:preview"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Preview mode"], "role": "item", "extent": [91131, 91147], "body": [{"type": "para", "indent": 4, "text": ["The IPR rendering mode (blur, sharp or ordered)."], "extent": [91210, 91264]}], "container": true, "attrs": {"hprop": "vm_previewmode", "ifdprop": "renderer:previewmode"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Preview time"], "role": "item", "extent": [91264, 91280], "body": [{"type": "para", "indent": 4, "text": ["Target time to spend on a tile in IPR."], "extent": [91343, 91387]}], "container": true, "attrs": {"hprop": "vm_previewtime", "ifdprop": "renderer:previewtime"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Enable adaptive preview"], "role": "item", "extent": [91387, 91414], "body": [{"type": "para", "indent": 4, "text": ["Adaptively update tile sampling."], "extent": [91485, 91523]}], "container": true, "attrs": {"hprop": "vm_previewadaptive", "ifdprop": "renderer:previewadaptive"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Adaptive preview factor"], "role": "item", "extent": [91523, 91550], "body": [{"type": "para", "indent": 4, "text": ["Controls how much of an effect the adaptive sampling contributes per tile."], "extent": [91633, 91713]}], "container": true, "attrs": {"hprop": "vm_previewadaptivefactor", "ifdprop": "renderer:previewadaptivefactor"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Use the relighting buffer for preview"], "role": "item", "extent": [91713, 91754], "body": [{"type": "para", "indent": 4, "text": ["Enable IPR image relighting."], "extent": [91827, 91861]}], "container": true, "attrs": {"hprop": "vm_relightingbuffer", "ifdprop": "renderer:relightingbuffer"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Preview uses fixed samples per pass"], "role": "item", "extent": [91861, 91900], "body": [{"type": "para", "indent": 4, "text": ["Base the number of samples per pass on ", {"type": "code", "text": ["vm_iprpasssamples"]}, ". Primarily useful for performance testing."], "extent": [91967, 92074]}], "container": true, "attrs": {"hprop": "vm_iprfixsamples", "ifdprop": "renderer:iprfixsamples"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Preview samples per pass"], "role": "item", "extent": [92074, 92102], "body": [{"type": "para", "indent": 4, "text": ["Sets the number of samples taken per pass, as a multiple of the minimum number of samples per pass. Primarily useful for performance testing."], "extent": [92171, 92318]}], "container": true, "attrs": {"hprop": "vm_iprpasssamples", "ifdprop": "renderer:iprpasssamples"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Use fake relighting buffer"], "role": "item", "extent": [92318, 92348], "body": [{"type": "para", "indent": 4, "text": ["Only used for performance testing. A fake relighting buffer is created and zeroed."], "extent": [92417, 92505]}], "container": true, "attrs": {"hprop": "vm_iprfakerelight", "ifdprop": "renderer:iprfakerelight"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Minimum preview tile size"], "role": "item", "extent": [92505, 92534], "body": [{"type": "para", "indent": 4, "text": ["Allows IPR to use tile sizes less than 64\u00d764 pixels."], "extent": [92597, 92655]}], "container": true, "attrs": {"hprop": "vm_iprbucketsize", "ifdprop": "renderer:iprbucket"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Preview mouse radius"], "role": "item", "extent": [92655, 92679], "body": [{"type": "para", "indent": 4, "text": ["IPR mouse radius control."], "extent": [92756, 92787]}], "container": true, "attrs": {"hprop": "vm_previewmouseradius", "ifdprop": "renderer:previewmouseradius"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Always use raytraced shadows in preview mode"], "role": "item", "extent": [92787, 92835], "body": [{"type": "para", "indent": 4, "text": ["Always use ray-traced shadows in IPR rendering."], "extent": [92870, 92923]}], "container": true, "attrs": {"hprop": "vm_iprraytraceshadows"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Output extra material style sheet data"], "role": "item", "extent": [92923, 92964], "body": [{"type": "para", "indent": 4, "text": ["Allows IPR to determine which material style sheets contributed to a pixel in the render output."], "extent": [93027, 93129]}], "container": true, "attrs": {"hprop": "vm_stylesheets", "ifdprop": "renderer:stylesheets"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Render"], "extent": [93129, 93142], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Display as"], "role": "item", "extent": [93142, 93157], "body": [], "container": true, "attrs": {"hprop": "viewportlod", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Is UV rendering"], "role": "item", "extent": [93198, 93217], "body": [], "container": true, "attrs": {"hprop": "vm_isuvrendering", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["UV Current UV Object"], "role": "item", "extent": [93263, 93286], "body": [], "container": true, "attrs": {"hprop": "vm_uvcurrentuvobject", "ifdprop": "renderer:uvcurrentuvobject", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["UV Current Cage Object"], "role": "item", "extent": [93377, 93402], "body": [], "container": true, "attrs": {"hprop": "vm_uvcurrentcageobject", "ifdprop": "renderer:uvcurrentcageobject", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["UV Current Hires Object"], "role": "item", "extent": [93497, 93523], "body": [], "container": true, "attrs": {"hprop": "vm_uvcurrenthiresobject", "ifdprop": "renderer:uvcurrenthiresobject", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Tile size"], "role": "item", "extent": [93620, 93633], "body": [{"type": "para", "indent": 4, "text": ["The size (in pixels) of the tiles rendered by mantra. Larger tile sizes may consume more memory."], "extent": [93687, 93789]}], "container": true, "attrs": {"hprop": "vm_bucketsize", "ifdprop": "image:bucket"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Color Tile Borders by Thread Index"], "role": "item", "extent": [93789, 93826], "body": [{"type": "para", "indent": 4, "text": ["Set the color of the tile borders to indicate which thread was responsible \n    for rendering it. This can be be used to visually check for thread balancing\n    issues."], "extent": [93898, 94072]}], "container": true, "attrs": {"hprop": "vm_bucketthreadcolor", "ifdprop": "image:bucketthreadcolor"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Opacity threshold"], "role": "item", "extent": [94072, 94093], "body": [{"type": "para", "indent": 4, "text": ["This property will be used to cull out parts of the volume behind fully opaque portions.\n    After shading of a surface, if the Of variable is less than this threshold, mantra will consider that the surface doesn\u2019t exist and samples will be ignored."], "extent": [94157, 94412]}], "container": true, "attrs": {"hprop": "vm_opacitythresh", "ifdprop": "image:opacitythresh"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Cache Limit"], "role": "item", "extent": [94412, 94427], "body": [{"type": "para", "indent": 4, "text": ["Whether to use a fixed size cache (", {"type": "code", "text": ["vm_cachesize"]}, ") or whether to use a proportion of physical memory (", {"type": "code", "text": ["vm_cacheratio"]}, ")"], "extent": [94494, 94618]}], "container": true, "attrs": {"hprop": "vm_usecacheratio", "ifdprop": "renderer:usecacheratio"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Cache Memory Ratio"], "role": "item", "extent": [94618, 94640], "body": [{"type": "para", "indent": 4, "text": ["The proportion of physical memory Mantra will use for its unified cache."], "extent": [94701, 94783]}, {"type": "para", "indent": 4, "text": ["For example, with the default ", {"type": "code", "text": ["vm_cacheratio"]}, " of ", {"type": "code", "text": ["0.25"]}, " and 16 Gb of physical memory, Mantra will use 4 Gb for its unified cache."], "extent": [94783, 94922]}, {"type": "para", "indent": 4, "text": ["The unified cache stores dynamic, unloadable data used by the render including the following:"], "extent": [94922, 95025]}, {"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["2D ", {"type": "code", "text": [".rat"]}, " texture tiles"], "extent": [95025, 95055]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["3D ", {"type": "code", "text": [".i3d"]}, " texture tiles"], "extent": [95055, 95085]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["3D ", {"type": "code", "text": [".pc"]}, " point cloud pages (when not preloaded into memory)"], "extent": [95085, 95151]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["Tessellated meshes required by ray tracing:"], "extent": [95151, 95201], "body": [{"type": "bullet_group", "body": [{"blevel": 10, "type": "bullet", "indent": 8, "text": ["Displacements"], "extent": [95201, 95225]}, {"blevel": 10, "type": "bullet", "indent": 8, "text": ["Subdivision surfaces"], "extent": [95225, 95256]}, {"blevel": 10, "type": "bullet", "indent": 8, "text": ["Bezier and NURBS primitives"], "extent": [95256, 95295]}], "container": true}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_cacheratio", "ifdprop": "renderer:cacheratio"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Cache Size (MB)"], "role": "item", "extent": [95295, 95314], "body": [{"type": "para", "indent": 4, "text": ["An explicit memory limit for the unified shading cache.  This is deprecated in favor of using the ", {"type": "ui", "text": ["Cache Memory Ratio"]}, "."], "extent": [95373, 95500]}], "container": true, "attrs": {"hprop": "vm_cachesize", "ifdprop": "renderer:cachesize"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Sample data cache size (MB)"], "role": "item", "extent": [95500, 95531], "body": [], "container": true, "attrs": {"hprop": "vm_samplecachesize", "ifdprop": "renderer:samplecachesize", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Enable hiding"], "role": "item", "extent": [95618, 95635], "body": [{"type": "para", "indent": 4, "text": ["Perform hidden surface removal. When hidden surface removal is disabled, all surfaces in the camera\u2019s frustum will be rendered, regardless of whether they are occluded. This can impact render time significantly."], "extent": [95688, 95905]}], "container": true, "attrs": {"hprop": "vm_hidden", "ifdprop": "renderer:hidden"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Use max processors"], "role": "item", "extent": [95905, 95927], "body": [{"type": "para", "indent": 4, "text": ["When enabled, automatically set the thread count (", {"type": "code", "text": ["renderer:threadcount"]}, " IFD property) to the number of CPUs of the rendering machine."], "extent": [95994, 96134]}], "container": true, "attrs": {"hprop": "vm_usemaxthreads", "ifdprop": "renderer:usemaxthreads"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Thread count"], "role": "item", "extent": [96134, 96150], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Use Max Processors"]}, " (", {"type": "code", "text": ["renderer:usemaxthreads"]}, " IFD property) is disabled, sets the number of threads Mantra uses for rendering."], "extent": [96213, 96353]}], "container": true, "attrs": {"hprop": "vm_threadcount", "ifdprop": "renderer:threadcount"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Override HIP in IFD"], "role": "item", "extent": [96353, 96376], "body": [{"type": "para", "indent": 4, "text": ["Controls what value is set for ", {"type": "code", "text": ["$HIP"]}, " in the IFD file. By default this is the same as ", {"type": "code", "text": ["$HIP"]}, " in Houdini, which is usually what you want. However, you may need to set ", {"type": "code", "text": ["$HIP"]}, " to something different in the IFD if you are doing interesting things with a render farm, for example."], "extent": [96404, 96685]}], "container": true, "attrs": {"hprop": "vm_hippath"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Inherit properties"], "role": "item", "extent": [96685, 96707], "body": [], "container": true, "attrs": {"hprop": "vm_inheritproperties", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Declare style sheets"], "role": "item", "extent": [96757, 96781], "body": [{"type": "para", "indent": 4, "text": ["Controls which style sheets defined in the hip file are embedded into the IFD. Standard Houdini pattern matching is used on each embedded style sheet name."], "extent": [96814, 96975]}], "container": true, "attrs": {"hprop": "declare_stylesheets"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Apply style sheets"], "role": "item", "extent": [96975, 96997], "body": [{"type": "para", "indent": 4, "text": ["Specifies which style sheets mantra should apply during rendering. This is a space separated list of either names of style sheets embedded in the hip file, or external JSON files on disk. As with individual styles within a single style sheet, style sheets later in the list take precedence over style sheets earlier in the list."], "extent": [97028, 97362]}], "container": true, "attrs": {"hprop": "apply_stylesheets"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Declare all bundles"], "role": "item", "extent": [97362, 97385], "body": [{"type": "para", "indent": 4, "text": ["Enabling this option forces all node bundles to be saved to the IFD.  Bundles can be used by style sheets to target objects. If this feature is used in style sheets defined on disk, you may need to enable this option to get the expected results from the style sheets."], "extent": [97414, 97687]}], "container": true, "attrs": {"hprop": "declare_bundles"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Declare materials"], "role": "item", "extent": [97687, 97708], "body": [{"type": "para", "indent": 4, "text": ["Controls which SHOPs are embedded in the generated IFD. This parameter can be used to force all SHOPs or all Material SHOPs to be embedded even if Houdini does not find explicit references to those SHOPs on the output objects and geometry."], "extent": [97739, 97984]}], "container": true, "attrs": {"hprop": "declare_all_shops"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Output OTLs with full paths"], "role": "item", "extent": [97984, 98015], "body": [{"type": "para", "indent": 4, "text": ["Enabling this checkbox will expand any variables in OTL paths, breaking the dependency on Houdini environment variables, but possibly making the IFD less portable."], "extent": [98043, 98212]}], "container": true, "attrs": {"hprop": "vm_otlfullpath"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Force VEX shader embedding"], "role": "item", "extent": [98212, 98242], "body": [{"type": "para", "indent": 4, "text": ["Mantra is able to load the shader directly from the OTL when Houdini uses a shader defined in an OTL. When shaders are built using VOPs, the shader must be embedded in the IFD. Enabling this option will force Houdini to embed the shaders defined by OTLs."], "extent": [98271, 98535]}, {"type": "para", "indent": 4, "text": ["This option makes the IFD more self-contained so that machines which don\u2019t have the OTL installed (or a different version of the OTL) are able to evaluate the shaders correctly."], "extent": [98535, 98718]}, {"type": "para", "indent": 4, "text": ["However, if you have complicated shaders, embedding them will bloat the size of the IFD significantly."], "extent": [98718, 98826]}], "container": true, "attrs": {"hprop": "vm_embedvex"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Enable motion blur"], "role": "item", "extent": [98826, 98848], "body": [{"type": "para", "indent": 4, "text": ["Whether to enable motion blur sampling for scanline rendering."], "extent": [98911, 98979]}], "container": true, "attrs": {"hprop": "vm_blurquality", "ifdprop": "renderer:blurquality"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Enable raytraced motion blur"], "role": "item", "extent": [98979, 99011], "body": [{"type": "para", "indent": 4, "text": ["Whether to allow motion blur sampling for ray-traced rendering."], "extent": [99080, 99149]}], "container": true, "attrs": {"hprop": "vm_rayblurquality", "ifdprop": "renderer:rayblurquality"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Enable Depth of Field"], "role": "item", "extent": [99149, 99174], "body": [{"type": "para", "indent": 4, "text": ["Allow depth of field rendering."], "extent": [99235, 99272]}], "container": true, "attrs": {"hprop": "vm_dofquality", "ifdprop": "renderer:dofquality"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Enable raytracing"], "role": "item", "extent": [99272, 99293], "body": [{"type": "para", "indent": 4, "text": ["Whether to allow ray-tracing.  By disallowing ray-tracing no ray-traced shadows, reflections, refractions, etc. will be performed."], "extent": [99354, 99490]}], "container": true, "attrs": {"hprop": "vm_rayquality", "ifdprop": "renderer:rayquality"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Enable GI"], "role": "item", "extent": [99490, 99503], "body": [{"type": "para", "indent": 4, "text": ["Whether to enable the irradiance and occlusion VEX functions. This also controls whether irradiance caching will be enabled."], "extent": [99562, 99692]}], "container": true, "attrs": {"hprop": "vm_giquality", "ifdprop": "renderer:giquality"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Enable dicing"], "role": "item", "extent": [99692, 99709], "body": [{"type": "para", "indent": 4, "text": ["Whether to enable dicing of displacements/subdivisions. Disabling this setting will have the same effect as disabling ", {"type": "code", "text": ["Polygons as subdivision"]}, " on all objects and disabling ", {"type": "code", "text": ["true displacements"]}, " on all materials."], "extent": [99776, 99993]}], "container": true, "attrs": {"hprop": "vm_dicingquality", "ifdprop": "renderer:dicingquality"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Enable render interrupt"], "role": "item", "extent": [99993, 100020], "body": [{"type": "para", "indent": 4, "text": ["Allow interruption of rendering.  This is typically enabled for IPR rendering."], "extent": [100091, 100175]}], "container": true, "attrs": {"hprop": "vm_renderinterrupt", "ifdprop": "renderer:renderinterrupt"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Ray tracing accelerator"], "role": "item", "extent": [100175, 100202], "body": [{"type": "para", "indent": 4, "text": ["Controls the type of ray tracing accelerator used by mantra. A ray tracing accelerator is a spatial data structure used to optimize the performance of ray intersection tests against complex geometry. "], "extent": [100265, 100475]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["KD-Tree (", {"type": "code", "text": ["\"kdtree\""]}, ")"], "extent": [100475, 100501], "body": [{"type": "para", "indent": 8, "text": ["Ray trace using a KD-Tree. Normally, the KD-Tree will produce the fastest raytracing performance at a modest initialization time. It is possible to control the performance/quality tradeoff for KD-Tree construction with the ", {"type": "ui", "text": ["KD-Tree Memory Factor"]}, " parameter (", {"type": "code", "text": ["vm_kdmemfactor"]}, "). "], "extent": [100501, 100794]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Bounding Volume Hierarchy (", {"type": "code", "text": ["\"bboxtree\""]}, ")"], "extent": [100794, 100840], "body": [{"type": "para", "indent": 8, "text": ["Ray trace using a bounding volume hierarchy. Sometimes a bounding volume hierarchy will be faster to construct and/or faster to raytrace than a KD-Tree. "], "extent": [100840, 101003]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_octreestyle", "ifdprop": "renderer:octreestyle"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["KD-Tree memory factor"], "role": "item", "extent": [101003, 101028], "body": [{"type": "para", "indent": 4, "text": ["Change the memory/performance tradeoff used when constructing KD-Tree acceleration data structures. Values larger than 1 will cause mantra to use proportionally more memory and take longer to optimize the tree in an attempt to make ray tracing faster. Smaller values will cause mantra to use proportionally less memory and take less time to optimize the tree, while possibly compromising ray tracing performance. The default value of 1 will try to balance the amount of memory used by ray tracing data structures with the amount of memory used by geometry."], "extent": [101091, 101653]}, {"type": "para", "indent": 4, "text": ["If you are noticing long tree construction times, try decreasing the KD memory factor to 0.1. If your render is too slow after tree construction, increase the value until you find a good balance of tree construction time vs. render performance."], "extent": [101653, 101903]}], "container": true, "attrs": {"hprop": "vm_kdmemfactor", "ifdprop": "renderer:kdmemfactor"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Enable Oriented BVH Construction"], "role": "item", "extent": [101903, 101939], "body": [{"type": "para", "indent": 4, "text": ["Enables a ray tracing tree construction algorithm that uses rotations to locally align the axes with the dominant geometric directions. This approach only works on curves, and will usually increase the amount of time required to build the ray tracing tree. However the resulting trees may improve ray tracing performance particularly for bundles of long curves that are not aligned to the x, y, or z axis as can commonly occur when rendering long hair."], "extent": [102002, 102460]}], "container": true, "attrs": {"hprop": "vm_bvhoriented", "ifdprop": "renderer:bvhoriented"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Ray Tracing Curve Bunch Size"], "role": "item", "extent": [102460, 102492], "body": [{"type": "para", "indent": 4, "text": ["The number of curve segments to group together when building ray tracing objects for curves. Larger values will reduce memory use but will decrease performance since the ray tracer needs to attempt more ray intersections. A value of 1 will create one ray tracing object per curve segment resulting in the best possible ray tracing performance but can increase memory use substantially."], "extent": [102561, 102952]}], "container": true, "attrs": {"hprop": "vm_curvebunchsize", "ifdprop": "renderer:curvebunchsize"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Use ray level of detail"], "role": "item", "extent": [102952, 102979], "body": [], "container": true, "attrs": {"hprop": "vm_bboxenablelod", "ifdprop": "renderer:bboxenablelod", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Render Time Limit"], "role": "item", "extent": [103062, 103083], "body": [{"type": "para", "indent": 4, "text": ["Specifies the amount of time to render in seconds, or 0 to render until completion."], "extent": [103142, 103231]}], "container": true, "attrs": {"hprop": "vm_timelimit", "ifdprop": "renderer:timelimit"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Quick exit"], "role": "item", "extent": [103231, 103245], "body": [{"type": "para", "indent": 4, "text": ["By default, mantra lets the system perform a cleanup of the process resources.  A quick-exit is very efficient, but this case, mantra won\u2019t do any cleanup itself.  This means that custom VEX cleanup functions may not be run."], "extent": [103271, 103501]}], "container": true, "attrs": {"hprop": "vm_quickexit"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Phantom"], "role": "item", "extent": [103501, 103512], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "code", "text": ["true"]}, ", the object will not be rendered by primary rays. Only secondary rays will hit the object."], "extent": [103569, 103677]}, {"type": "para", "indent": 4, "text": ["(See the ", {"scheme": "Mantra", "value": "/props/mantra#vm_rendervisibility", "type": "link", "text": ["Render Visibility"], "fallback_text": "vm_rendervisibility", "fullpath": "/props/mantra#vm_rendervisibility", "fragment": "#vm_rendervisibility"}, " property)."], "extent": [103677, 103749]}], "container": true, "attrs": {"hprop": "vm_phantom", "ifdprop": "object:phantom"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Renderable"], "role": "item", "extent": [103749, 103763], "body": [{"type": "para", "indent": 4, "text": ["If this option is turned off, then the instance will not be rendered. The object\u2019s properties can still be queried from within VEX, but no geometry will be rendered. This is roughly equivalent to turning the object into a transform space object."], "extent": [103822, 104073]}, {"type": "para", "indent": 4, "text": ["See ", {"type": "ui", "text": ["Render Visibility"]}, " (", {"type": "code", "text": ["vm_rendervisibility"]}, " property)."], "extent": [104073, 104138]}], "container": true, "attrs": {"hprop": "vm_renderable", "ifdprop": "object:renderable"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Render Visibility"], "role": "item", "extent": [104138, 104159], "body": [{"type": "para", "indent": 4, "text": ["Controls the visibility of an object to different types of rays using a category expression. This parameter generalizes the Phantom and Renderable toggles and allows more specific control over the visibility of an object to the different ray types supported by mantra and VEX."], "extent": [104234, 104515]}, {"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "q", "text": ["primary"]}, " - Rays sent from the camera"], "extent": [104515, 104559]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "q", "text": ["shadow"]}, " - Shadow rays"], "extent": [104559, 104588]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "q", "text": ["diffuse"]}, " - Diffuse rays"], "extent": [104588, 104619]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "q", "text": ["reflect"]}, " - Reflections"], "extent": [104619, 104649]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "q", "text": ["refract"]}, " - Refractions"], "extent": [104649, 104680]}], "container": true}, {"type": "para", "indent": 4, "text": ["For example, to create a phantom object, set the expression to ", {"type": "q", "text": ["-primary"]}, ". To create an unrenderable object, set the expression to the empty string ", {"type": "q", "text": []}, ". These tokens correspond to the string given to ", {"type": "q", "text": ["raystyle"]}, " in the VEX trace() and gather() functions."], "extent": [104680, 104938]}], "container": true, "attrs": {"hprop": "vm_rendervisibility", "ifdprop": "object:rendervisibility"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Object root path"], "role": "item", "extent": [104938, 104958], "body": [{"type": "para", "indent": 4, "text": ["This is set to the ", {"type": "q", "text": ["root"]}, " of the object tree. In Houdini, this is typically ", {"type": "code", "text": ["/obj"]}, ". If object names are specified using relative paths (i.e. ", {"type": "code", "text": ["light1"]}, " or ", {"type": "code", "text": ["subnet1/light1"]}, "), this is used to determine the full path. This will be deprecated in the future in favor of category selection."], "extent": [105013, 105301]}], "container": true, "attrs": {"hprop": "vm_objroot", "ifdprop": "renderer:objroot"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Polygons as subdivision (Mantra)"], "role": "item", "extent": [105301, 105337], "body": [{"type": "para", "indent": 4, "text": ["Render polygons as a subdivision surface. The ", {"type": "code", "text": ["creaseweight"]}, " attribute is used to perform linear creasing. This attribute may appear on points, vertices or primitives."], "extent": [105396, 105569]}, {"type": "para", "indent": 4, "text": ["When rendering using OpenSubdiv, in addition to the ", {"type": "code", "text": ["creaseweight"]}, ", ", {"type": "code", "text": ["cornerwieght"]}, " attributes and the ", {"type": "code", "text": ["subdivision_hole"]}, " group, additional attributes are scanned to control the behaviour of refinement.  These override any other settings:"], "extent": [105569, 105811]}, {"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["int osd_scheme"]}, ", ", {"type": "code", "text": ["string osd_scheme"]}, ":  Specifies the scheme for OSD subdivision (0 or ", {"type": "q", "text": ["catmull-clark"]}, "; 1 or ", {"type": "q", "text": ["loop"]}, ";  2 or ", {"type": "q", "text": ["bilinear"]}, ").  Note that for Loop subdivision, the geometry can only contain triangles."], "extent": [105811, 106027]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["int osd_vtxboundaryinterpolation"]}, ": The Vertex Boundary Interpolation method (see ", {"type": "code", "text": ["vm_osd_vtxinterp"]}, " for further details)"], "extent": [106027, 106155]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["int osd_fvarlinearinterpolation"]}, ": The Face-Varying Linear Interpolation method (see ", {"type": "code", "text": ["vm_osd_fvarinterp"]}, " for further details)"], "extent": [106155, 106287]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["int osd_creasingmethod"]}, ": Specify the creasing method, 0 for Catmull-Clark, 1 for Chaikin"], "extent": [106287, 106383]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["int osd_trianglesubdiv"]}, ": Specifies the triangle weighting algorithm, 0 for Catmull-Clark weights, 1 for ", {"type": "q", "text": ["smooth triangle"]}, " weights."], "extent": [106383, 106522]}], "container": true}], "container": true, "attrs": {"hprop": "vm_rendersubd", "ifdprop": "object:rendersubd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Subdivision Style"], "role": "item", "extent": [106522, 106543], "body": [{"type": "para", "indent": 4, "text": ["The algorithm used to render subdivision surfaces.  Currently, this can be either ", {"type": "code", "text": ["mantra_catclark"]}, " or ", {"type": "code", "text": ["osd_catclark"]}, "."], "extent": [106600, 106724]}], "container": true, "attrs": {"hprop": "vm_subdstyle", "ifdprop": "object:subdstyle"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Subdivision Group"], "role": "item", "extent": [106724, 106745], "body": [{"type": "para", "indent": 4, "text": ["A primitive group of polygons which should be rendered as a subdivision surface.  This is only effective if ", {"type": "code", "text": ["vm_rendersubd"]}, " is enabled."], "extent": [106802, 106943]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [106943, 106953], "body": [{"type": "para", "indent": 8, "text": ["This is a group on the final geometry that is being rendered. For example, if the top-level primitive is an Alembic primitive, then the ", {"type": "code", "text": ["vm_subdgroup"]}, " refers to a given face set in that primitive."], "extent": [106953, 107160]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"hprop": "vm_subdgroup", "ifdprop": "object:subdgroup"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["OpenSubdiv Quality"], "role": "item", "extent": [107160, 107182], "body": [{"type": "para", "indent": 4, "text": ["The dicing quality when rendering subdivision surfaces as ", {"type": "code", "text": ["osd_catclark"]}, ".  This value is multiplied by the shading quality and shading factor to determine the number of refinement levels for the surface."], "extent": [107243, 107452]}], "container": true, "attrs": {"hprop": "vm_osd_quality", "ifdprop": "object:osd_quality"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["OpenSubdiv Vertex Boundary Interpolation"], "role": "item", "extent": [107452, 107496], "body": [{"type": "para", "indent": 4, "text": ["How subdivision vertex (Houdini point) attributes are interpolated on boundaries."], "extent": [107561, 107647]}, {"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["0: Do not interpolate boundaries"], "extent": [107647, 107686]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["1: Sharpen edges"], "extent": [107686, 107709]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["2: Sharpen edges and corners"], "extent": [107709, 107745]}], "container": true}], "container": true, "attrs": {"hprop": "vm_osd_vtxinterp", "ifdprop": "object:osd_vtxinterp"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["OpenSubdiv FVar Linear Interpolation"], "role": "item", "extent": [107745, 107785], "body": [{"type": "para", "indent": 4, "text": ["How subdivision face varying (Houdini vertex) attributes are interpolated."], "extent": [107852, 107931]}, {"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["0: Smooth everywhere (", {"type": "q", "text": ["edge only"]}, ")"], "extent": [107931, 107972]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["1: Sharpen corners only"], "extent": [107972, 108002]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["2: Sharpen edges and corners"], "extent": [108002, 108037]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["3: Sharpen edges and corners and propagate corners"], "extent": [108037, 108094]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["4: Sharpen all boundaries (", {"type": "q", "text": ["always sharp"]}, ")"], "extent": [108094, 108143]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["5: Bilinear interpolation"], "extent": [108143, 108176]}], "container": true}], "container": true, "attrs": {"hprop": "vm_osd_fvarinterp", "ifdprop": "object:osd_fvarinterp"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Save geometry groups"], "role": "item", "extent": [108176, 108200], "body": [{"type": "para", "indent": 4, "text": ["Controls whether geometry groups are saved to the IFD.  Groups can require \n    a significant amount of storage and are normally unused during rendering - \n    so leaving this option disabled will improve IFD generation time and \n    reduce file size."], "extent": [108227, 108484]}], "container": true, "attrs": {"hprop": "vm_savegroups"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Rendering"], "extent": [108484, 108500], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Enable depth of field"], "role": "item", "extent": [108500, 108526], "body": [{"type": "para", "indent": 4, "text": ["Mantra will render with depth of field. The parameters controlling depth of field may be found on the camera object."], "extent": [108546, 108668]}], "container": true, "attrs": {"hprop": "vm_dof"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Allow motion blur"], "role": "item", "extent": [108668, 108689], "body": [{"type": "para", "indent": 4, "text": ["This is the ", {"type": "q", "text": ["master switch"]}, " for simulated motion blur when rendering. Turning it on enables ", {"type": "em", "text": ["transformation"]}, " motion blur (blurring by interpolating each object\u2019s transforms between frames). You can set the number of transform blur samples using ", {"scheme": "Mantra", "value": "/props/mantra#xform_motionsamples", "type": "link", "text": "", "fallback_text": "xform_motionsamples", "fullpath": "/props/mantra#xform_motionsamples", "fragment": "#xform_motionsamples"}, ". To enable ", {"type": "em", "text": ["deformation"]}, " motion blur, increase ", {"scheme": "Mantra", "value": "/props/mantra#geo_motionsamples", "type": "link", "text": "", "fallback_text": "geo_motionsamples", "fullpath": "/props/mantra#geo_motionsamples", "fragment": "#geo_motionsamples"}, "."], "extent": [108718, 109072]}], "container": true, "attrs": {"hprop": "allowmotionblur"}}], "container": true, "role": "item_group"}, {"type": "para", "indent": 0, "text": ["See ", {"scheme": null, "value": "/render/blur", "type": "link", "text": ["motion blur"], "fullpath": "/render/blur"}, " for more information about rendering motion blur."], "extent": [109072, 109154]}, {"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Auto Engine Procedural"], "role": "item", "extent": [109154, 109180], "body": [{"type": "para", "indent": 4, "text": ["This is an advanced property which can be added per object."], "extent": [109219, 109288]}, {"type": "para", "indent": 4, "text": ["If the property is set, SOHO will automatically enable the Engine\n    Procedural for this object.  The object network itself will be saved as an\n    HDA in the IFD stream for use by the Engine Procedural.  At render time,\n    mantra will take the geometry generated by the Display SOP and instance it\n    to each point in the geometry on the Render SOP\u2019s geometry.  For each\n    instance, point attributes on the Render SOP\u2019s points that match parameters\n    on the object network will be applied, allowing for geometry variation at\n    render time."], "extent": [109288, 109843]}, {"type": "para", "indent": 4, "text": ["Mantra has three different levels of support for the engine procedural.\n    These modes are set using the ", {"type": "code", "text": ["-e"]}, " command line option (or the\n    ", {"type": "code", "text": ["MANTRA_ENGINE_PROCEDURAL"]}, " environment variable):"], "extent": [109843, 110040]}, {"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["none"]}, ": In this mode, mantra can bypass setting up an environment to evaluate SOP networks.  This can improve start-up time for mantra.  In most cases, this is an insignificant amount of time."], "extent": [110040, 110239]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["basic"]}, ": Allows generation of point and curve geometry."], "extent": [110239, 110301]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["full"]}, ": Allows generation of any types of geometry.  This option will make mantra use an Engine license instead of a Render license."], "extent": [110301, 110441]}], "container": true}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [110441, 110451], "body": [{"type": "para", "indent": 8, "text": ["The engine procedural will try to set a parameter named ", {"type": "code", "text": ["cooking_in_engine"]}, " to 1 when the HDA is being evaluated in mantra.  This allows the SOP network to cook differently for display in Houdini and rendering in Mantra."], "extent": [110451, 110681]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"hprop": "vm_auto_engine_procedural"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Engine Procedural - Unload SOP Geometry"], "role": "item", "extent": [110681, 110724], "body": [{"type": "para", "indent": 4, "text": ["When the ", {"type": "code", "text": ["Auto Engine Procedural"]}, " is set, this property will tell mantra\n    whether to unload the SOP geometry after cooking.  Unloading SOP geometry\n    will free up memory in mantra, but may cause some SOP/Object networks to\n    perform additional computation."], "extent": [110759, 111028]}], "container": true, "attrs": {"hprop": "vm_auto_engine_unload"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Engine Procedural - HDA Uses LOD Parameter"], "role": "item", "extent": [111028, 111074], "body": [{"type": "para", "indent": 4, "text": ["When the ", {"type": "code", "text": ["Auto Engine Procedural"]}, " is set, this property will tell mantra\n    whether to compute the bounding box LOD and set a ", {"type": "code", "text": ["lod"]}, " parameter the HDA.\n    This allows the SOP network to generate different geometry based on the\n    level of detail in mantra."], "extent": [111113, 111377]}, {"type": "para", "indent": 4, "text": ["When the LOD is not required, mantra can share geometry between instances\n    that have the same render parameters (similar to ", {"type": "code", "text": ["Cache Stamping Geometry"]}, "\n    parameter on the Copy Stamp SOP).  If the LOD is required, mantra can not\n    perform any sharing of geometry."], "extent": [111377, 111650]}], "container": true, "attrs": {"hprop": "vm_auto_engine_requirelod"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Engine Procedural - Orient HDA instances to points"], "role": "item", "extent": [111650, 111704], "body": [{"type": "para", "indent": 4, "text": ["When the ", {"type": "code", "text": ["Auto Engine Procedural"]}, " is set, this property controls whether\n    the instanced geometry should be rotated based on the point attributes.\n    Each instance will always be translated to the instance point, but this\n    parameter controls whether attributes like ", {"type": "code", "text": ["pscale"]}, " and ", {"type": "code", "text": ["N"]}, " will be applied\n    to the instance transform."], "extent": [111741, 112082]}], "container": true, "attrs": {"hprop": "vm_auto_engine_doorient"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Engine Procedural - Bounding Box SOP"], "role": "item", "extent": [112082, 112122], "body": [{"type": "para", "indent": 4, "text": ["When the ", {"type": "code", "text": ["Auto Engine Procedural"]}, " is set, the SOP specified by this\n    property is used to determine the bounds of the generated hair at rendertime."], "extent": [112159, 112314]}, {"type": "para", "indent": 4, "text": ["If not specified or empty the SOP with the display flag is used."], "extent": [112314, 112384]}, {"type": "tip_group", "body": [{"type": "tip", "indent": 4, "role": "item", "extent": [112384, 112393], "body": [{"type": "para", "indent": 8, "text": ["Rendering with motion blur can invalidate the cache of the SOP being\n        cooked, causing all dependent nodes to recook when they are displayed\n        in Houdini after a render. To avoid this, create a separate SOP for\n        computing geometry to represent the bounding box of the display\n        geometry. Use this property to specify the final node of that chain."], "extent": [112393, 112774]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"hprop": "vm_auto_engine_boundsop"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Shutter offset"], "role": "item", "extent": [112774, 112792], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/blur/ShutterOffset.jpg", "type": "img", "text": ""}], "role": "item", "extent": [112823, 112882], "body": [{"type": "para", "indent": 8, "text": ["This parameter controls which segment of time will be considered when generating motion blur. A value of 1 will use the current position of the object and the position of the object on the next frame as the time interval to use for motion blur. A value of -1 will use the position of the object on the previous frame and the current position of the object as the time. A value of 0 will generate an interval which lasts halfway through the previous frame and half way into the next frame."], "extent": [112882, 113380]}, {"type": "para", "indent": 8, "text": ["Adjusting this parameter is usually unnecessary unless you are attempting to match motion- blur which has been generated outside of Mantra (for example a photographic background plate)."], "extent": [113380, 113575]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 4, "text": ["Controls where the blur occurs in the image relative to the position of the object at the current frame. A value of ", {"type": "code", "text": ["-1"]}, " blurs from the position at the previous frame to the position in the current frame. A value of ", {"type": "code", "text": ["0"]}, " blurs from halfway to the previous frame to halfway to the next frame. A value of ", {"type": "code", "text": ["1"]}, " blurs from the current position to the position at the next frame. You can use fractional frame values and values greater than ", {"type": "code", "text": ["-1"]}, " or ", {"type": "code", "text": ["1"]}, " to move the blur less or more."], "extent": [113575, 114060]}, {"type": "para", "indent": 4, "text": ["To change the ", {"type": "em", "text": ["size"]}, " of the blur, change the ", {"type": "ui", "text": ["Shutter time"]}, " (", {"type": "code", "text": ["shutter"]}, " property)."], "extent": [114060, 114153]}, {"type": "para", "indent": 4, "text": ["This parameter replaces the old ", {"type": "ui", "text": ["Motion blur style"]}, " (", {"type": "code", "text": ["motionstyle"]}, ") parameter, which only allows values of ", {"type": "q", "text": ["before"]}, " (shutter offset=-1), ", {"type": "q", "text": ["center"]}, " (shutter offset=0), and ", {"type": "q", "text": ["after"]}, " (shutter offset=1)."], "extent": [114153, 114358]}], "container": true, "attrs": {"hprop": "shutteroffset"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Xform time samples"], "role": "item", "extent": [114358, 114380], "body": [{"type": "para", "indent": 4, "text": ["The number of samples to compute when rendering ", {"type": "em", "text": ["transformation"]}, " motion blur over the shutter open time. The default is 2 samples (at the start and end of the shutter time), giving one blurred segment."], "extent": [114447, 114654]}, {"type": "para", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/blur/XFormSampleSimple.jpg", "type": "img", "text": ""}], "extent": [114654, 114713]}, {"type": "para", "indent": 4, "text": ["If you have object moving and changing direction extremely quickly, you might want to increase the number of samples to capture the sub-frame direction changes."], "extent": [114713, 114879]}, {"type": "para", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/blur/XFormSampleComplex.jpg", "type": "img", "text": ""}], "extent": [114879, 114939]}, {"type": "para", "indent": 4, "text": ["In the above example, it requires 40 transformation samples to correctly render the complex motion that occurs within one frame. (This amount of change within a single frame is very unusual and only used as a demonstration.)"], "extent": [114939, 115169]}, {"type": "para", "indent": 4, "text": ["Transformation blur simulates blur by interpolating each object\u2019s transformation between frames, so it\u2019s cheap to compute but does not capture surface deformation. To enable blurring deforming geometry, increase ", {"scheme": "Mantra", "value": "/props/mantra#geo_motionsamples", "type": "link", "text": "", "fallback_text": "geo_motionsamples", "fullpath": "/props/mantra#geo_motionsamples", "fragment": "#geo_motionsamples"}, "."], "extent": [115169, 115414]}], "container": true, "attrs": {"hprop": "xform_motionsamples", "ifdprop": "object:xformsamples"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Geo time samples"], "role": "item", "extent": [115414, 115434], "body": [{"type": "para", "indent": 4, "text": ["The number of sub-frame samples to compute when rendering ", {"type": "em", "text": ["deformation"]}, " motion blur over the shutter open time. The default is 1 (sample only at the start of the shutter time), giving ", {"type": "strong", "text": ["no"]}, " deformation blur by default. If you want rapidly deforming geometry to blur properly, you must increase this value to 2 or more. Increasing the number of geometry time samples is relatively expensive because Houdini must cook the sub-frame geometry and send it to Mantra."], "extent": [115497, 115963]}, {"type": "para", "indent": 4, "text": [{"type": "q", "text": ["Deformation"]}, " may refer to simple transformations at the Geometry (SOP) level, or actual surface deformation, such as a character or object which changes shape rapidly over the course of a frame."], "extent": [115963, 116164]}, {"type": "para", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/blur/GeoTimeSamplesSimple.jpg", "type": "img", "text": ""}], "extent": [116164, 116226]}, {"type": "para", "indent": 4, "text": ["Objects whose deformations are quite complex within a single frame will require a higher number of Geo Time Samples."], "extent": [116226, 116348]}, {"type": "para", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/blur/GeoTimeSamples.jpg", "type": "img", "text": ""}], "extent": [116348, 116404]}, {"type": "para", "indent": 4, "text": ["Deformation blur also lets you blur ", {"type": "em", "text": ["attribute change"]}, " over the shutter time. For example, if point colors are changing rapidly as the object moves, you can blur the ", {"type": "code", "text": ["Cd"]}, " attribute. You must explicitly specify which attributes to blur using the ", {"scheme": "Mantra", "value": "/props/mantra#vm_segmentattrs", "type": "link", "text": "", "fallback_text": "vm_segmentattrs", "fullpath": "/props/mantra#vm_segmentattrs", "fragment": "#vm_segmentattrs"}, " property."], "extent": [116404, 116689]}, {"type": "para", "indent": 4, "text": ["Increasing the number of Geo Time Samples ", {"type": "strong", "text": ["can have an impact"]}, " on the amount of memory Mantra uses. For each additional Sample, Mantra must retain a copy of the geometry in memory while it samples across the shutter time. When optimizing your renders, it is a good idea to find the minimum number of Geo Time Samples necessary to create a smooth motion trail."], "extent": [116689, 117054]}, {"type": "para", "indent": 4, "text": ["Deformation blur is ignored for objects that have ", {"scheme": null, "value": "/render/blur#velocity", "type": "link", "text": ["Velocity motion blur"], "fullpath": "/render/blur#velocity", "fragment": "#velocity"}, " turned on."], "extent": [117054, 117165]}], "container": true, "attrs": {"hprop": "geo_motionsamples", "ifdprop": "object:geosamples"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Render engine"], "role": "item", "extent": [117165, 117182], "body": [{"type": "para", "indent": 4, "text": ["See ", {"scheme": null, "value": "/render/understanding", "type": "link", "text": ["understanding mantra rendering"], "fullpath": "/render/understanding"}, " for more information."], "extent": [117247, 117337]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Micropolygon Rendering"], "extent": [117337, 117365], "body": [{"type": "para", "indent": 8, "text": ["Each primitive is diced up into micropolygons which are shaded and sampled independently."], "extent": [117365, 117468]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Ray Tracing"], "extent": [117468, 117485], "body": [{"type": "para", "indent": 8, "text": ["The scene is sampled by sending rays from the camera.  Each surface hit by a ray will trigger a surface shader execution."], "extent": [117485, 117620]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Micropolygon Physically Based Rendering"], "extent": [117620, 117665], "body": [{"type": "para", "indent": 8, "text": ["Sampling is performed on micropolygons; however, all shading and illumination is performed using physically based rendering. "], "extent": [117665, 117808]}, {"type": "para", "indent": 8, "text": ["The number of rays used to compute shading is determined by the maximum ray-samples."], "extent": [117808, 117906]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Physically Based Rendering"], "extent": [117906, 117938], "body": [{"type": "para", "indent": 8, "text": ["Sampling of the scene is performed using ray-tracing and shading is computed using physically based rendering."], "extent": [117938, 118066]}, {"type": "para", "indent": 8, "text": ["In this case, the pixel samples determine the shading quality of the PBR engine."], "extent": [118066, 118156]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Photon Map Generation"], "extent": [118156, 118183], "body": [{"type": "para", "indent": 8, "text": ["Rather than rendering an image, a photon map will be generated by sending photons from light sources into the scene.  The photon map file to be generated is specified on the PBR tab."], "extent": [118183, 118375]}], "container": true}], "container": true}, {"type": "para", "indent": 4, "text": ["Though this IFD token has an integer value, it\u2019s also possible to set the value through a string value."], "extent": [118375, 118488]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["micropoly"]}], "extent": [118488, 118505], "body": [{"type": "para", "indent": 8, "text": ["Micropolygon scanline rendering (default)."], "extent": [118505, 118565]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["raytrace"]}], "extent": [118565, 118581], "body": [{"type": "para", "indent": 8, "text": ["All rendering will be performed using ray-tracing."], "extent": [118581, 118649]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["pbrmicropoly"]}], "extent": [118649, 118669], "body": [{"type": "para", "indent": 8, "text": ["Physically Based Rendering using micro-polygon scanline rendering."], "extent": [118669, 118753]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["pbrraytrace"]}], "extent": [118753, 118772], "body": [{"type": "para", "indent": 8, "text": ["Physically Based Rendering using ray-tracing only."], "extent": [118772, 118840]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["photon"]}], "extent": [118840, 118854], "body": [{"type": "para", "indent": 8, "text": ["Photon map generation."], "extent": [118854, 118886]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_renderengine", "ifdprop": "renderer:renderengine"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Raytrace motion blur"], "role": "item", "extent": [118886, 118910], "body": [{"type": "para", "indent": 4, "text": ["Enable or disable raytrace motion blur for micro-polygon rendering and photon map generation. By default, raytrace motion blur is disabled. This setting has no effect on the ray tracing rendering engines."], "extent": [118971, 119181]}], "container": true, "attrs": {"hprop": "vm_traceblur", "ifdprop": "object:traceblur"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Sampling"], "extent": [119181, 119196], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Focus distance"], "role": "item", "extent": [119196, 119215], "body": [{"type": "para", "indent": 4, "text": ["The lens focal distance and distance from the camera at\n    which objects will be in focus. This is only used when rendering using depth of field. Objects outside this distance will be blurred."], "extent": [119265, 119464]}], "container": true, "attrs": {"hprop": "focus", "ifdprop": "camera:focus"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["F-stop"], "role": "item", "extent": [119464, 119474], "body": [{"type": "para", "indent": 4, "text": ["Lens fstop. This is only used when rendering using depth of field.\n    Determines blurriness of depth of field effects."], "extent": [119524, 119649]}], "container": true, "attrs": {"hprop": "fstop", "ifdprop": "camera:fstop"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Shutter time"], "role": "item", "extent": [119649, 119665], "body": [{"type": "para", "indent": 4, "text": ["The shutter time refers to the portion of a frame the shutter is actually open. On a physical camera, this if often referred to as Shutter Speed. The renderer uses this determine motion blur. The value should be in the range ", {"type": "code", "text": ["[0,1]"]}, "."], "extent": [119686, 119925]}, {"type": "para", "indent": 4, "text": ["A value of 0 for the shutter time would mean that there is no motion blur at all, as the shutter is only \u201cOpen\u201d for an instant. A value of 1 on the other hand would mean that the shutter is open for the entire length of the frame."], "extent": [119925, 120161]}, {"type": "para", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/blur/ShutterTime.jpg", "type": "img", "text": ""}], "extent": [120161, 120214]}, {"type": "para", "indent": 4, "text": ["In the above example the sphere is rotating a full 360 degrees over the course of a single frame. You can see how the length of the \u201cmotion trail\u201d or \u201cblur\u201d changes based on the shutter time. In most cases, the default value of .5 is appropriate for animated sequences and a good match for real world settings."], "extent": [120214, 120530]}, {"type": "para", "indent": 4, "text": ["Keep in mind that this parameter controls the amount of time within a single frame, that the shutter is open. It does not refer to how long an individual frame is. To adjust the frame rate, change the Frames per Second parameter in the Global Animation Options."], "extent": [120530, 120797]}], "container": true, "attrs": {"hprop": "shutter"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Motion blur style"], "role": "item", "extent": [120797, 120818], "body": [{"type": "para", "indent": 4, "text": ["See ", {"type": "ui", "text": ["Shutter offset"]}, " (", {"type": "code", "text": ["shutteroffset"]}, " property)."], "extent": [120847, 120903]}], "container": true, "attrs": {"hprop": "motionstyle"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Shutter shape"], "role": "item", "extent": [120903, 120920], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Controls the opening of the shutter along shutter time through a grayscale \n    ramp. The higher the ramp value at a given time point, the more time \n    sample will be focused in that area. \n    NOTE"], "extent": [120987, 121193], "body": [{"type": "para", "indent": 8, "text": ["The ramp is always evaluated across the entire range, regardless of the shutter time setting."], "extent": [121193, 121296]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_shuttershape", "ifdprop": "camera:shuttershape"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Geometry velocity blur"], "role": "item", "extent": [121296, 121322], "body": [{"type": "para", "indent": 4, "text": ["This menu lets you choose what type of ", {"type": "em", "text": ["geometry velocity blur"]}, " to do on an object, if any. Separate from ", {"type": "em", "text": ["transform blur"]}, " and ", {"type": "em", "text": ["deformation blur"]}, ", you can render motion blur based on point movement, using attributes stored on the points that record change over time. You should use this type of blur if the number points in the geometry changes over time (for example, a particle simulation where points are born and die)."], "extent": [121386, 121814]}, {"type": "para", "indent": 4, "text": ["If your geometry changes topology frame-to-frame, Mantra will not be able to interpolate the geometry to correctly calculate Motion Blur. In these cases, motion blur can use a ", {"type": "code", "text": ["v"]}, " and/or ", {"type": "code", "text": ["accel"]}, " attribute which is consistent even while the underlying geometry is changing. The surface of a fluid simulation is a good example of this. In this case, and other types of simulation data, the solvers will automatically create the velocity attribute."], "extent": [121814, 122265]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["No Velocity Blur"], "extent": [122265, 122287], "body": [{"type": "para", "indent": 8, "text": ["Do not render motion blur on this object, even if the renderer is set to allow motion blur."], "extent": [122287, 122388]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Velocity Blur"], "extent": [122388, 122407], "body": [{"type": "para", "indent": 8, "text": ["To use velocity blur, you must compute and store point velocities in a point attribute ", {"type": "code", "text": ["v"]}, ". The renderer uses this attribute, if it exists, to render velocity motion blur (assuming the renderer is set to allow motion blur). The ", {"type": "code", "text": ["v"]}, " attribute may be created automatically by simulation nodes (such as particle DOPs), or you can compute and add it using the ", {"scheme": "Node", "value": "/nodes/sop/pointvelocity", "type": "link", "text": ["Point velocity SOP"], "fullpath": "/nodes/sop/pointvelocity"}, "."], "extent": [122407, 122817]}, {"type": "para", "indent": 8, "text": ["The ", {"type": "code", "text": ["v"]}, " attribute value is measured in Houdini units per second."], "extent": [122817, 122891]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Acceleration Blur"], "extent": [122891, 122914], "body": [{"type": "para", "indent": 8, "text": ["To use acceleration blur, you must compute and store point acceleration in a point attribute ", {"type": "code", "text": ["accel"]}, " (you can change the acceleration attribute name using the ", {"scheme": "Mantra", "value": "/props/mantra#geo_accelattribute", "type": "link", "text": "", "fallback_text": "geo_accelattribute", "fullpath": "/props/mantra#geo_accelattribute", "fragment": "#geo_accelattribute"}, " property). The renderer uses this attribute, if it exists, to render multi-segment acceleration motion blur (assuming the renderer is set to allow motion blur). The ", {"type": "code", "text": ["accel"]}, " attribute may be created automatically by simulation nodes, or you can compute and add it using the ", {"scheme": "Node", "value": "/nodes/sop/pointvelocity", "type": "link", "text": ["Point velocity SOP"], "fullpath": "/nodes/sop/pointvelocity"}, "."], "extent": [122914, 123428]}, {"type": "para", "indent": 8, "text": ["When Acceleration Blur is on, if the geometry has a ", {"type": "em", "text": ["angular velocity"]}, " attribute (", {"type": "code", "text": ["w"]}, "), rapid rotation will also be blurred. This should be a vector attribute, where the components represent rotation speeds in radians per second around X, Y, and Z."], "extent": [123428, 123686]}], "container": true}], "container": true}, {"type": "para", "indent": 4, "text": ["When this is set to ", {"type": "q", "text": ["Velocity Blur"]}, " or ", {"type": "q", "text": ["Acceleration Blur"]}, ", deformation blur is not applied to the object. When this is set to ", {"type": "q", "text": ["Acceleration Blur"]}, ", you can use the ", {"scheme": "Mantra", "value": "/props/mantra#geo_motionsamples", "type": "link", "text": "", "fallback_text": "geo_motionsamples", "fullpath": "/props/mantra#geo_motionsamples", "fragment": "#geo_motionsamples"}, " property to set the number of acceleration samples."], "extent": [123686, 123934]}, {"type": "col_group", "body": [{"ext": null, "type": "col", "indent": 4, "role": "item", "extent": [123934, 123944], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 8, "text": [{"scheme": "Image", "value": "/images/render/motionblur_velocity.jpg", "type": "img", "text": ""}], "role": "item", "extent": [123944, 124004], "body": [{"type": "summary", "indent": 12, "text": ["Velocity motion blur used the velocity attribute (", {"type": "code", "text": ["v"]}, ") to do linear motion blur."], "extent": [124004, 124103]}], "container": true}], "container": true, "role": "item_group"}], "container": true}, {"ext": null, "type": "col", "indent": 4, "role": "item", "extent": [124103, 124113], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 8, "text": [{"scheme": "Image", "value": "/images/render/motionblur_acceleration.jpg", "type": "img", "text": ""}], "role": "item", "extent": [124113, 124177], "body": [{"type": "summary", "indent": 12, "text": ["Acceleration motion blur uses the change in velocity to more accurately blue objects turning at high speed."], "extent": [124177, 124303]}], "container": true}], "container": true, "role": "item_group"}], "container": true}, {"ext": null, "type": "col", "indent": 4, "role": "item", "extent": [124303, 124313], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 8, "text": [{"scheme": "Image", "value": "/images/render/motionblur_angular_acceleration.jpg", "type": "img", "text": ""}], "role": "item", "extent": [124313, 124385], "body": [{"type": "summary", "indent": 12, "text": ["Angular acceleration blur works with object spin, such as these fast-spinning cubes."], "extent": [124385, 124489]}], "container": true}], "container": true, "role": "item_group"}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"hprop": "geo_velocityblur", "ifdprop": "object:velocityblur"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Acceleration attribute"], "role": "item", "extent": [124489, 124515], "body": [{"type": "para", "indent": 4, "text": ["This property is valid only when ", {"type": "ui", "text": ["Geometry motion blur"]}, " is set to ", {"type": "q", "text": ["Acceleration Blur"]}, ". Enter the name of a point attribute to use as the acceleration value when rendering multi-segment acceleration blur. The default is ", {"type": "code", "text": ["accel"]}, ", which may be added to geometry automatically by various simulation solvers."], "extent": [124547, 124858]}], "container": true, "attrs": {"hprop": "geo_accelattribute"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Depth of field aspect ratio"], "role": "item", "extent": [124858, 124889], "body": [{"type": "para", "indent": 4, "text": ["Controls anamorphic depth of field by changing the aspect ratio for the ellipse of confusion.  Values between 0 and 1 will increase the amount of blur in the Y direction.  Values larger than 1 will decrease the amount of blur in Y."], "extent": [124948, 125185]}], "container": true, "attrs": {"hprop": "vm_dofaspect", "ifdprop": "renderer:dofaspect"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Pixel samples"], "role": "item", "extent": [125185, 125202], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/sampling_tab/PixelSampling.jpg", "type": "img", "text": ""}], "role": "item", "extent": [125254, 125322], "body": [{"type": "para", "indent": 8, "text": ["Controls the number of primary rays Mantra will use to sample your scene per pixel. The two numbers represent an arrangement of samples in the X and Y axis and are generally the same number. However, for non-square pixels it may be necessary to use different values in X and Y. Multiplying these two values together will give you the number of primary rays per pixel."], "extent": [125322, 125703]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 4, "text": ["Increasing Pixel Samples will result in a cleaner, higher quality image. However, since all other sampling values are multiplied by the number of Pixel Samples, they should only be increased when necessary. For more details on when to increase Pixel Samples, see the \u201cRemoving Noise\u201d section."], "extent": [125703, 126001]}], "container": true, "attrs": {"hprop": "vm_samples", "ifdprop": "image:samples"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Ray variance anti-aliasing"], "role": "item", "extent": [126001, 126031], "body": [{"type": "para", "indent": 4, "text": ["When enabled, this parameter will cause Mantra to use ray variance antialiasing when determining the number of Secondary Rays to send for every Primary Ray."], "extent": [126096, 126262]}, {"type": "para", "indent": 4, "text": ["This means that rather than using a specific number of rays, Mantra will first send out a small number of rays and use this sample set to evaluate the Variance. Depending on the amount of variance, Mantra will continue to send more rays up to the ", {"type": "ui", "text": ["Max Ray Samples"]}, " value. Ray Variance Antialiasing is useful for optimizing your render by sending more rays only in the areas they are needed."], "extent": [126262, 126664]}, {"type": "para", "indent": 4, "text": ["In cases where the minimum number of rays to remove noise is equal to the maximum number of rays, you may save a small amount of render time by disabling Ray Variance Antialiasing."], "extent": [126664, 126850]}], "container": true, "attrs": {"hprop": "vm_dorayvariance", "ifdprop": "object:dorayvariance"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Max Ray Samples"], "role": "item", "extent": [126850, 126869], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Ray Variance anti-aliasing"]}, " is enabled, this parameter represents the maximum number of secondary rays allowed for each BSDF type even if the ", {"type": "ui", "text": ["Noise Level"]}, " is never reached. This parameter, along with ", {"type": "ui", "text": ["Min Ray Samples"]}, ", essentially allows you to create a range of acceptable sampling for your image. Carefully controlling the total number of potential rays is the best way to optimize your renders."], "extent": [126934, 127354]}, {"type": "para", "indent": 4, "text": ["Remember, this number is multiplied by the current number of Pixel Samples ", {"type": "em", "text": ["and"]}, " the number of BSDF types on the material being evaluated. For example, if it\u2019s a purely diffuse material, and Pixel Samples are set to 3\u00d73, and the ", {"type": "ui", "text": ["Max Ray Samples"]}, " is set to 1, then it will cast up to 9 secondary rays (9 diffuse rays). If the material is both reflective ", {"type": "em", "text": ["and"]}, " refractive, then it will cast up to 18 secondary rays (9 reflection and 9 refraction rays)."], "extent": [127354, 127817]}, {"type": "para", "indent": 4, "text": ["For more details on when to increase ", {"type": "ui", "text": ["Max Ray Samples"]}, ", see ", {"scheme": null, "value": "/render/noise", "type": "link", "text": ["removing noise"], "fullpath": "/render/noise"}, "."], "extent": [127817, 127916]}], "container": true, "attrs": {"hprop": "vm_maxraysamples", "ifdprop": "object:maxraysamples"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Min Ray Samples"], "role": "item", "extent": [127916, 127935], "body": [{"type": "para", "indent": 4, "text": ["This value is the ", {"type": "strong", "text": ["minimum number of secondary rays"]}, " to use for each BSDF type when generating an image. When ", {"type": "ui", "text": ["Ray Variance anti-aliasing"]}, " is disabled, this number represents the number of secondary rays to send regardless of the ", {"type": "ui", "text": ["Noise Level"]}, "."], "extent": [128000, 128258]}, {"type": "para", "indent": 4, "text": ["Remember, this number is multiplied by the current number of Pixel Samples ", {"type": "em", "text": ["and"]}, " the number of BSDF types on the material being evaluated."], "extent": [128258, 128402]}], "container": true, "attrs": {"hprop": "vm_minraysamples", "ifdprop": "object:minraysamples"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Noise Level"], "role": "item", "extent": [128402, 128417], "body": [{"type": "para", "indent": 4, "text": ["Represents a threshold in the ", {"type": "strong", "text": ["amount of variance allowed before mantra will send more secondary rays"]}, ". Variance essentially represents how \u201cspread out\u201d the values in a set of samples are. For instance, a set of samples that were all the same would have a variance of 0. It is generally a good idea to keep this value as high as possible so that rays are sent only into those areas where an unacceptable amount of noise is present."], "extent": [128472, 128913]}, {"type": "para", "indent": 4, "text": ["Adding \u201cdirect samples\u201d and \u201cindirect samples\u201d image planes can help you track how many samples are being sent and to which parts of the image. For more information about sampling, see the \u201cSampling and Noise\u201d section."], "extent": [128913, 129141]}, {"type": "para", "indent": 4, "text": ["If you find that certain objects in your scene require substantially more samples than other parts of your image and you are unable to \u201ctarget\u201d those objects using the Noise Level parameter, it may be a better idea to add per-object sampling parameters to the problem areas. See ", {"scheme": null, "value": "/render/noise", "type": "link", "text": ["removing noise"], "fullpath": "/render/noise"}, " for more details."], "extent": [129141, 129474]}], "container": true, "attrs": {"hprop": "vm_variance", "ifdprop": "object:variance"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Global Quality"], "role": "item", "extent": [129474, 129492], "body": [{"type": "para", "indent": 4, "text": ["Acts as a global multiplier on all per-component quality parameters. This allows you to increase/decrease quality, keeping the relative per-component qualities the same."], "extent": [129557, 129732]}], "container": true, "attrs": {"hprop": "vm_globalquality", "ifdprop": "object:globalquality"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Diffuse Quality"], "role": "item", "extent": [129732, 129751], "body": [{"type": "para", "indent": 4, "text": ["Controls the quality of ", {"type": "em", "text": ["indirect diffuse"]}, " sampling (for information on the difference between direct and indirect rays, see ", {"scheme": null, "value": "/render/sampling", "type": "link", "text": ["sampling and noise"], "fullpath": "/render/sampling"}, "). Often, indirect sources of light (such as the surfaces of other objects, and light scattered inside of a volume) will be a significant cause of noise in your renders. Turning this up should decrease this type of noise, at the cost of slowing down rendering."], "extent": [129818, 130250]}, {"type": "para", "indent": 4, "text": ["This parameter acts as a multiplier on ", {"type": "ui", "text": ["Min Ray Samples"]}, " and ", {"type": "ui", "text": ["Max Ray Samples"]}, " and also as a divisor for ", {"type": "ui", "text": ["Noise Level"]}, ". For example, if you have ", {"type": "ui", "text": ["Min Ray Samples"]}, " set to ", {"type": "code", "text": ["1"]}, ", ", {"type": "ui", "text": ["Max Ray Samples"]}, " set to ", {"type": "code", "text": ["8"]}, " and your Noise Level to ", {"type": "code", "text": ["0.1"]}, ", then set ", {"type": "ui", "text": ["Diffuse Quality"]}, " to ", {"type": "code", "text": ["2"]}, ", Mantra will send between 2 and 16 secondary diffuse ray samples based on a Noise Level of 0.05. Remember these numbers apply only to the ", {"type": "em", "text": ["indirect samples"]}, ". Mantra uses the original values for all direct sampling."], "extent": [130250, 130755]}, {"type": "para", "indent": 4, "text": ["To find how much noise is in your indirect diffuse component, add the ", {"type": "q", "text": ["Indirect Lighting (per-component)"]}, " image plane in the ", {"type": "ui", "text": ["Extra Image Planes"]}, " tab. This lets you check each indirect component individually. For this parameter, you should check the Indirect Diffuse component."], "extent": [130755, 131040]}], "container": true, "attrs": {"hprop": "vm_diffusequality", "ifdprop": "object:diffusequality"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["SSS Quality"], "role": "item", "extent": [131040, 131055], "body": [{"type": "para", "indent": 4, "text": ["Controls the quality of ", {"type": "em", "text": ["indirect sss"]}, " sampling (for information on the difference between direct and indirect rays, see ", {"scheme": null, "value": "/render/sampling", "type": "link", "text": ["sampling and noise"], "fullpath": "/render/sampling"}, "). Often, indirect sources of light (such as the surfaces of other objects, and light scattered inside of a volume) will be a significant cause of noise in your renders. Turning this up should decrease this type of noise, at the cost of slowing down rendering."], "extent": [131114, 131538]}, {"type": "para", "indent": 4, "text": ["This parameter acts as a multiplier on ", {"type": "ui", "text": ["Min Ray Samples"]}, " and ", {"type": "ui", "text": ["Max Ray Samples"]}, " and also as a divisor for ", {"type": "ui", "text": ["Noise Level"]}, ". For example, if you have ", {"type": "ui", "text": ["Min Ray Samples"]}, " set to ", {"type": "code", "text": ["1"]}, ", ", {"type": "ui", "text": ["May Ray Samples"]}, " set to ", {"type": "code", "text": ["8"]}, " and your Noise Level to ", {"type": "code", "text": ["0.1"]}, ", then set ", {"type": "ui", "text": ["SSS Quality"]}, " to ", {"type": "code", "text": ["2"]}, ", Mantra will send between 2 and 16 secondary SSS ray samples based on a Noise Level of 0.05. Remember these numbers apply only to the ", {"type": "em", "text": ["indirect samples"]}, ". Mantra uses the original values for all direct sampling."], "extent": [131538, 132031]}, {"type": "para", "indent": 4, "text": ["To find how much noise is in your indirect SSS component, add the ", {"type": "q", "text": ["Indirect Lighting (per-component)"]}, " image plane in the ", {"type": "ui", "text": ["Extra Image Planes"]}, " tab. This lets you check each indirect component individually."], "extent": [132031, 132243]}], "container": true, "attrs": {"hprop": "vm_sssquality", "ifdprop": "object:sssquality"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Refraction Quality"], "role": "item", "extent": [132243, 132265], "body": [{"type": "para", "indent": 4, "text": ["Controls the quality of ", {"type": "em", "text": ["indirect refraction"]}, " sampling (for information on the difference between direct and indirect rays, see ", {"scheme": null, "value": "/render/sampling", "type": "link", "text": ["sampling and noise"], "fullpath": "/render/sampling"}, "). Indirect refractions (refracted light from of other objects in the scene, such as when viewing an object through glass) can sometimes add noise to the render. Turning this up should decrease this type of noise, at the cost of slowing down rendering."], "extent": [132342, 132769]}, {"type": "para", "indent": 4, "text": ["This parameter acts as a multiplier on ", {"type": "ui", "text": ["Min Ray Samples"]}, " and ", {"type": "ui", "text": ["Max Ray Samples"]}, " and also as a divisor for ", {"type": "ui", "text": ["Noise Level"]}, ". For example, if you have ", {"type": "ui", "text": ["Min Ray Samples"]}, " set to ", {"type": "code", "text": ["1"]}, ", ", {"type": "ui", "text": ["May Ray Samples"]}, " set to ", {"type": "code", "text": ["8"]}, " and your Noise Level to ", {"type": "code", "text": ["0.1"]}, ", then set ", {"type": "ui", "text": ["Refract Quality"]}, " to ", {"type": "code", "text": ["2"]}, ", Mantra will send between 2 and 16 secondary refraction ray samples based on a Noise Level of 0.05. Remember these numbers apply only to the ", {"type": "em", "text": ["indirect samples"]}, ". Mantra uses the original values for all direct sampling."], "extent": [132769, 133277]}, {"type": "para", "indent": 4, "text": ["To find how much noise is in your indirect refraction component, add the ", {"type": "q", "text": ["Indirect Lighting (per-component)"]}, " image plane in the ", {"type": "ui", "text": ["Extra Image Planes"]}, " tab. This lets you check each indirect component individually. For this parameter, you should check the Indirect Refraction component."], "extent": [133277, 133572]}], "container": true, "attrs": {"hprop": "vm_refractionquality", "ifdprop": "object:refractionquality"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Reflection Quality"], "role": "item", "extent": [133572, 133594], "body": [{"type": "para", "indent": 4, "text": ["Controls the quality of ", {"type": "em", "text": ["indirect reflection"]}, " sampling (for information on the difference between direct and indirect rays, see ", {"scheme": null, "value": "/render/sampling", "type": "link", "text": ["sampling and noise"], "fullpath": "/render/sampling"}, "). Indirect reflections (reflections of other objects in the scene) can sometimes add noise to the render. Turning this up should decrease this type of noise, at the cost of slowing down rendering."], "extent": [133667, 134039]}, {"type": "para", "indent": 4, "text": ["This parameter acts as a multiplier on ", {"type": "ui", "text": ["Min Ray Samples"]}, " and ", {"type": "ui", "text": ["Max Ray Samples"]}, " and also as a divisor for ", {"type": "ui", "text": ["Noise Level"]}, ". For example, if you have ", {"type": "ui", "text": ["Min Ray Samples"]}, " set to ", {"type": "code", "text": ["1"]}, ", ", {"type": "ui", "text": ["May Ray Samples"]}, " set to ", {"type": "code", "text": ["8"]}, " and your Noise Level to ", {"type": "code", "text": ["0.1"]}, ", then set ", {"type": "ui", "text": ["Reflect Quality"]}, " to ", {"type": "code", "text": ["2"]}, ", Mantra will send between 2 and 16 secondary reflection ray samples based on a Noise Level of 0.05. Remember these numbers apply only to the ", {"type": "em", "text": ["indirect samples"]}, ". Mantra uses the original values for all direct sampling."], "extent": [134039, 134547]}, {"type": "para", "indent": 4, "text": ["To find how much noise is in your indirect reflection component, add the ", {"type": "q", "text": ["Indirect Lighting (per-component)"]}, " image plane in the ", {"type": "ui", "text": ["Extra Image Planes"]}, " tab. This lets you check each indirect component individually. For this parameter, you should check the Indirect Reflection component."], "extent": [134547, 134838]}], "container": true, "attrs": {"hprop": "vm_reflectionquality", "ifdprop": "object:reflectionquality"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Volume Quality"], "role": "item", "extent": [134838, 134856], "body": [{"type": "para", "indent": 4, "text": ["Controls the quality of ", {"type": "em", "text": ["indirect volume"]}, " sampling (for information on the difference between direct and indirect rays, see ", {"scheme": null, "value": "/render/sampling", "type": "link", "text": ["sampling and noise"], "fullpath": "/render/sampling"}, "). Often, indirect sources of light (such as the surfaces of other objects, and light scattered inside of a volume) will be a significant cause of noise in your renders. Turning this up should decrease this type of noise, at the cost of slowing down rendering."], "extent": [134921, 135352]}, {"type": "para", "indent": 4, "text": ["This parameter acts as a multiplier on ", {"type": "ui", "text": ["Min Ray Samples"]}, " and ", {"type": "ui", "text": ["Max Ray Samples"]}, " and also as a divisor for ", {"type": "ui", "text": ["Noise Level"]}, ". For example, if you have ", {"type": "ui", "text": ["Min Ray Samples"]}, " set to ", {"type": "code", "text": ["1"]}, ", ", {"type": "ui", "text": ["May Ray Samples"]}, " set to ", {"type": "code", "text": ["8"]}, " and your Noise Level to ", {"type": "code", "text": ["0.1"]}, ", then set ", {"type": "ui", "text": ["Volume Quality"]}, " to ", {"type": "code", "text": ["2"]}, ", Mantra will send between 2 and 16 secondary volume ray samples based on a Noise Level of 0.05. Remember these numbers apply only to the ", {"type": "em", "text": ["indirect samples"]}, ". Mantra uses the original values for all direct sampling."], "extent": [135352, 135855]}, {"type": "para", "indent": 4, "text": ["To find how much noise is in your indirect volume component, add the ", {"type": "q", "text": ["Indirect Lighting (per-component)"]}, " image plane in the ", {"type": "ui", "text": ["Extra Image Planes"]}, " tab. This lets you check each indirect component individually. For this parameter, you should check the Indirect Volume component."], "extent": [135855, 136142]}], "container": true, "attrs": {"hprop": "vm_volumequality", "ifdprop": "object:volumequality"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Variance color space"], "role": "item", "extent": [136142, 136166], "body": [{"type": "para", "indent": 4, "text": ["Sampling color space for variance antialiasing.  Setting this to Gamma 2.2 will cause darker parts of the image to receive more samples."], "extent": [136227, 136369]}], "container": true, "attrs": {"hprop": "vm_colorspace", "ifdprop": "renderer:colorspace"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Enable Indirect Sample Limits"], "role": "item", "extent": [136369, 136402], "body": [{"type": "para", "indent": 4, "text": ["Decouples the Direct from Indirect Rays, allowing for different sampling rates as well as separate noise levels. Generally speaking, it will only be necessary to enable this parameter if you find that too many samples are being sent as Direct Rays."], "extent": [136473, 136731]}, {"type": "para", "indent": 4, "text": ["Adding \u201cdirect samples\u201d and \u201cindirect samples\u201d image planes can help you track how many samples are being sent and to which parts of the image. For more information about sampling, see the \u201cSampling and Noise\u201d section."], "extent": [136731, 136959]}, {"type": "para", "indent": 4, "text": ["This parameter will enable three new parameters: ", {"type": "ui", "text": ["Min Indirect Ray Samples"]}, ", ", {"type": "ui", "text": ["Max Indirect Ray Samples"]}, ", and ", {"type": "ui", "text": ["Indirect Noise Level"]}, "."], "extent": [136959, 137107]}, {"type": "para", "indent": 4, "text": ["To understand the difference between Direct and Indirect rays, see ", {"scheme": null, "value": "/render/sampling", "type": "link", "text": ["sampling and noise"], "fullpath": "/render/sampling"}, "."], "extent": [137107, 137218]}], "container": true, "attrs": {"hprop": "vm_decoupleindirect", "ifdprop": "object:decoupleindirect"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Min Indirect Ray Samples"], "role": "item", "extent": [137218, 137246], "body": [{"type": "para", "indent": 4, "text": ["The ", {"type": "strong", "text": ["minimum number of indirect rays"]}, " to use when generating an image. Generally speaking indirect rays are used when sampling other objects and their material properties. For more information about indirect rays see \u201cSampling and Noise\u201d."], "extent": [137327, 137575]}, {"type": "para", "indent": 4, "text": ["Remember, like the previous Ray Sample limits, this value is multiplied by the current number of Pixel Samples."], "extent": [137575, 137692]}], "container": true, "attrs": {"hprop": "vm_minindirectraysamples", "ifdprop": "object:minindirectraysamples"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Max Indirect Ray Samples"], "role": "item", "extent": [137692, 137720], "body": [{"type": "para", "indent": 4, "text": ["The ", {"type": "strong", "text": ["maximum number of indirect rays"]}, " to use when generating an image, ", {"type": "em", "text": ["even if the Indirect Noise level is never reached"]}, ". This parameter, along with ", {"type": "ui", "text": ["Min Indirect Ray Samples"]}, ", essentially allows you to create a range of acceptable sampling for your image. Carefully controlling the total number of potential rays is the best way to optimize your renders."], "extent": [137801, 138170]}, {"type": "para", "indent": 4, "text": ["Remember, this number is multiplied by the current number of Pixel Samples."], "extent": [138170, 138255]}, {"type": "para", "indent": 4, "text": ["For more details on when to increase ", {"type": "ui", "text": ["Max Indirect Ray Samples"]}, ", see ", {"scheme": null, "value": "/render/noise", "type": "link", "text": ["removing noise"], "fullpath": "/render/noise"}, "."], "extent": [138255, 138363]}], "container": true, "attrs": {"hprop": "vm_maxindirectraysamples", "ifdprop": "object:maxindirectraysamples"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Indirect Noise Level"], "role": "item", "extent": [138363, 138387], "body": [{"type": "para", "indent": 4, "text": ["A threshold in the ", {"type": "strong", "text": ["amount of variance allowed before mantra will send more indirect rays"]}, ". Variance essentially represents how \u201cspread out\u201d the values in a set of samples are, a set of samples that were all the same would have a variance of 0. It is generally a good idea to keep this value as high as possible so that rays are sent only into those areas where an unacceptable amount of noise is present."], "extent": [138458, 138873]}, {"type": "para", "indent": 4, "text": ["Adding \u201cdirect samples\u201d and \u201cindirect samples\u201d image planes can help you track how many samples are being sent and to which parts of the image. For more information about sampling, see the \u201cSampling and Noise\u201d section."], "extent": [138873, 139101]}, {"type": "para", "indent": 4, "text": ["If you find that certain objects in your scene require substantially more samples than other parts of your image and you are unable to \u201ctarget\u201d those objects using the Noise Level parameter, it may be a better idea to add per-object sampling parameters to the problem areas. See ", {"scheme": null, "value": "/render/noise", "type": "link", "text": ["removing noise"], "fullpath": "/render/noise"}, " for more details."], "extent": [139101, 139434]}], "container": true, "attrs": {"hprop": "vm_indirectvariance", "ifdprop": "object:indirectvariance"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Sampling quality"], "role": "item", "extent": [139434, 139454], "body": [{"type": "para", "indent": 4, "text": ["The relative number of illumination samples to be used for the light source.  Sampling Quality is relative to the ray sampling parameters (", {"type": "code", "text": ["vm_minraysamples"]}, " and ", {"type": "code", "text": ["vm_maxraysamples"]}, ")."], "extent": [139522, 139710]}], "container": true, "attrs": {"hprop": "vm_samplingquality", "ifdprop": "light:samplingquality"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Jitter"], "role": "item", "extent": [139710, 139720], "body": [{"type": "para", "indent": 4, "text": ["A floating point value which adds noise to pixel sampling patterns. A value of 1 will fully randomize pixel sampling patterns, while a value of 0 turns of pixel jitter resulting in stairstep artifacts when too few pixel samples are used. Jitter only applies to pixel antialiasing and does not apply to motion blur or depth of field sampling (which are always randomized)."], "extent": [139770, 140147]}], "container": true, "attrs": {"hprop": "vm_jitter", "ifdprop": "image:jitter"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Random seed"], "role": "item", "extent": [140147, 140162], "body": [{"type": "para", "indent": 4, "text": ["Adjusting this parameter will cause the pixel sampling patterns used by Mantra to be regenerated in different configurations. By default, the patterns change on every frame, so manually changing this value is not necessary."], "extent": [140223, 140452]}], "container": true, "attrs": {"hprop": "vm_randomseed", "ifdprop": "renderer:randomseed"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Sample lock"], "role": "item", "extent": [140452, 140467], "body": [{"type": "para", "indent": 4, "text": ["Sampling generally occurs in random patterns which change on every frame of an animation. This can cause a distracting \u201cbuzz\u201d when there is a significant amount of noise in your images which can make evaluation of other aspects of the scene difficult. Enabling this parameter will \u201clock\u201d the sampling patterns so that the noise remains the same on every frame."], "extent": [140525, 140895]}, {"type": "para", "indent": 4, "text": ["Also, in some cases where the final rendered images will be sent through a post-render de- noise process, it can be useful to have the noise remain constant frame to frame. Consistent sampling patterns can help when analyzing the noise."], "extent": [140895, 141141]}, {"type": "para", "indent": 4, "text": ["It defaults to \u201coff\u201d because it is generally unacceptable to have a locked sampling pattern for final sequences."], "extent": [141141, 141259]}], "container": true, "attrs": {"hprop": "vm_samplelock", "ifdprop": "image:samplelock"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Decorrelate Depth of Field from Motion Blur Samples"], "role": "item", "extent": [141259, 141314], "body": [{"type": "para", "indent": 4, "text": ["For scenes using both motion blur and depth of field, mantra\u2019s default\n    image sampling patterns correlate the time and depth of field samples.\n    This has the effect of reducing noise, but can lead to correlation\n    artifacts (banding) in the render in parts of the image where there is\n    both significant motion blur and depth of field.  Decorrelating depth\n    of field from motion blur by enabling this setting will eliminate these\n    banding artifacts while increasing the noise in the render."], "extent": [141380, 141891]}, {"type": "para", "indent": 4, "text": ["For micropolygon rendering, there is a performance penalty when\n    enabling this property, since mantra optimizes micropolygon rendering\n    for correlated depth of field sampling patterns.  There is no\n    performance penalty for ray tracing."], "extent": [141891, 142141]}], "container": true, "attrs": {"hprop": "vm_decorrelatedof", "ifdprop": "image:decorrelatedof"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Bokeh"], "role": "item", "extent": [142141, 142150], "body": [{"type": "para", "indent": 4, "text": ["Filter kernel used in depth of field rendering. Use the pop-up menu to the right of the text box to choose from the available options."], "extent": [142199, 142339]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Radial bokeh (", {"type": "code", "text": ["radial"]}, ")"], "extent": [142339, 142368], "body": [{"type": "para", "indent": 8, "text": ["Use a gaussian filter kernel (highest quality)."], "extent": [142368, 142425]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Image file bokeh (", {"type": "code", "text": ["file"]}, ")"], "extent": [142425, 142456], "body": [{"type": "para", "indent": 8, "text": ["Use an image file "], "extent": [142456, 142484]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Box filter bokeh (", {"type": "code", "text": ["box"]}, ")"], "extent": [142484, 142514], "body": [{"type": "para", "indent": 8, "text": ["Use a box filter kernal."], "extent": [142514, 142548]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Disable bokeh (", {"type": "code", "text": ["null"]}, ")"], "extent": [142548, 142576], "body": [{"type": "para", "indent": 8, "text": ["Do not filter."], "extent": [142576, 142600]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_bokeh", "ifdprop": "camera:bokeh"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Bokeh image file"], "role": "item", "extent": [142600, 142620], "body": [{"type": "para", "indent": 4, "text": ["The file to use for ", {"type": "q", "text": ["file"]}, " shaped bokeh.  White/black cutout images that delineate the shape of the lens are good candidates, where white regions represent the areas that light passes through."], "extent": [142673, 142871]}], "container": true, "attrs": {"hprop": "vm_bokehfile", "ifdprop": "camera:bokeh"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Bokeh rotation"], "role": "item", "extent": [142871, 142889], "body": [{"type": "para", "indent": 4, "text": ["The rotation for ", {"type": "q", "text": ["file"]}, " shaped bokeh."], "extent": [142946, 142989]}], "container": true, "attrs": {"hprop": "vm_bokehrotation", "ifdprop": "camera:bokeh"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Volume velocity quality"], "role": "item", "extent": [142989, 143016], "body": [{"type": "para", "indent": 4, "text": ["A scale on the native step size that determines how finely mantra will\n    subdivide the velocity blur ray tracing cage. For voxel volume\n    primitives, the default of 0.1 means to take one velocity sample every\n    10 voxels.  Smaller values will speed up renders but may introduce\n    inaccuracy in the resulting motion blur."], "extent": [143085, 143419]}], "container": true, "attrs": {"hprop": "vm_velocityquality", "ifdprop": "object:velocityquality"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Volume step rate"], "role": "item", "extent": [143419, 143439], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/sampling_tab/VolumeQuality.jpg", "type": "img", "text": ""}], "role": "item", "extent": [143506, 143573], "body": [{"type": "para", "indent": 8, "text": ["How finely or coarsely a volume is sampled as a ray travels through it. Volumetric objects are made up of 3d structures called Voxels, the value of this parameter represents the number of voxels a ray will travel through before performing another sample."], "extent": [143573, 143841]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 4, "text": ["The default value is ", {"type": "code", "text": ["0.25"]}, ", which means that every one of every four voxels will be sampled. A value of ", {"type": "code", "text": ["1"]}, " would mean that all voxels are sampled and a value of 2 would mean that all voxels are sampled twice. This means that the volume step rate value behaves in a similar way to pixel samples, acting as a multiplier on the total number of samples for volumetric objects."], "extent": [143841, 144225]}, {"type": "para", "indent": 4, "text": ["For volumes that aren\u2019t voxel based, like CVEX procedural volumes, Mantra will divide the bounding box of the volume into roughly 100 \u201cvirtual\u201d voxels. In these cases, setting the Volume Step Rate correctly is essential to maintaining the correct level of detail."], "extent": [144225, 144498]}, {"type": "para", "indent": 4, "text": ["Keep in mind that increasing the volume step rate can dramatically increase render times, so it should only be adjusted when necessary. Also, while increasing the default from ", {"type": "code", "text": ["0.25"]}, " can reduce volumetric noise, increasing the value beyond ", {"type": "code", "text": ["1"]}, " will rarely see similar results."], "extent": [144498, 144784]}, {"type": "para", "indent": 4, "text": ["For more information about volume sampling, see ", {"scheme": null, "value": "/render/sampling", "type": "link", "text": ["sampling and noise"], "fullpath": "/render/sampling"}, "."], "extent": [144784, 144876]}], "container": true, "attrs": {"hprop": "vm_volumesteprate", "ifdprop": "object:volumesteprate"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Uniform volume"], "role": "item", "extent": [144876, 144894], "body": [{"type": "para", "indent": 4, "text": ["Whether to render this object as if it was a uniform-density volume. Using this property on surface geometry is more efficient than actually creating a volume object of uniform density, since the renderer can assume that the volume density is uniform and place samples more optimally. The surface normal of the surface is used to determine which side of the surface will render as a volume - the normal will point away from the interior. The surface need not be closed - if the surface is not closed, the volume will extend an infinite distance away from the surface. Non-closed surfaces may produce unexpected results near the edge of the surface, so try to keep the viewing camera away from the edges. This parameter is compatible with ray tracing and PBR but not micropolygon renders."], "extent": [144963, 145756]}], "container": true, "attrs": {"hprop": "vm_volumeuniform", "ifdprop": "object:volumeuniform"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Uniform volume type"], "role": "item", "extent": [145756, 145779], "body": [{"type": "para", "indent": 4, "text": ["Determines the type of uniform volume. ", {"type": "code", "text": ["Continuous"]}, " samples along a series of points within the intersected volume object. ", {"type": "code", "text": ["Segment"]}, " samples once per-segment within the intersected volume object."], "extent": [145852, 146053]}], "container": true, "attrs": {"hprop": "vm_volumeuniformtype", "ifdprop": "object:volumeuniformtype"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Uniform volume flipped normal detection threshold"], "role": "item", "extent": [146053, 146106], "body": [{"type": "para", "indent": 4, "text": ["When there are flipped normals due to reversed geometry or self intersections, mantra may misjudge volume spans and cause artifacts in render. Mantra will try to correct for such a case, provided that the distances between the intersections fall within this threshold."], "extent": [146191, 146465]}], "container": true, "attrs": {"hprop": "vm_volumeuniformflipthresh", "ifdprop": "object:volumeuniformflipthresh"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Volume surface"], "role": "item", "extent": [146465, 146483], "body": [{"type": "para", "indent": 4, "text": ["When rendering a uniform volume (", {"type": "code", "text": ["vm_uniformvolume"]}, " is enabled), this setting controls whether the surface is also rendered.  If you enable this setting, the surface shader should handle both volume and surface samples by checking the value of the dPdz global - when it is 0 the shader should render a surface, otherwise a volume."], "extent": [146548, 146884]}], "container": true, "attrs": {"hprop": "vm_volumesurface", "ifdprop": "object:volumesurface"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Volume isosurface"], "role": "item", "extent": [146884, 146905], "body": [{"type": "para", "indent": 4, "text": ["Rather than generating samples inside a volume, this setting will configure the renderer so that it automatically finds an isosurface of the volume density field and renders this as a surface.  The ", {"type": "code", "text": ["vm_volumedensity"]}, " parameter is used as a threshold to control the isosurface density threshold. You should use an ordinary surface shader when rendering volumes with this setting enabled - not a volume rendering surface shader."], "extent": [146962, 147398]}, {"type": "para", "indent": 4, "text": ["By default, the isosurface is found by ray marching through the volume to find points where the threshold density is crossed. This means that to improve render accuracy, you can increase the ", {"type": "code", "text": ["vm_volumesteprate"]}, " parameter. Some volume types use a native accelerated isosurface search technique in which case the volume step rate is ignored and the isosurface is determined analytically for that particular type of volume. VDB volumes, for example, use this analytic isosurface rendering approach. The ", {"type": "code", "text": ["vm_volumeisodefault"]}, " parameter can be used to disable this native intersection algorithm."], "extent": [147398, 147994]}], "container": true, "attrs": {"hprop": "vm_volumeiso", "ifdprop": "object:volumeiso"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Use default volume isosurface evaluator"], "role": "item", "extent": [147994, 148036], "body": [{"type": "para", "indent": 4, "text": ["Disable native volume isosurface for this object when ", {"type": "code", "text": ["vm_volumeiso"]}, " is enabled. This parameter will only affect volume types that have a native isosurface algorithm - including VDB volumes."], "extent": [148107, 148303]}], "container": true, "attrs": {"hprop": "vm_volumeisodefault", "ifdprop": "object:volumeisodefault"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Volume density"], "role": "item", "extent": [148303, 148321], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "code", "text": ["vm_volumeuniform"]}, " is on, the uniform density of the object\u2019s volume. This value must be the same on the object as on the Volume Cloud shader.  When ", {"type": "code", "text": ["vm_volumeiso"]}, " is on, this value specifies the threshold density value for isosurface rendering."], "extent": [148390, 148646]}], "container": true, "attrs": {"hprop": "vm_volumedensity", "ifdprop": "object:volumedensity"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Volume samples"], "role": "item", "extent": [148646, 148664], "body": [{"type": "para", "indent": 4, "text": ["The number of samples to generate when rendering a uniform volume (", {"type": "code", "text": ["vm_uniformvolume"]}, " is enabled).  The samples will be distributed so as to produce an equal image contribution if they were all equal in brightness."], "extent": [148729, 148949]}], "container": true, "attrs": {"hprop": "vm_volumesamples", "ifdprop": "object:volumesamples"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Volume shadow step rate"], "role": "item", "extent": [148949, 148976], "body": [{"type": "para", "indent": 4, "text": ["A factor to proportionally decrease the volume step rate only for shadows, relative to the volume step rate. Smaller values will cause mantra to use a larger ray march step size for shadow rays than other shading rays.  A value of 1 will produce equal quality for shadow rays and shading rays."], "extent": [149055, 149354]}], "container": true, "attrs": {"hprop": "vm_volumeshadowsteprate", "ifdprop": "object:volumeshadowsteprate"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Volume zero threshold"], "role": "item", "extent": [149354, 149379], "body": [{"type": "para", "indent": 4, "text": ["Specifies the minimum density value that will be rendered.  Using a larger zero threshold can improve rendering performance by reducing the amount of shading and sampling that occurs in nearly empty parts of the volume.  Using too large a zero threshold can introduce clipping artifacts in the render."], "extent": [149450, 149757]}], "container": true, "attrs": {"hprop": "vm_volumezerothresh", "ifdprop": "object:volumezerothresh"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Volume sampling channel"], "role": "item", "extent": [149757, 149784], "body": [{"type": "para", "indent": 4, "text": ["Specifies the volume channel by name that will be used for empty space culling.  By default mantra will use the 'density' channel if it exists.  If you are rendering an emissive volume in which some parts of the volume have a 0 density but still need to be rendered, you should specify a different channel using this parameter.  If the specified channel is not found, mantra will assume that the entire volume needs to be rendered and no culling will occur.  The sampling channel should be structured such that values less than the ", {"type": "code", "text": ["vm_volumezerothresh"]}, " indicate empty space."], "extent": [149865, 150446]}], "container": true, "attrs": {"hprop": "vm_volumesamplingchannel", "ifdprop": "object:volumesamplingchannel"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Volume Up Vector"], "role": "item", "extent": [150446, 150466], "body": [{"type": "para", "indent": 4, "text": ["Used for uniform volumes when doing inside/outside tests."], "extent": [150533, 150596]}], "container": true, "attrs": {"hprop": "vm_volumeupvector", "ifdprop": "object:volumeupvector"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Stochastic transparency"], "role": "item", "extent": [150596, 150623], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 4, "text": [{"scheme": "Image", "value": "/images/render/mug/sampling/VolumeSamplingStochastic.jpg", "type": "img", "text": ""}], "role": "item", "extent": [150683, 150757], "body": [{"type": "para", "indent": 8, "text": ["The number of transparent samples to be shaded as a ray travels through translucent objects. Increasing this value will result in less noise in translucent objects and is generally less costly than increasing Pixel samples, Volume Step Rate, or Min and Max ray samples. Stochastic Sampling will not have any effect on noise from Indirect Sources however."], "extent": [150757, 151121]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 4, "text": ["This may make the image noisier than without stochastic transparency, so you may need to compensate by, for example, increasing the pixel samples. You should generally leave this option on."], "extent": [151121, 151320]}, {"type": "para", "indent": 4, "text": ["The renderer ignores this option for micropolygon rendering (except for secondary ray tracing) and for renders that only generate opacity (such as deep shadow maps). In those cases it is more efficient to composite all the transparent shading results."], "extent": [151320, 151581]}, {"type": "para", "indent": 4, "text": ["Added in Houdini 12."], "extent": [151581, 151607]}], "container": true, "attrs": {"hprop": "vm_transparent", "ifdprop": "image:transparent"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Stochastic samples"], "role": "item", "extent": [151607, 151629], "body": [{"type": "para", "indent": 4, "text": ["The number of transparent samples to shade when ", {"scheme": null, "value": "#vm_transparent", "type": "link", "text": ["Stochastic Transparency"], "fullpath": "/props/mantra#vm_transparent", "fragment": "#vm_transparent"}, " is on. Higher values improve shading quality for volumes and transparent surfaces, but are slower to render."], "extent": [151703, 151907]}], "container": true, "attrs": {"hprop": "vm_transparentsamples", "ifdprop": "image:transparentsamples"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Allow image motion blur"], "role": "item", "extent": [151907, 151934], "body": [{"type": "para", "indent": 4, "text": ["Occasionally, when motion blur is going to be added to an image as a post-process or for other compositing operations, it is necessary to calculate the motion blur but not include it in the final rendered image. In these cases, Allow Image Motion Blur should be disabled."], "extent": [151997, 152274]}, {"type": "para", "indent": 4, "text": ["This means that the blurred positions necessary for Motion Blur can be exported as a custom Motion Vector Image Plane from within a shader using the GetBlurP() function without the small overhead of doing the actual shading in the render."], "extent": [152274, 152518]}, {"type": "para", "indent": 4, "text": ["This parameter is related to the motion blur parameters which are available only when Motion Blur is enabled. Disabling this option will cause motion blur to be removed from the final rendered image, however the blurred Position will still be calculated, allowing for custom motion vector image planes to be created."], "extent": [152518, 152840]}], "container": true, "attrs": {"hprop": "vm_imageblur", "ifdprop": "renderer:imageblur"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["SSS sampling mode"], "role": "item", "extent": [152840, 152861], "body": [{"type": "para", "indent": 4, "text": ["Sampling strategy to use for PBR SSS in direct lighting. The default is ", {"type": "code", "text": ["Perceptual"]}, "."], "extent": [152938, 153029]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["Ideal"]}], "extent": [153029, 153042], "body": [{"type": "para", "indent": 8, "text": ["Sample distribution matches the diffusion profile perfectly."], "extent": [153042, 153112]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["Perceptual"]}], "extent": [153112, 153130], "body": [{"type": "para", "indent": 8, "text": ["Sample distribution is biased toward low-energy areas so that unlit regions may converge faster."], "extent": [153130, 153236]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_pbrssssamplingmode", "ifdprop": "renderer:pbrssssamplingmode"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Shaders"], "extent": [153236, 153250], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Rendering properties"], "role": "item", "extent": [153250, 153275], "body": [], "container": true, "attrs": {"hprop": "shop_propertiespath"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Material"], "role": "item", "extent": [153308, 153320], "body": [], "container": true, "attrs": {"hprop": "shop_materialpath"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Surface shader"], "role": "item", "extent": [153351, 153369], "body": [], "container": true, "attrs": {"hprop": "shop_surfacepath", "ifdprop": "object:surface"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Disable surface shader rendering"], "role": "item", "extent": [153428, 153464], "body": [], "container": true, "attrs": {"hprop": "shop_disable_surface_shader"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Photon shader"], "role": "item", "extent": [153505, 153522], "body": [], "container": true, "attrs": {"hprop": "shop_photonpath"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Displacement shader"], "role": "item", "extent": [153551, 153574], "body": [], "container": true, "attrs": {"hprop": "shop_displacepath", "ifdprop": "object:displace"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Disable displace shader rendering"], "role": "item", "extent": [153635, 153672], "body": [], "container": true, "attrs": {"hprop": "shop_disable_displace_shader"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Matte shader"], "role": "item", "extent": [153714, 153730], "body": [{"type": "para", "indent": 4, "text": ["When the object has matte shading enabled, this shader is used for primary ray shading instead of the surface shader."], "extent": [153795, 153918]}], "container": true, "attrs": {"hprop": "vm_matteshader", "ifdprop": "object:matteshader"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Light shader"], "role": "item", "extent": [153918, 153934], "body": [], "container": true, "attrs": {"hprop": "shop_lightpath"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Disable light shader rendering"], "role": "item", "extent": [153962, 153996], "body": [], "container": true, "attrs": {"hprop": "shop_disable_light_shader"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Shadow shader"], "role": "item", "extent": [154035, 154052], "body": [], "container": true, "attrs": {"hprop": "shop_shadowpath", "ifdprop": "object:shadow"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Disable shadow shader rendering"], "role": "item", "extent": [154109, 154144], "body": [], "container": true, "attrs": {"hprop": "shop_disable_shadow_shader"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Fog shader"], "role": "item", "extent": [154184, 154198], "body": [], "container": true, "attrs": {"hprop": "shop_fogpath"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Disable fog shader rendering"], "role": "item", "extent": [154224, 154256], "body": [], "container": true, "attrs": {"hprop": "shop_disable_fog_shader"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Disable geometry shader rendering"], "role": "item", "extent": [154293, 154330], "body": [], "container": true, "attrs": {"hprop": "shop_disable_geometry_shader"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Material style sheet"], "role": "item", "extent": [154372, 154396], "body": [{"type": "para", "indent": 4, "text": ["On object nodes, this parameter defines a material style sheet to be applied\n    to this object' geometry. A material style sheet determines the geometry\n    look by assigning various shaders and materials to different pieces\n    of the geometry (primitives) and by overriding shader parameters\n    for rendering just these pieces."], "extent": [154473, 154810]}, {"type": "para", "indent": 4, "text": ["The style sheet definition in this parameter is specified using a JSON \n    format, but can be edited in Data Tree pane with Material Style Sheets view."], "extent": [154810, 154968]}], "container": true, "attrs": {"hprop": "shop_materialstylesheet", "ifdprop": "object:materialstylesheet"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Shading"], "extent": [154968, 154982], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Diffuse Components"], "role": "item", "extent": [154982, 155005], "body": [{"type": "para", "indent": 4, "text": ["A space-separated list of component types that will behave like diffuse bounces.  This will affect which reflection scope is used based on the ray type and also which bounce limit to use.  Uncategorized component types are assumed to be reflections."], "extent": [155080, 155335]}], "container": true, "attrs": {"hprop": "vm_diffusecomponents", "ifdprop": "renderer:diffusecomponents"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Refract Components"], "role": "item", "extent": [155335, 155357], "body": [{"type": "para", "indent": 4, "text": ["A space-separated list of component types that will behave like refract bounces.  This will affect which reflection scope is used based on the ray type and also which bounce limit to use.  Uncategorized component types are assumed to be reflections."], "extent": [155432, 155687]}], "container": true, "attrs": {"hprop": "vm_refractcomponents", "ifdprop": "renderer:refractcomponents"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Volume Components"], "role": "item", "extent": [155687, 155708], "body": [{"type": "para", "indent": 4, "text": ["A space-separated list of component types that will behave like volume bounces.  This will affect which reflection scope is used based on the ray type and also which bounce limit to use.  Uncategorized component types are assumed to be reflections."], "extent": [155781, 156035]}], "container": true, "attrs": {"hprop": "vm_volumecomponents", "ifdprop": "renderer:volumecomponents"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["SSS Components"], "role": "item", "extent": [156035, 156053], "body": [{"type": "para", "indent": 4, "text": ["A space-separated list of component types that will behave like subsurface scatter bounces.  This will affect which reflection scope is used based on the ray type and also which bounce limit to use.  Uncategorized component types are assumed to be reflections."], "extent": [156120, 156386]}], "container": true, "attrs": {"hprop": "vm_ssscomponents", "ifdprop": "renderer:ssscomponents"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Variables imported by fog shaders"], "role": "item", "extent": [156386, 156423], "body": [{"type": "para", "indent": 4, "text": ["To save on computation, mantra will only compute exports on surface shaders if the variable needs to be saved to an image plane.  This means that some surface exports may not be available in fog shaders for the ", {"type": "code", "text": ["simport()"]}, " function.  This parameter specifies a list of variables which need to be computed for fog shaders."], "extent": [156484, 156811]}], "container": true, "attrs": {"hprop": "vm_fogimports", "ifdprop": "renderer:fogimports"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Enable Absorption and Nested Dielectrics"], "role": "item", "extent": [156811, 156855], "body": [{"type": "para", "indent": 4, "text": ["To save on computation, mantra will only compute exports on surface shaders if the variable needs to be saved to an image plane.  This means that some surface exports may not be available in fog shaders for the ", {"type": "code", "text": ["simport()"]}, " function.  However, to properly render advanced features like absorption and nested dielectrics, additional exports from surface shaders are required.  This enables on these special exports."], "extent": [156928, 157347]}], "container": true, "attrs": {"hprop": "vm_nesteddielectric", "ifdprop": "renderer:nesteddielectric"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Allowable paths"], "role": "item", "extent": [157347, 157366], "body": [{"type": "para", "indent": 4, "text": ["The type of path tracing to perform in PBR mode."], "extent": [157429, 157487]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["diffuse"]}], "extent": [157487, 157502], "body": [{"type": "para", "indent": 8, "text": ["Trace all diffuse and specular bounces, but once a diffuse bounce is encountered continue tracing only diffuse reflections."], "extent": [157502, 157643]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["all"]}], "extent": [157643, 157654], "body": [{"type": "para", "indent": 8, "text": ["All paths are traced.  This option can be used to enable rendering of caustics without the use of photon maps. However when using point or small area lights, the rendered result can turn out to be extremely noisy."], "extent": [157654, 157877]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_pbrpathtype", "ifdprop": "renderer:pbrpathtype"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Constrain by Maximum Roughness"], "role": "item", "extent": [157877, 157911], "body": [{"type": "para", "indent": 4, "text": ["Roughness parameter in GGX BSDFs are clamped by the maximum roughness value propagated down the ray chain in pathtracing. Enabling this option can cut out a lot of noise in indirect specular (in particular, cases where glossy surface is reflected by a rough specular surface) at the cost of a bit of accuracy."], "extent": [157986, 158301]}], "container": true, "attrs": {"hprop": "vm_constrainmaxrough", "ifdprop": "renderer:constrainmaxrough"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Generator Shader"], "role": "item", "extent": [158301, 158321], "body": [{"type": "para", "indent": 4, "text": ["The shader used to evaluate samples for the experimental generator rendering engine."], "extent": [158392, 158482]}], "container": true, "attrs": {"hprop": "vm_generatorshader", "ifdprop": "renderer:generatorshader"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Displacement bound"], "role": "item", "extent": [158482, 158504], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["The maximum bounds that the displacement shader will move geometry. This is defined in ", {"type": "q", "text": ["camera"]}, " space. \n    NOTE"], "extent": [158569, 158687], "body": [{"type": "para", "indent": 8, "text": ["The absolute value is used to determine the bounds."], "extent": [158687, 158748]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_displacebound", "ifdprop": "object:displacebound"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Displacement space"], "role": "item", "extent": [158748, 158770], "body": [{"type": "para", "indent": 4, "text": ["The space in which you specify displacement bounds."], "extent": [158839, 158900]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["\"object\""]}], "extent": [158900, 158916], "body": [{"type": "para", "indent": 8, "text": ["Displacements occur in object space."], "extent": [158916, 158970]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["\"camera\""]}], "extent": [158970, 158986], "body": [{"type": "para", "indent": 8, "text": ["Displacements occur in camera space."], "extent": [158986, 159040]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["\"world\""]}], "extent": [159040, 159055], "body": [{"type": "para", "indent": 8, "text": ["Default, currently an alias for camera."], "extent": [159055, 159104]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_displacespace", "ifdprop": "object:displacespace"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Velocity bound"], "role": "item", "extent": [159104, 159122], "body": [{"type": "para", "indent": 4, "text": ["The maximum bounds for volume velocity motion blur.  It is only necessary to configure this parameter when using velocity motion blur with custom volume procedurals, since mantra already computes an accurate bound for built-in volume types."], "extent": [159187, 159433]}], "container": true, "attrs": {"hprop": "vm_velocitybound", "ifdprop": "object:velocitybound"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Re-dice displacements"], "role": "item", "extent": [159433, 159458], "body": [{"type": "para", "indent": 4, "text": ["With extreme displacement, it\u2019s possible to get micro-polygons which are stretched far out of shape. Turning re-dicing on will cause the geometry to be re-measured after a trial displacement, to get a much better estimate of the actual size of the displaced geometry. This will result in micro-polygons which have a much more uniform size and will most likely provide higher quality images. This is more costly since the displacement shader may be run twice during the dicing process."], "extent": [159509, 159999]}, {"type": "para", "indent": 4, "text": ["This property has no effect for volume displacements."], "extent": [159999, 160058]}], "container": true, "attrs": {"hprop": "vm_redice", "ifdprop": "object:redice"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Matte shading"], "role": "item", "extent": [160058, 160075], "body": [{"type": "para", "indent": 4, "text": ["When enabled, the object\u2019s surface shader will be replaced with a matte\n    shader for primary rays. The default matte shader causes the object to\n    render as fully opaque but with an alpha of 0 - effectively cutting a\n    hole in the image where the object would have appeared. This setting is\n    useful when manually splitting an image into passes, so that the\n    background elements can be rendered separately from a foreground\n    object.  The default matte shader is the ", {"type": "q", "text": ["Matte"]}, " VEX shader, though it\n    is possible to set a different matte shader by adding the\n    ", {"type": "code", "text": ["vm_matteshader"]}, " render property and assigning another shader.\n    Secondary rays will still use the object\u2019s assigned surface shader,\n    allowing it to appear in reflections and indirect lighting even though\n    it will not render directly."], "extent": [160128, 160956]}, {"type": "para", "indent": 4, "text": ["For correct matte shading of volumes:"], "extent": [160956, 160998]}, {"type": "ord_group", "body": [{"blevel": 6, "type": "ord", "indent": 4, "text": ["Add the ", {"type": "code", "text": ["vm_matteshader"]}, " property to the object."], "extent": [160998, 161053]}, {"blevel": 6, "type": "ord", "indent": 4, "text": ["Create a ", {"type": "ui", "text": ["Volume Matte"]}, " shader."], "extent": [161053, 161093]}, {"blevel": 6, "type": "ord", "indent": 4, "text": ["Set the density on this shader to match the density on the geometry shader."], "extent": [161093, 161175]}, {"blevel": 6, "type": "ord", "indent": 4, "text": ["Assign this shader to ", {"type": "code", "text": ["vm_matteshader"]}, "."], "extent": [161175, 161222]}], "container": true}, {"type": "para", "indent": 4, "text": ["Then when the ", {"type": "ui", "text": ["Matte Shading"]}, " toggle is enabled, it will use your custom volume matte shader rather than the default (which just sets the density to 1). If you want fully opaque matte, you can use the matte shader rather than volume matte. "], "extent": [161222, 161470]}], "container": true, "attrs": {"hprop": "vm_matte", "ifdprop": "object:matte"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["True displace"], "role": "item", "extent": [161470, 161487], "body": [{"type": "para", "indent": 4, "text": ["When running displacement shaders, whether the VEX variable P is actually moved (true displacement) or whether bump mapping will be performed."], "extent": [161550, 161698]}], "container": true, "attrs": {"hprop": "vm_truedisplace", "ifdprop": "object:truedisplace"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Add Bump To Ray Traced Displacements"], "role": "item", "extent": [161698, 161738], "body": [{"type": "para", "indent": 4, "text": ["When true displacements is enabled, use the displacement as a bump map in addition to displacing the geometry.  Enabling this option can increase apparent detail without incurring the cost of an increase in shading quality.  Essentially, mantra is using true displacements up to the shading quality, and then adding the remaining detail by modifying the shading normal ", {"type": "code", "text": ["N"]}, "."], "extent": [161807, 162186]}], "container": true, "attrs": {"hprop": "vm_bumpraydisplace", "ifdprop": "object:bumpraydisplace"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Volume filter"], "role": "item", "extent": [162186, 162203], "body": [{"type": "para", "indent": 4, "text": ["Some volume primitives (Geometry Volumes, Image3D) can use a filter during evaluation of volume channels. This specifies the filter.  The default box filter is fast to evaluate and produces sharp renders for most smooth fluid simulations.  If your voxel data contains aliasing (stairstepping along edges), you may need to use a larger filter width or smoother filter to produce acceptable results.  For aliased volume data, ", {"type": "code", "text": ["gauss"]}, " is a good filter with a filter width of 1.5."], "extent": [162260, 162746]}, {"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["point"]}], "extent": [162746, 162760]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["box"]}], "extent": [162760, 162772]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["gauss"]}], "extent": [162772, 162786]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["bartlett"]}], "extent": [162786, 162803]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["blackman"]}], "extent": [162803, 162820]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["catrom"]}], "extent": [162820, 162835]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["hanning"]}], "extent": [162835, 162851]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["mitchell"]}], "extent": [162851, 162869]}], "container": true}], "container": true, "attrs": {"hprop": "vm_volumefilter", "ifdprop": "object:filter"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Volume filter width"], "role": "item", "extent": [162869, 162892], "body": [{"type": "para", "indent": 4, "text": ["This specifies the filter width for the object:filter property. The filter width is specified in number of voxels. Larger filter widths take longer to render and produce blurrier renders, but may be necessary to combat aliasing in some kinds of voxel data."], "extent": [162959, 163221]}], "container": true, "attrs": {"hprop": "vm_volumefilterwidth", "ifdprop": "object:filterwidth"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Raytrace shading"], "role": "item", "extent": [163221, 163241], "body": [{"type": "para", "indent": 4, "text": ["Shade every sample rather than shading micropolygon vertices. This setting enables the raytrace rendering on a per-object basis."], "extent": [163296, 163430]}, {"type": "para", "indent": 4, "text": ["When micro-polygon rendering, shading normally occurs at micro-polygon vertices at the beginning of the frame. To determine the color of a sample, the corner vertices are interpolated. Turning on ", {"type": "code", "text": ["object:rayshade"]}, " will cause the ray-tracing shading algorithm to be invoked. This will cause each sample to be shaded independently. This means that the shading cost may be significantly increased. However, each sample will be shaded at the correct time, and location."], "extent": [163430, 163901]}, {"type": "para", "indent": 4, "text": ["Currently not supported for per-primitive material assignment (material SOP)."], "extent": [163901, 163984]}], "container": true, "attrs": {"hprop": "vm_rayshade", "ifdprop": "object:rayshade"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Raytracing bias"], "role": "item", "extent": [163984, 164003], "body": [{"type": "para", "indent": 4, "text": ["Global raytracing bias to be used for PBR rendering, specified in world space units.  Increase the raytracing bias only if doing so eliminates rendering artifacts in your render.  For really small scenes (1 unit in size), it is sometimes necessary to decrease the raytracing bias."], "extent": [164058, 164344]}], "container": true, "attrs": {"hprop": "vm_raybias", "ifdprop": "renderer:raybias"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Ray derivative bias"], "role": "item", "extent": [164344, 164367], "body": [{"type": "para", "indent": 4, "text": ["Controls the distance between the shading position and the generated points used for ray tracing derivative calculations as a multiple of the pixel size.  Smaller values will produce sharper results at the expense of possible numerical stability problems.  If you are using bump mapping on geometry with inconsistent tangent vectors, decrease this value to eliminate artifacts in the render.  This value is not a scale on the derivative size, only an accuracy control."], "extent": [164432, 164906]}], "container": true, "attrs": {"hprop": "vm_rayderivbias", "ifdprop": "renderer:rayderivbias"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Randomize ray derivative basis"], "role": "item", "extent": [164906, 164940], "body": [{"type": "para", "indent": 4, "text": ["When enabled, ray tracing derivatives will use a randomly oriented s/t basis as opposed to the default geometric basis.  This property can be used to reduce shading artifacts that arise due to abrupt changes in parameter directions at surface boundaries, particularly when computing normals from high frequency patterns.  Ray tracing derivatives include all values computed using the ", {"type": "code", "text": ["Du()"]}, ", ", {"type": "code", "text": ["Dv()"]}, ", ", {"type": "code", "text": ["computenormal()"]}, ", and the ", {"type": "code", "text": ["dPds"]}, "/", {"type": "code", "text": ["dPdt"]}, " globals.  The s and t shading globals are unaffected by this property."], "extent": [165009, 165526]}], "container": true, "attrs": {"hprop": "vm_rayderivrandom", "ifdprop": "renderer:rayderivrandom"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Smooth grid colors"], "role": "item", "extent": [165526, 165548], "body": [{"type": "para", "indent": 4, "text": ["When micro-polygon rendering, shading normally occurs at micro-polygon vertices at the beginning of the frame. Enabling this checkbox causes the vertex colors to be Gouraud shaded to determine the color for a sample."], "extent": [165609, 165831]}, {"type": "para", "indent": 4, "text": ["Turn this checkbox off when you are trying to match a background plate to  eliminate any filtering which might occur on the plate. The Gouraud interpolation will cause softening of the map."], "extent": [165831, 166026]}], "container": true, "attrs": {"hprop": "vm_smoothcolor", "ifdprop": "object:smoothcolor"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Fix shadow terminator"], "role": "item", "extent": [166026, 166051], "body": [], "container": true, "attrs": {"hprop": "vm_smoothP", "ifdprop": "object:smoothP", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Categories"], "role": "item", "extent": [166120, 166134], "body": [{"type": "para", "indent": 4, "text": ["The space or comma separated list of categories to which this object belongs."], "extent": [166190, 166277]}, {"type": "para", "indent": 4, "text": ["Currently not supported for per-primitive material assignment (material SOP)."], "extent": [166277, 166360]}], "container": true, "attrs": {"hprop": "categories", "ifdprop": "object:categories"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Light mask"], "role": "item", "extent": [166360, 166374], "body": [{"type": "para", "indent": 4, "text": ["A list of patterns. Lights matching these patterns will illuminate this object. You can use wildcards (for example, ", {"type": "code", "text": ["key_*"]}, ") and\n    ", {"scheme": null, "value": "/basics/bundles", "type": "link", "text": ["bundle references"], "fullpath": "/basics/bundles"}, "  to specify lights."], "extent": [166432, 166630]}, {"type": "para", "indent": 4, "text": ["You can also use the  ", {"scheme": null, "value": "/ref/panes/linker", "type": "link", "text": ["link editor pane"], "fullpath": "/ref/panes/linker"}, "  to edit the relationships between lights and objects using a graphical\n    interface."], "extent": [166630, 166785]}, {"type": "para", "indent": 4, "text": ["The ", {"type": "code", "text": ["object:lightmask"]}, " property in Mantra is a computed property containing the results of combining light categories and light masks."], "extent": [166785, 166925]}], "container": true, "attrs": {"hprop": "lightmask", "ifdprop": "object:lightmask"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["LPE Tag"], "role": "item", "extent": [166925, 166935], "body": [{"type": "para", "indent": 4, "text": ["Custom label assigned to lights or objects for use with ", {"scheme": null, "value": "/render/lpe", "type": "link", "text": ["light path expression"], "fullpath": "/render/lpe"}, "."], "extent": [166986, 167084]}], "container": true, "attrs": {"hprop": "vm_lpetag", "ifdprop": "object:lpetag"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Light selection"], "role": "item", "extent": [167084, 167103], "body": [{"type": "para", "indent": 4, "text": ["A space-separated list of categories. Lights in these categories will illuminate this object."], "extent": [167173, 167272]}], "container": true, "attrs": {"hprop": "lightcategories", "ifdprop": "object:lightcategories"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Reflection mask"], "role": "item", "extent": [167272, 167291], "body": [{"type": "para", "indent": 4, "text": ["A list of patterns. Objects matching these patterns will reflect in this object. You can use wildcards (for example, ", {"type": "code", "text": ["key_*"]}, ") and\n    ", {"scheme": null, "value": "/basics/bundles", "type": "link", "text": ["bundle references"], "fullpath": "/basics/bundles"}, "  to specify objects."], "extent": [167349, 167549]}, {"type": "para", "indent": 4, "text": ["You can also use the  ", {"scheme": null, "value": "/ref/panes/linker", "type": "link", "text": ["link editor pane"], "fullpath": "/ref/panes/linker"}, "  to edit the relationships between lights and objects using a graphical\n    interface."], "extent": [167549, 167700]}, {"type": "para", "indent": 4, "text": ["The ", {"type": "code", "text": ["object:reflectmask"]}, " property in Mantra is a computed property containing the results of combining reflection categories and reflection masks."], "extent": [167700, 167852]}], "container": true, "attrs": {"hprop": "reflectmask", "ifdprop": "object:reflectmask"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Reflection selection"], "role": "item", "extent": [167852, 167876], "body": [{"type": "para", "indent": 4, "text": ["A space-separated list of categories. Objects in these categories will reflect in this object."], "extent": [167946, 168046]}], "container": true, "attrs": {"hprop": "reflectcategories", "ifdprop": "object:reflectcategories"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Refraction mask"], "role": "item", "extent": [168046, 168065], "body": [{"type": "para", "indent": 4, "text": ["A list of patterns. Objects matching these patterns will be visible in refraction rays. You can use wildcards (for example, ", {"type": "code", "text": ["key_*"]}, ") and ", {"scheme": null, "value": "/basics/bundles", "type": "link", "text": ["bundle references"], "fullpath": "/basics/bundles"}, "  to specify objects."], "extent": [168123, 168326]}, {"type": "para", "indent": 4, "text": ["You can also use the  ", {"scheme": null, "value": "/ref/panes/linker", "type": "link", "text": ["link editor pane"], "fullpath": "/ref/panes/linker"}, "  to edit the relationships between lights and objects using a graphical\n    interface."], "extent": [168326, 168477]}, {"type": "para", "indent": 4, "text": ["The ", {"type": "code", "text": ["object:refractmask"]}, " property in Mantra is a computed property containing the results of combining reflection categories and reflection masks."], "extent": [168477, 168629]}], "container": true, "attrs": {"hprop": "refractmask", "ifdprop": "object:refractmask"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Refraction selection"], "role": "item", "extent": [168629, 168653], "body": [{"type": "para", "indent": 4, "text": ["A space-separated list of categories. Objects in these categories will be visible in refraction rays."], "extent": [168723, 168830]}], "container": true, "attrs": {"hprop": "refractcategories", "ifdprop": "object:refractcategories"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Bias along normal"], "role": "item", "extent": [168830, 168851], "body": [{"type": "para", "indent": 4, "text": ["When biases are used in VEX shaders, the bias can either be performed along the ray direction or along the surface normal. If this parameter is turned on, biasing will be along the surface normal - using the ", {"type": "code", "text": ["Ng"]}, " VEX variable. "], "extent": [168910, 169147]}, {"type": "para", "indent": 4, "text": ["If the ray direction and normal point in different directions, the normal will first be flipped and then biasing will be performed in the direction of the flipped normal.  This setting is particularly useful when ray traced surfaces that are seen edge-on."], "extent": [169147, 169408]}], "container": true, "attrs": {"hprop": "vm_biasnormal", "ifdprop": "object:biasnormal"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Emission illuminates objects"], "role": "item", "extent": [169408, 169440], "body": [{"type": "para", "indent": 4, "text": ["Normally, emission (", {"type": "q", "text": ["Ce"]}, ") will contribute to secondary rays such as reflections.  This setting disables emission for secondary rays so that it only affects primary rays or directly visible light.  This setting is useful to avoid double-counting emission when it is already handled by another object or light."], "extent": [169497, 169811]}], "container": true, "attrs": {"hprop": "vm_emitillum", "ifdprop": "object:emitillum"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Share Displacements Between Instances"], "role": "item", "extent": [169811, 169852], "body": [{"type": "para", "indent": 4, "text": ["By default, when instancing is used with displacements, the displaced\n    geometry will be created uniquely for each instance, since it\u2019s\n    possible that the displacements may differ based on the world-space\n    position of each instance.  This default behavior will guarantee\n    correct results but it can be inefficient since mantra needs to keep a\n    separate copy of the displaced geometry for each instance. When this\n    setting is enabled, mantra will share a single copy of the displaced\n    geometry between all instances, and assumes that the displacement\n    shader only uses the object space position to determine the displaced\n    position and normal."], "extent": [169917, 170591]}, {"type": "para", "indent": 4, "text": ["The dicing quality used when displacements are shared will be the dicing quality for the instance that is closest to the camera. Therefore, instances that are farther from the camera may incur a greater rendering cost when this setting is enabled, but overall memory use will usually be lower."], "extent": [170591, 170890]}, {"type": "para", "indent": 4, "text": ["When sharing displacements on packed primitives, there\u2019s a very subtle issue which may cause issues with popping displacements.  The ", {"type": "code", "text": ["vm_procuseroottransform"]}, " toggle is on by default.  This means the object space for the packed geometry will not include the transform on the packed primitive itself, only the transform on the object containing the packed primitives.  This is important when doing geometry/volume lighting so that point clouds will all be in the space of the single object.  However, when there are shared displacements, the displacement should be computed in the space of the unpacked geometry (i.e. including the transform on the packed primitive).  If you want to use shared displacements on packed primitives, you should turn off the ", {"type": "code", "text": ["vm_procuseroottransform"]}, " parameter."], "extent": [170890, 171686]}], "container": true, "attrs": {"hprop": "vm_sharedisplace", "ifdprop": "object:sharedisplace"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Shadow"], "extent": [171686, 171699], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Shadow mask"], "role": "item", "extent": [171699, 171715], "body": [{"type": "para", "indent": 4, "text": ["The pattern of object names which are considered for ray-traced shadows."], "extent": [171770, 171848]}], "container": true, "attrs": {"hprop": "shadowmask", "ifdprop": "light:shadowmask"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Shadow selection"], "role": "item", "extent": [171848, 171868], "body": [{"type": "para", "indent": 4, "text": ["The pattern of object categories which are considered for ray-traced shadows."], "extent": [171935, 172018]}], "container": true, "attrs": {"hprop": "shadowcategories", "ifdprop": "light:shadowcategories"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Statistics"], "extent": [172018, 172035], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Render output"], "role": "item", "extent": [172035, 172053], "body": [], "container": true, "attrs": {"hprop": "soho_spoolrenderoutput", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["VEX profiling"], "role": "item", "extent": [172105, 172122], "body": [{"type": "para", "indent": 4, "text": ["VEX profiling lets you do analyze shader performance. Turning this on will slow down shading, especially when NAN detection is turned on."], "extent": [172183, 172326]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["No VEX Profiling (", {"type": "code", "text": ["0"]}, ")"], "extent": [172326, 172354], "body": [{"type": "para", "indent": 8, "text": ["No VEX Profiling is performed."], "extent": [172354, 172398]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Execution Profiling (", {"type": "code", "text": ["1"]}, ")"], "extent": [172398, 172429], "body": [{"type": "para", "indent": 8, "text": ["Mantra will print out information about shading computations at the conclusion of the render. This helps in identifying bottlenecks in the shading process."], "extent": [172429, 172602]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Profiling and NAN detection (", {"type": "code", "text": ["2"]}, ")"], "extent": [172602, 172641], "body": [{"type": "para", "indent": 8, "text": ["Prints out the shading information and will not print instructions that generate bad values (Not A Number). The output is cryptic, but can help track down errors in shaders."], "extent": [172641, 172824]}], "container": true}], "container": true}, {"type": "para", "indent": 4, "text": ["When NAN detection is turned on, each instruction executed in VEX will be checked for invalid arithmetic operations. This will check for division by ", {"type": "code", "text": ["0"]}, ", numeric overflow, invalid operations. Errors like this will typically result in white or black pixels in the resulting image."], "extent": [172824, 173109]}], "container": true, "attrs": {"hprop": "vm_vexprofile", "ifdprop": "renderer:vexprofile"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Verbose level"], "role": "item", "extent": [173109, 173126], "body": [{"type": "para", "indent": 4, "text": ["Increasing this value will cause more information to be printed out during rendering.  To see render time and memory information, set the verbosity level to 1.  To see more detailed information about the render, set this parameter to 3.  Larger values print out progressively more information."], "extent": [173181, 173480]}], "container": true, "attrs": {"hprop": "vm_verbose", "ifdprop": "renderer:verbose"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Alfred style progress"], "role": "item", "extent": [173480, 173505], "body": [{"type": "para", "indent": 4, "text": ["A percentage complete value is printed out as tiles are finished. This is in the style expected by Pixar\u2019s Alfred render queue."], "extent": [173568, 173701]}, {"type": "para", "indent": 4, "text": ["The following is an example of timing information and how to read it."], "extent": [173701, 173780]}, {"lang": null, "type": "pre", "indent": 4, "text": ["\n    Render Time: 4.52u 6.30s 4.24r Memory:  23.40 MB of 23.59 MB arena size.  VM Size: 345.11 MB\n    "], "extent": [173780, 173893]}, {"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["The ", {"type": "code", "text": ["u"]}, " value is the user time in seconds mantra took to render the image."], "extent": [173893, 173984], "body": [{"type": "note_group", "body": [{"type": "note", "indent": 8, "role": "item", "extent": [173984, 173998], "body": [{"type": "para", "indent": 12, "text": ["This value might not be 100% accurate depending on the OS and other system variables.  On Linux, this value will indicate the total time for ", {"type": "ui", "text": ["all threads"]}, " to render, so rendering with more than one processor may inflate the user time."], "extent": [173998, 174252]}], "container": true}], "container": true, "role": "item_group"}], "container": true}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["The ", {"type": "code", "text": ["s"]}, " value is the system overhead incurred in rendering the frame (disk io, swap, etc.).  A large system time may indicate a large amount of time spend reading or writing files."], "extent": [174252, 174444]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["The ", {"type": "code", "text": ["r"]}, " value is the wall clock time to render.  This is the most important value as it gives a clear indication for the total amount of time spent rendering."], "extent": [174444, 174614]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["Arena size is the amount of memory mantra allocated to actually render the image. It does not reflect how much memory mantra actually used."], "extent": [174614, 174765]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["VM size is the virtual memory size for the mantra program.  This is the amount of memory reported by the operating system and may significantly exceed the amount of memory that mantra is actually using."], "extent": [174765, 174975]}], "container": true}, {"type": "para", "indent": 4, "text": ["Mantra needs to grab continuous chunks of memory as it builds the data structures. Once it frees up the data, the operating system controls the arena size shrinking it where it finds continuous chunks of memory back to the free pool of available memory. This is called memory allocation and memory deallocation. You don\u2019t want the arena size much larger than the actual memory used."], "extent": [174975, 175363]}], "container": true, "attrs": {"hprop": "vm_alfprogress", "ifdprop": "renderer:alfprogress"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Python tile callback"], "role": "item", "extent": [175363, 175387], "body": [{"type": "para", "indent": 4, "text": ["This property specifies a python callback which can be called at the completion of each tile rendered. There is a ", {"type": "q", "text": ["built-in"]}, " ", {"type": "q", "text": ["mantra"]}, " module which allows information to be queried. There is a single function available in the mantra module. The ", {"type": "q", "text": ["property"]}, " function allows querying of any global rendering property as well as some other special properties. The result of the property call is always a list of values. "], "extent": [175456, 175881]}, {"type": "para", "indent": 4, "text": ["The special properties queried may be\u2026"], "extent": [175881, 175931]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["tile:ncomplete"]}], "extent": [175931, 175953], "body": [{"type": "para", "indent": 8, "text": ["The number of tiles which have been completed."], "extent": [175953, 176013]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["tile:ntiles"]}], "extent": [176013, 176032], "body": [{"type": "para", "indent": 8, "text": ["The total number of tiles in the image."], "extent": [176032, 176085]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["tile:laptime"]}], "extent": [176085, 176105], "body": [{"type": "para", "indent": 8, "text": ["The number of seconds taken to render the last tile."], "extent": [176105, 176171]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["tile:totaltime"]}], "extent": [176171, 176193], "body": [{"type": "para", "indent": 8, "text": ["The total number of seconds to render since the render began.  This does ", {"type": "strong", "text": ["not"]}, " include time to load the scene, but rather is defined as the time since the first tile began rendering."], "extent": [176193, 176389]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["tile:coords"]}], "extent": [176389, 176408], "body": [{"type": "para", "indent": 8, "text": ["The tile bounding box (in pixels)."], "extent": [176408, 176456]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["tile:memory"]}], "extent": [176456, 176475], "body": [{"type": "para", "indent": 8, "text": ["The amount of RAM in use by mantra."], "extent": [176475, 176520]}], "container": true}], "container": true}, {"lang": "python", "type": "pre", "indent": 4, "text": ["\n    import mantra\n    import sys\n\n    tile = mantra.property(\"tile:ncomplete\")(0)\n    if tile == 1\n        print mantra.property(\"renderer:name\")\n        print mantra.property(\"renderer:version\")\n    "], "extent": [176520, 176745]}], "container": true, "attrs": {"hprop": "vm_tilecallback", "ifdprop": "renderer:tilecallback"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Colorize output"], "role": "item", "extent": [176745, 176765], "body": [], "container": true, "attrs": {"hprop": "vm_logcolors", "ifdprop": "global:logcolors", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Log timestamp"], "role": "item", "extent": [176838, 176855], "body": [], "container": true, "attrs": {"hprop": "vm_logtimestamps", "ifdprop": "global:logtimestamps", "status": "nd"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Stereo"], "extent": [176936, 176949], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Render cameras"], "role": "item", "extent": [176949, 176968], "body": [{"type": "para", "indent": 4, "text": ["Specifies a list of cameras to be used for rendering. The native operator type for the stereo camera has this property and by default specifies two regular cameras for the left and right points of view."], "extent": [176995, 177203]}], "container": true, "attrs": {"hprop": "vm_cameralist"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Image file suffix"], "role": "item", "extent": [177203, 177224], "body": [{"type": "para", "indent": 4, "text": ["Is a string appended to the file name. This string is usually specified by the cameras included in the ", {"type": "code", "text": ["vm_cameralist"]}, " property of another camera, and is appended to the ", {"type": "code", "text": ["vm_picture"]}, " file name string of the render node before saving the rendered image to a file. It is used for disambiguating left and right images for a given frame. This suffix is added to the base filename and will come before the filename extension."], "extent": [177255, 177681]}], "container": true, "attrs": {"hprop": "vm_filenamesuffix"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Is left camera"], "role": "item", "extent": [177681, 177699], "body": [{"type": "para", "indent": 4, "text": ["Is non-zero if the camera represents the left view point in a stereoscopic setup."], "extent": [177729, 177820]}], "container": true, "attrs": {"hprop": "vm_s3dleftcamera"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Is right camera"], "role": "item", "extent": [177820, 177839], "body": [{"type": "para", "indent": 4, "text": ["Is non-zero if the camera represents the right view point in a stereoscopic setup."], "extent": [177870, 177958]}], "container": true, "attrs": {"hprop": "vm_s3drightcamera"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Sub camera tag"], "role": "item", "extent": [177958, 177976], "body": [], "container": true, "attrs": {"hprop": "subcamtag", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Include in viewport menu"], "role": "item", "extent": [178015, 178043], "body": [], "container": true, "attrs": {"hprop": "viewmenu", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["View xform node"], "role": "item", "extent": [178081, 178100], "body": [], "container": true, "attrs": {"hprop": "viewxformpath", "status": "nd"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Unwrapping"], "extent": [178143, 178160], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Unwrap Method"], "role": "item", "extent": [178160, 178178], "body": [{"type": "para", "indent": 4, "text": ["Selects the method used to unwrap from the 'UV Object'."], "extent": [178211, 178276]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["UV To Surface"], "extent": [178276, 178295], "body": [{"type": "para", "indent": 8, "text": ["Maps the UVs to their locations on the surface of the object."], "extent": [178295, 178370]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Trace Closest Surface"], "extent": [178370, 178397], "body": [{"type": "para", "indent": 8, "text": ["Uses raytracing to find the surface closest to the ", {"type": "ui", "text": ["UV Object"]}, "."], "extent": [178397, 178472]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_uv_unwrap_method"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Texture Format"], "role": "item", "extent": [178472, 178490], "body": [{"type": "para", "indent": 4, "text": ["The texture baking output format:"], "extent": [178543, 178586]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["UDIM"], "extent": [178586, 178596], "body": [{"type": "para", "indent": 8, "text": ["Bake texture into one or more UDIM texture images."], "extent": [178596, 178660]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Ptex"], "extent": [178660, 178670], "body": [{"type": "para", "indent": 8, "text": ["Bake texture into a single Ptex image."], "extent": [178670, 178718]}], "container": true}], "container": true}], "container": true, "attrs": {"hprop": "vm_uvtype", "ifdprop": "renderer:uvtype"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["UV Attribute"], "role": "item", "extent": [178718, 178734], "body": [{"type": "para", "indent": 4, "text": ["When texture baking to UDIM images, this is the name of the texture\n    coordinate attribute used for unwrapping."], "extent": [178797, 178916]}], "container": true, "attrs": {"hprop": "vm_uvattribute", "ifdprop": "renderer:uvattribute"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["UV Unwrap Resolution"], "role": "item", "extent": [178916, 178940], "body": [{"type": "para", "indent": 4, "text": ["When texture baking to UDIM images, this specifies the resolution of the\n    UDIM images."], "extent": [178999, 179094]}], "container": true, "attrs": {"hprop": "vm_uvunwrapres", "ifdprop": "image:resolution"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["UV Shading Quality"], "role": "item", "extent": [179094, 179116], "body": [{"type": "para", "indent": 4, "text": ["Controls the sharpness of baked textures. Higher values produce sharper results."], "extent": [179189, 179275]}], "container": true, "attrs": {"hprop": "vm_uvshadingquality", "ifdprop": "renderer:uvshadingquality"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Create Intermediate Directories"], "role": "item", "extent": [179275, 179310], "body": [{"type": "para", "indent": 4, "text": ["When performing texture baking, this parameter will create any intermediate directories before creating the baked texture images."], "extent": [179367, 179502]}], "container": true, "attrs": {"hprop": "vm_uvmkpath", "ifdprop": "renderer:uvmkpath"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Hide UV cage objects"], "role": "item", "extent": [179502, 179526], "body": [{"type": "para", "indent": 4, "text": ["When UV baking from a high-res object to a low-res cage, normally you want to turn off rendering of the low-res cage.  Turning off this option will disable that feature."], "extent": [179553, 179728]}], "container": true, "attrs": {"hprop": "vm_uvhidecage"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Exclude Light Paths"], "role": "item", "extent": [179728, 179751], "body": [{"type": "para", "indent": 4, "text": ["This parameter controls the light components excluded during bake renders. When baking it is common to render only view-independent components such as ", {"type": "q", "text": ["diffuse"]}, ". The default value of ", {"type": "code", "text": ["-diffuse & -volume"]}, " will only render diffuse and volume light paths."], "extent": [179780, 180038]}], "container": true, "attrs": {"hprop": "vm_uvlightpaths"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Minimum Ptex Map Resolution"], "role": "item", "extent": [180038, 180069], "body": [{"type": "para", "indent": 4, "text": ["When baking to a Ptex image, this specifies the tile resolution for the\n    smallest faces in the model."], "extent": [180136, 180246]}], "container": true, "attrs": {"hprop": "vm_ptexmapminres", "ifdprop": "renderer:ptexmapminres"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Maximum Ptex Map Resolution"], "role": "item", "extent": [180246, 180277], "body": [{"type": "para", "indent": 4, "text": ["When baking to a Ptex image, this specifies the largest resolution for any\n    individual face in the model."], "extent": [180344, 180458]}], "container": true, "attrs": {"hprop": "vm_ptexmapmaxres", "ifdprop": "renderer:ptexmapmaxres"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Ptex Resolution Scale"], "role": "item", "extent": [180458, 180483], "body": [{"type": "para", "indent": 4, "text": ["When baking to a Ptex image, mantra will measure the world-space size of all the faces in the image.  Each face\u2019s tile resolution will be determined by the relative size of the face compared with the smallest faces in the model (unless ", {"type": "ui", "text": ["Ptex Use Relative Scale"]}, " is disabled).  The tile resolution of a given face is given by ", {"type": "code", "text": ["clamp(curr_size/min_size * ptexmapminres * ptexmapscale, ptexmapminres, ptexmapmaxres)"]}, "."], "extent": [180548, 180970]}], "container": true, "attrs": {"hprop": "vm_ptexmapscale", "ifdprop": "renderer:ptexmapscale"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Ptex Scale Prim Attribute"], "role": "item", "extent": [180970, 180999], "body": [{"type": "para", "indent": 4, "text": ["When baking to a Ptex image, mantra will look for primitive-level scalar attribute of this name to scale tile resolution of current face. Note that the scaled resolution is still clamped by Minimum and Maximum resolutions."], "extent": [181066, 181294]}], "container": true, "attrs": {"hprop": "vm_ptexscaleattr", "ifdprop": "renderer:ptexscaleattr"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Ptex Use Relative Scale"], "role": "item", "extent": [181294, 181321], "body": [{"type": "para", "indent": 4, "text": ["If this is disabled, mantra will no longer measure relative size of faces compared with smallest faces in the model when baking to a Ptex image. The tile resolution of each face will simply be ", {"type": "ui", "text": ["Minimum Ptex Map Resolution"]}, " multiplied by ", {"type": "ui", "text": ["Ptex Resolution Scale"]}, " and primitive-level Ptex scale attribute (if one exists)."], "extent": [181396, 181724]}], "container": true, "attrs": {"hprop": "vm_ptexrelativescale", "ifdprop": "renderer:ptexrelativescale"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Orient Ptex Subfaces Clockwise"], "role": "item", "extent": [181724, 181758], "body": [{"type": "para", "indent": 4, "text": ["When baking to a Ptex image, this option determines the orientation of face ids for subfaces when splitting non-quad faces.  The default is to order the sub-faces counterclockwise.  However, some software expects to have the faces ordered clockwise."], "extent": [181827, 182082]}], "container": true, "attrs": {"hprop": "vm_ptexwraporient", "ifdprop": "renderer:ptexwraporient"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["UDIM Post Process"], "role": "item", "extent": [182082, 182103], "body": [{"type": "para", "indent": 4, "text": ["When baking to a UDIM image, this option determines what type of post-processing is applied to the final image.  The choices are  ", {"type": "ui", "text": ["No Post Processing"]}, ", ", {"type": "ui", "text": ["Border Expansion"]}, ", ", {"type": "ui", "text": ["Fill Background With Average Color"]}, ", and ", {"type": "ui", "text": ["Diffuse Fill"]}, "."], "extent": [182170, 182417]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [182417, 182427], "body": [{"type": "para", "indent": 12, "text": ["Currently, this is only supported when rendering to disk (not to flipbooks)"], "extent": [182427, 182516]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"hprop": "vm_uvpostprocess", "ifdprop": "renderer:uvpostprocess"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["UV Additional Pixels at Border"], "role": "item", "extent": [182516, 182550], "body": [{"type": "para", "indent": 4, "text": ["When baking to a UDIM image and performing island border expansion, this\n    parameter indicates by how many pixels each island should be enlarged."], "extent": [182619, 182772]}], "container": true, "attrs": {"hprop": "vm_uvborderpixels", "ifdprop": "renderer:uvborderpixels"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Reverse Normals"], "role": "item", "extent": [182772, 182791], "body": [{"type": "para", "indent": 4, "text": ["When texture baking, this will reverse normals on the geometry.  This\n    determines the orientation of the surface for the baking lens shader (i.e.\n    shade the inside or outside of the surface)."], "extent": [182822, 183025]}], "container": true, "attrs": {"hprop": "vm_uv_flip_normal"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Ray Bias"], "role": "item", "extent": [183025, 183037], "body": [{"type": "para", "indent": 4, "text": ["Determines how much to offset the position of the ray from the surface of the object along the normal vector. This value should be increased proportional to the displacement in a displacement shader (if there is one) in order to ensure that the ray hits the surface. The\n    bias is used solely for camera rays."], "extent": [183065, 183382]}], "container": true, "attrs": {"hprop": "vm_uv_ray_bias"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Ray Max Distance"], "role": "item", "extent": [183382, 183402], "body": [{"type": "para", "indent": 4, "text": ["If ", {"type": "code", "text": ["vm_uv_unwrap_method"]}, " is set to ", {"type": "code", "text": ["Trace Closest Surface"]}, " this parameter controls the maximum distance to trace for nearby surfaces. Useful for limiting the areas of the scene that will be baked onto the low-res object."], "extent": [183433, 183659]}], "container": true, "attrs": {"hprop": "vm_uv_ray_maxdist"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["User"], "extent": [183659, 183670], "body": []}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["View"], "extent": [183670, 183682], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Resolution"], "role": "item", "extent": [183682, 183697], "body": [{"type": "para", "indent": 4, "text": ["The output resolution in pixels. Standard presets are available via the pull down menu to the right of the parameter."], "extent": [183718, 183841]}], "container": true, "attrs": {"hprop": "res"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Choose resolution"], "role": "item", "extent": [183841, 183862], "body": [], "container": true, "attrs": {"hprop": "resMenu", "status": "nd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Pixel aspect ratio"], "role": "item", "extent": [183899, 183921], "body": [{"type": "para", "indent": 4, "text": ["The pixel aspect ratio of the output image."], "extent": [183977, 184026]}], "container": true, "attrs": {"hprop": "aspect", "ifdprop": "image:pixelaspect"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Projection"], "role": "item", "extent": [184026, 184040], "body": [{"type": "para", "indent": 4, "text": ["Type of camera projection used for rendering (for example, perspective or orthographic)."], "extent": [184068, 184162]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Perspective"], "extent": [184162, 184179], "body": [{"type": "para", "indent": 8, "text": ["This simulates the classic pinhole camera where camera rays emanate\n        from a common camera origin through a flat camera plane."], "extent": [184179, 184321]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Orthographic"], "extent": [184321, 184339], "body": [{"type": "para", "indent": 8, "text": ["This uses parallel camera rays that are orthogonal to the (flat)\n        camera plane. The width of the view volume is determined by the\n        Ortho Width parameter below."], "extent": [184339, 184522]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Polar (panoramic)"], "extent": [184522, 184545], "body": [{"type": "para", "indent": 8, "text": ["This projection uses a spherical camera plane for rendering."], "extent": [184545, 184615]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Cylindrical (panoramic)"], "extent": [184615, 184644], "body": [{"type": "para", "indent": 8, "text": ["This projection uses a cylindrical camera plane for rendering."], "extent": [184644, 184716]}], "container": true}], "container": true}, {"type": "para", "indent": 4, "text": ["Lens Shader:\n    Use a lens shader to initialize rays for ray tracing."], "extent": [184716, 184800]}, {"type": "para", "indent": 4, "text": ["Selecting ", {"type": "ui", "text": ["Polar"]}, ", ", {"type": "ui", "text": ["Cylindrical"]}, " or ", {"type": "ui", "text": ["Lens Shader"]}, " will automatically switch the ", {"type": "ui", "text": ["Rendering Engine"]}, " (on the output driver) to ", {"type": "ui", "text": ["Ray Tracing"]}, ", as it is impossible to render these projections with micropolygon rendering."], "extent": [184800, 185032]}], "container": true, "attrs": {"hprop": "projection"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Otho width"], "role": "item", "extent": [185032, 185046], "body": [{"type": "para", "indent": 4, "text": ["Width of orthographic view volume when using Projection is set to\n    Orthographic."], "extent": [185102, 185191]}], "container": true, "attrs": {"hprop": "orthowidth", "ifdprop": "camera:orthowidth"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Focal length"], "role": "item", "extent": [185191, 185207], "body": [{"type": "para", "indent": 4, "text": ["Camera focal length (zoom)."], "extent": [185230, 185263]}], "container": true, "attrs": {"hprop": "focal"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Focal units"], "role": "item", "extent": [185263, 185278], "body": [{"type": "para", "indent": 4, "text": ["The units used for the focal length."], "extent": [185306, 185348]}], "container": true, "attrs": {"hprop": "focalunits"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Aperture"], "role": "item", "extent": [185348, 185360], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 4, "text": [{"scheme": "Image", "value": "/images/nodes/fov.png", "type": "img", "text": ""}], "role": "item", "extent": [185386, 185434], "body": [{"type": "para", "indent": 8, "text": ["Width of the visible field."], "extent": [185434, 185479]}, {"type": "para", "indent": 8, "text": ["You can obtain a good fit between the Houdini camera and a real world camera by matching a measured lens\u2019s horizontal angle of view, and deriving a Houdini focal length value that reproduces it with the default aperture 41.4214."], "extent": [185479, 185717]}, {"type": "note_group", "body": [{"type": "note", "indent": 8, "role": "item", "extent": [185717, 185731], "body": [{"type": "para", "indent": 12, "text": ["The default aperture combined with the default focal length of 50mm produces a 45 degree field of view."], "extent": [185731, 185848]}], "container": true}], "container": true, "role": "item_group"}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"hprop": "aperture"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Near clipping"], "role": "item", "extent": [185848, 185865], "body": [{"type": "para", "indent": 4, "text": ["Position of near clipping plane."], "extent": [185887, 185929]}], "container": true, "attrs": {"hprop": "near"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Far clipping"], "role": "item", "extent": [185929, 185945], "body": [{"type": "para", "indent": 4, "text": ["Position of far clipping plane."], "extent": [185966, 186003]}], "container": true, "attrs": {"hprop": "far"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Screen window X/Y"], "role": "item", "extent": [186003, 186024], "body": [{"type": "para", "indent": 4, "text": ["Define the center of the window during the rendering process."], "extent": [186045, 186112]}], "container": true, "attrs": {"hprop": "win"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Screen window size"], "role": "item", "extent": [186112, 186134], "body": [{"type": "para", "indent": 4, "text": ["Scale for expanding the cropped area specified by the ", {"type": "ui", "text": ["Crop"]}, " parameters."], "extent": [186159, 186239]}], "container": true, "attrs": {"hprop": "winsize"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Screen window mask"], "role": "item", "extent": [186239, 186261], "body": [{"type": "para", "indent": 4, "text": ["Sets the screen window mask to cover the bounding box of the selected object(s)."], "extent": [186282, 186368]}], "container": true, "attrs": {"hprop": "winmask"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Left crop"], "role": "item", "extent": [186368, 186381], "body": [{"type": "para", "indent": 4, "text": ["Left cropping margin for camera\u2019s view area."], "extent": [186404, 186454]}], "container": true, "attrs": {"hprop": "cropl"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Right crop"], "role": "item", "extent": [186454, 186468], "body": [{"type": "para", "indent": 4, "text": ["Right cropping margin for camera\u2019s view area."], "extent": [186491, 186542]}], "container": true, "attrs": {"hprop": "cropr"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Bottom crop"], "role": "item", "extent": [186542, 186557], "body": [{"type": "para", "indent": 4, "text": ["Bottom cropping margin for camera\u2019s view area."], "extent": [186580, 186632]}], "container": true, "attrs": {"hprop": "cropb"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Top crop"], "role": "item", "extent": [186632, 186644], "body": [{"type": "para", "indent": 4, "text": ["Top cropping margin for camera\u2019s view area."], "extent": [186667, 186716]}], "container": true, "attrs": {"hprop": "cropt"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Crop Mask"], "role": "item", "extent": [186716, 186729], "body": [{"type": "para", "indent": 4, "text": ["Sets the pixel crop region to cover the bounding box of the selected object(s)."], "extent": [186755, 186840]}], "container": true, "attrs": {"hprop": "cropmask"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Image Overscan"], "role": "item", "extent": [186840, 186858], "body": [{"type": "para", "indent": 4, "text": ["Enlarges the crop region by this many pixels (horizontal and vertical amounts).  If the crop region is the full image, additional pixels outside the image will be rendered."], "extent": [186883, 187061]}, {"type": "para", "indent": 4, "text": ["For images that support arbitrary data windows (OpenEXR, Houdini) pixels outside the image resolution will be saved.  For other image formats, the pixels will be computed but the results discarded."], "extent": [187061, 187264]}], "container": true, "attrs": {"hprop": "vm_overscan"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Icon scale"], "role": "item", "extent": [187264, 187278], "body": [{"type": "para", "indent": 4, "text": ["Scales the viewport geometry. This parameter is only for display\n    purposes."], "extent": [187305, 187389]}], "container": true, "attrs": {"hprop": "iconscale"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Lens curvature"], "role": "item", "extent": [187389, 187407], "body": [{"type": "para", "indent": 4, "text": ["Mantra is able to render using a non-flat projection plane. When the curvature is non-zero, ray-tracing will be used for primary rays. The curvature may either be greater or less than zero to mimic a wide angle or fish-eye lens."], "extent": [187464, 187698]}, {"type": "para", "indent": 4, "text": ["The ", {"type": "code", "text": ["vm_curvature"]}, " has the following effect on an existing perspective direction vector D:"], "extent": [187698, 187794]}, {"lang": null, "type": "pre", "indent": 4, "text": ["\n    tx = [-0.5:0.5] x screen offset\n    ty = [-0.5:0.5] y screen offset\n\n    cmult = camera:curvature / camera:zoom\n    D.z = 1 + (1 - 2*(tx*tx + ty*ty)) * cmult\n    "], "extent": [187794, 187972]}], "container": true, "attrs": {"hprop": "vm_curvature", "ifdprop": "camera:curvature"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Remove Camera Scale"], "role": "item", "extent": [187972, 187996], "body": [{"type": "para", "indent": 4, "text": ["Remove camera scaling when calculating the view transform. This is on by default."], "extent": [188034, 188121]}], "container": true, "attrs": {"hprop": "vm_removecamerascale"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Enable background image"], "role": "item", "extent": [188121, 188148], "body": [{"type": "para", "indent": 4, "text": ["Enables background image rendering."], "extent": [188206, 188247]}], "container": true, "attrs": {"hprop": "vm_bgenable", "ifdprop": "image:bgenable"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Background Image"], "role": "item", "extent": [188247, 188267], "body": [{"type": "para", "indent": 4, "text": ["Specifies a ", {"scheme": null, "value": "/render/dcm", "type": "link", "text": ["deep camera"], "fullpath": "/render/dcm"}, "/", {"scheme": null, "value": "/render/lights#enabling-and-disabling-shadows", "type": "link", "text": ["shadow"], "fullpath": "/render/lights#enabling-and-disabling-shadows", "fragment": "#enabling-and-disabling-shadows"}, " image to use to fill in the background color for primary rays (and only primary rays)."], "extent": [188329, 188518]}, {"type": "para", "indent": 4, "text": ["Because the deep camera/shadow image stores the color/opacity values for all depths, the deep image can be mixed with other objects in the scene with perfect occlusion/transparency."], "extent": [188518, 188709]}, {"type": "para", "indent": 4, "text": ["Add this property to a camera (not the output driver). If you add it to the output driver, the background image will be picked up for shadow map generation, which is probably not what you want."], "extent": [188709, 188908]}, {"type": "para", "indent": 4, "text": ["If you add this property to a light, the image will be merged with shadow maps generated shadow maps from the light."], "extent": [188908, 189030]}, {"type": "para", "indent": 4, "text": ["Mantra uses ", {"scheme": null, "value": "/io/ocio", "type": "link", "text": ["OCIO"], "fullpath": "/io/ocio"}, " to color correct images on disk. It may be able to ", {"scheme": null, "value": "/io/ocio#guess", "type": "link", "text": ["guess the image\u2019s color space"], "fullpath": "/io/ocio#guess", "fragment": "#guess"}, " based on the image filename (for example, ", {"type": "code", "text": ["myimage-srgb.exr"]}, ") or format."], "extent": [189030, 189234]}], "container": true, "attrs": {"hprop": "vm_background", "ifdprop": "image:background"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Background Image as Matte"], "role": "item", "extent": [189234, 189263], "body": [{"type": "para", "indent": 4, "text": ["Render the ", {"scheme": null, "value": "#vm_background", "type": "link", "text": ["background deep camera map"], "fullpath": "/props/mantra#vm_background", "fragment": "#vm_background"}, " as a matte object. When this property is on, mantra throws away the color of the deep camera map, and the alpha from the deep camera map is not put into the final image. This is the default behavior for deep shadow map files."], "extent": [189359, 189645]}, {"type": "para", "indent": 4, "text": ["Only meaningful for deep camera images.  Deep shadow images have this behavior by default."], "extent": [189645, 189741]}], "container": true, "attrs": {"hprop": "vm_backgroundmatte", "ifdprop": "image:backgroundmatte", "default": "('false')"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Background Image Channels"], "role": "item", "extent": [189741, 189770], "body": [{"type": "para", "indent": 4, "text": ["A space/comma-separated list of patterns matching the channels to use from the ", {"scheme": null, "value": "#vm_background", "type": "link", "text": ["background image"], "fullpath": "/props/mantra#vm_background", "fragment": "#vm_background"}, ". This For example, ", {"type": "code", "text": ["*,^C"]}, " uses all channels except the ", {"type": "code", "text": ["C"]}, " channel. This lets you for example use only the alpha channel from a deep camera map, and prevent the color from the DCM from affecting the rendered image."], "extent": [189868, 190205]}, {"type": "para", "indent": 4, "text": ["This is applicable to both deep camera map backgrounds and flat image backgrounds."], "extent": [190205, 190293]}], "container": true, "attrs": {"hprop": "vm_backgroundchannels", "ifdprop": "image:backgroundchannels", "default": "(\"*\")"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Scale background to fill image"], "role": "item", "extent": [190293, 190327], "body": [{"type": "para", "indent": 4, "text": ["When enabled, if the background image does not match the render resolution the background will be scaled to fill the render resolution."], "extent": [190383, 190524]}], "container": true, "attrs": {"hprop": "vm_bgscale", "ifdprop": "image:bgscale"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Background Z-Scale"], "role": "item", "extent": [190524, 190546], "body": [{"type": "para", "indent": 4, "text": ["This setting allows you to apply a scale to the z-values in the background image, which may simplify merging deep images that have a different scale."], "extent": [190600, 190755]}], "container": true, "attrs": {"hprop": "vm_bgzscale", "ifdprop": "image:bgzscale"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Lens Shader"], "role": "item", "extent": [190755, 190770], "body": [{"type": "para", "indent": 4, "text": ["Specifies the CVEX lens shader to use for the ", {"type": "code", "text": ["Lens Shader"]}, " projection\n    type.  A lens shader is responsible for computing primary rays from\n    screen coordinates, and is a flexible way to define new kinds of camera\n    projections that can\u2019t be modeled as perspective or orthographic\n    projections.  Lens shaders can have the following parameters and\n    exports:"], "extent": [190835, 191214]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["float x"]}], "extent": [191214, 191229], "body": [{"type": "para", "indent": 8, "text": ["X screen coordinate in the range -1 to 1."], "extent": [191229, 191288]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["float y"]}], "extent": [191288, 191303], "body": [{"type": "para", "indent": 8, "text": ["Y screen coordinate in the range -1 to 1."], "extent": [191303, 191362]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["float Time"]}], "extent": [191362, 191380], "body": [{"type": "para", "indent": 8, "text": ["Sample time."], "extent": [191380, 191410]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["float dofx"]}], "extent": [191410, 191428], "body": [{"type": "para", "indent": 8, "text": ["X depth of field sample value."], "extent": [191428, 191476]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["float dofy"]}], "extent": [191476, 191494], "body": [{"type": "para", "indent": 8, "text": ["Y depth of field sample value."], "extent": [191494, 191542]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["float aspect"]}], "extent": [191542, 191562], "body": [{"type": "para", "indent": 8, "text": ["Image aspect ratio (x/y)."], "extent": [191562, 191597]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["int xres"]}], "extent": [191597, 191613], "body": [{"type": "para", "indent": 8, "text": ["Image horizontal resolution."], "extent": [191613, 191651]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["int yres"]}], "extent": [191651, 191667], "body": [{"type": "para", "indent": 8, "text": ["Image vertical resolution."], "extent": [191667, 191711]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["export vector P"]}], "extent": [191711, 191734], "body": [{"type": "para", "indent": 8, "text": ["Ray origin in camera space."], "extent": [191734, 191779]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["export vector I"]}], "extent": [191779, 191802], "body": [{"type": "para", "indent": 8, "text": ["Ray direction in camera space."], "extent": [191802, 191850]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["export int valid"]}], "extent": [191850, 191874], "body": [{"type": "para", "indent": 8, "text": ["Whether the sample is valid for measuring."], "extent": [191874, 191926]}], "container": true}], "container": true}, {"type": "para", "indent": 4, "text": ["The lens shader should be able to handle x and y values outside the -1\n    to 1 range, in case samples outside the image need to be generated. The\n    P and I exports should be created in camera space, ignoring the camera\n    transform."], "extent": [191926, 192168]}, {"type": "para", "indent": 4, "text": ["Before rendering begins, mantra measures the lens shader before\n    rendering.  During the measuring process, the ", {"type": "code", "text": ["valid"]}, " variable can be used\n    to flag invalid rays.  In the future, the ", {"type": "code", "text": ["valid"]}, " flag may be used during\n    rendering."], "extent": [192168, 192413]}, {"type": "para", "indent": 4, "text": ["Mantra\u2019s camera space is defined with positive\n    z-values in front of the camera, so for a default camera the z-axis\n    is flipped relative to Houdini\u2019s world space."], "extent": [192413, 192587]}, {"type": "para", "indent": 4, "text": ["An example lens shader is the ", {"scheme": null, "value": "/nodes/shop/v_asadlens", "type": "link", "text": ["Ray Lens"], "fullpath": "/nodes/shop/v_asadlens"}, " shader."], "extent": [192587, 192668]}], "container": true, "attrs": {"hprop": "vm_lensshader", "ifdprop": "renderer:lensshader"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Pixel Crop"], "role": "item", "extent": [192668, 192682], "body": [{"type": "para", "indent": 4, "text": ["Specify the cropping region in pixel coordinates.  This is typically automatically done in IFD generation."], "extent": [192713, 192825]}], "container": true, "attrs": {"ifdprop": "image:pixelcrop"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Other Houdini properties"], "extent": [192825, 192856], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Fog Background Shader"], "role": "item", "extent": [192856, 192882], "body": [{"type": "para", "indent": 4, "text": ["The shader assigned to the automatically added background fog object (see ", {"scheme": "Mantra", "value": "/props/mantra#vm_fogbackground", "type": "link", "text": "", "fallback_text": "vm_fogbackground", "fullpath": "/props/mantra#vm_fogbackground", "fragment": "#vm_fogbackground"}, "). You must add this as a spare parameter if you want to change it, it doesn\u2019t exist in the render properties interface."], "extent": [192961, 193186]}], "container": true, "attrs": {"hprop": "vm_fogbackgroundshader", "ifdprop": "renderer:fogbackgroundshader"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Network Queue Size"], "role": "item", "extent": [193186, 193208], "body": [{"type": "para", "indent": 4, "text": ["The number of tiles queued for network rendering. You must add this as a spare parameter if you want to change it, it doesn\u2019t exist in the render properties interface."], "extent": [193273, 193446]}], "container": true, "attrs": {"hprop": "vm_networkqsize", "ifdprop": "renderer:networkqsize"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Override Property Map"], "role": "item", "extent": [193446, 193471], "body": [{"type": "para", "indent": 4, "text": ["Typically handled automatically during IFD generation."], "extent": [193546, 193610]}, {"type": "para", "indent": 4, "text": ["In the material overrides, the names specified for the overrides may not\n    match the internal mantra property names (i.e. ", {"type": "code", "text": ["vm_rendersubd"]}, " as opposed\n    to ", {"type": "code", "text": ["rendersubd"]}, ").  The property map provides a name map (represented as a\n    Python dictionary) mapping the parameter name specified in the override to\n    the actual Mantra property name."], "extent": [193610, 193964]}, {"type": "para", "indent": 4, "text": ["You must add this as a spare parameter if you want to change it, it doesn\u2019t exist in the render properties interface."], "extent": [193964, 194087]}], "container": true, "attrs": {"hprop": "vm_overridepropmap", "ifdprop": "geometry:overridepropmap"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Sample all lights"], "role": "item", "extent": [194087, 194108], "body": [{"type": "para", "indent": 4, "text": ["Enables independent sampling for different light sources when rendering with PBR.  When disabled, mantra will attempt to reduce the expense of lighting computation by randomly selecting a light source to compute illumination rather than performing lighting from all lights.  Normally leaving multi-light sampling enabled will produce a better performance/quality tradeoff, in combination with active radius control in scenes with many lights."], "extent": [194138, 194586]}, {"type": "para", "indent": 4, "text": ["This is passed as an argument to the ", {"scheme": "Mantra", "value": "/props/mantra#vm_pbrshader", "type": "link", "text": "", "fallback_text": "vm_pbrshader", "fullpath": "/props/mantra#vm_pbrshader", "fragment": "#vm_pbrshader"}, "."], "extent": [194586, 194655]}, {"type": "para", "indent": 4, "text": ["You must add this as a spare parameter if you want to change it, it doesn\u2019t exist in the render properties interface."], "extent": [194655, 194778]}], "container": true, "attrs": {"hprop": "vm_pbrmultilight"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["IFD-only properties"], "extent": [194778, 194804], "body": [{"type": "para", "indent": 0, "text": ["These properties exist in IFD scene description files, but do not have equivalents in the Houdini property UI."], "extent": [194804, 194917]}, {"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Geometry velocity scale"], "role": "item", "extent": [194917, 194944], "body": [{"type": "para", "indent": 4, "text": ["This is typically handled automatically using the camera shutter information."], "extent": [194980, 195063]}], "container": true, "attrs": {"ifdprop": "object:velocityscale"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Progress Action"], "role": "item", "extent": [195063, 195082], "body": [{"type": "para", "indent": 4, "text": ["Specify the rendering task.  This setting is passed to the IPR viewer and is typically done automatically during IFD generation."], "extent": [195121, 195255]}], "container": true, "attrs": {"ifdprop": "renderer:progressaction"}}], "container": true, "role": "item_group"}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Image and plane properties"], "extent": [195255, 195290], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["plane:planefile"]}], "role": "item", "extent": [195290, 195312], "body": [{"type": "para", "indent": 4, "text": ["The name of the image file to write the plane to (if undefined, inherited from ", {"type": "code", "text": ["image:filename"]}, ")."], "extent": [195347, 195454]}], "container": true, "attrs": {"ifdprop": "plane:planefile"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["plane:planedevice"]}], "role": "item", "extent": [195454, 195477], "body": [{"type": "para", "indent": 4, "text": ["The image device to write the plane (if undefined, inherited from ", {"type": "code", "text": ["image:device"]}, ")."], "extent": [195514, 195606]}], "container": true, "attrs": {"ifdprop": "plane:planedevice"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["plane:planechannel"]}], "role": "item", "extent": [195606, 195630], "body": [{"type": "para", "indent": 4, "text": ["The channel name for the image plane in the output file."], "extent": [195663, 195729]}], "container": true, "attrs": {"ifdprop": "plane:channel"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["plane:planevariable"]}], "role": "item", "extent": [195729, 195754], "body": [{"type": "para", "indent": 4, "text": ["The VEX variable to use as the image plane data."], "extent": [195788, 195846]}], "container": true, "attrs": {"ifdprop": "plane:variable"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["plane:vextype"]}], "role": "item", "extent": [195846, 195865], "body": [{"type": "para", "indent": 4, "text": ["The VEX type of the variable named in the ", {"type": "code", "text": ["plane:planevariable"]}, " property."], "extent": [195898, 195981]}], "container": true, "attrs": {"ifdprop": "plane:vextype"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["plane:lightexport"]}], "role": "item", "extent": [195981, 196004], "body": [{"type": "para", "indent": 4, "text": ["Name of a light object associated with the VEX variable. If this is set, the variable is exported at the conclusion of the illuminance loops run for the light."], "extent": [196041, 196210]}], "container": true, "attrs": {"ifdprop": "plane:lightexport"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["plane:component"]}], "role": "item", "extent": [196210, 196231], "body": [{"type": "para", "indent": 4, "text": ["Whether per-component export is enabled."], "extent": [196266, 196316]}], "container": true, "attrs": {"ifdprop": "plane:component"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["plane:gamma"]}], "role": "item", "extent": [196316, 196333], "body": [{"type": "para", "indent": 4, "text": ["Gamma correction value for the image plane."], "extent": [196364, 196417]}], "container": true, "attrs": {"ifdprop": "plane:gamma"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["plane:excludedcm"]}], "role": "item", "extent": [196417, 196439], "body": [{"type": "para", "indent": 4, "text": ["Whether to exclude the plane from deep camera map rendering."], "extent": [196471, 196541]}], "container": true, "attrs": {"ifdprop": "plane:excludedcm"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["plane:showrelightingbuffer"]}], "role": "item", "extent": [196541, 196573], "body": [{"type": "para", "indent": 4, "text": ["Whether to include the plane in the relighting buffer"], "extent": [196615, 196678]}], "container": true, "attrs": {"ifdprop": "plane:showrelightingbuffer"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["plane:gain"]}], "role": "item", "extent": [196678, 196694], "body": [{"type": "para", "indent": 4, "text": ["Gain value for the image plane."], "extent": [196724, 196765]}], "container": true, "attrs": {"ifdprop": "plane:gain"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["plane:quantize"]}], "role": "item", "extent": [196765, 196785], "body": [{"type": "para", "indent": 4, "text": ["The storage type for the plane image.  The type of quantization used will affect image quality and size.  If you need to adjust the image\u2019s dynamic range in compositing, you should normally leave this value at the default of 16-bit floating point."], "extent": [196819, 197076]}, {"type": "para", "indent": 4, "text": ["The default is ", {"type": "code", "text": ["\"float16\""]}, " for the first plane, and ", {"type": "code", "text": ["\"float\""]}, " for secondary planes. You can override the first plane\u2019s value with the ", {"type": "code", "text": ["-b"]}, " command line argument to mantra."], "extent": [197076, 197253]}], "container": true, "attrs": {"ifdprop": "plane:quantize"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["plane:disable"]}], "role": "item", "extent": [197253, 197272], "body": [{"type": "para", "indent": 4, "text": ["Disables the output of the image plane."], "extent": [197305, 197350]}], "container": true, "attrs": {"ifdprop": "plane:disable"}}], "container": true, "role": "item_group"}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Implicit properties"], "extent": [197350, 197378], "body": [{"type": "para", "indent": 0, "text": ["These properties are only meaningful in IFD:"], "extent": [197378, 197425]}, {"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["renderer:name"]}], "role": "item", "extent": [197425, 197449], "body": [{"type": "para", "indent": 4, "text": ["Read only variable holding the renderer\u2019s name."], "extent": [197449, 197506]}], "container": true}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["renderer:version"]}], "role": "item", "extent": [197506, 197528], "body": [{"type": "para", "indent": 4, "text": ["Example: (9, 0, 614)"], "extent": [197528, 197558]}, {"type": "para", "indent": 4, "text": ["Read only triple of the major version, minor version, and build number of the renderer."], "extent": [197558, 197655]}], "container": true}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["object:id"]}], "role": "item", "extent": [197655, 197670], "body": [{"type": "para", "indent": 4, "text": ["Example: (0)"], "extent": [197670, 197692]}, {"type": "para", "indent": 4, "text": ["An integer value which can be queried from within shaders. Not supported for per-primitive material assignment (in the ", {"scheme": "Node", "value": "/nodes/sop/material", "type": "link", "text": ["Material surface node"], "fullpath": "/nodes/sop/material"}, ")."], "extent": [197692, 197860]}], "container": true}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["object:area"]}], "role": "item", "extent": [197860, 197877], "body": [{"type": "para", "indent": 4, "text": ["Example: (1.0)"], "extent": [197877, 197901]}, {"type": "para", "indent": 4, "text": ["Read only floating point value that provides the surface area of the object currently being shaded."], "extent": [197901, 198006]}], "container": true}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["light:arealight"]}], "role": "item", "extent": [198006, 198027], "body": [{"type": "para", "indent": 4, "text": ["Example: (1)"], "extent": [198027, 198049]}, {"type": "para", "indent": 4, "text": ["Read only integer value that indicates whether the current light (for example in an illuminance loop) is an area light."], "extent": [198049, 198174]}], "container": true}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["light:distantlight"]}], "role": "item", "extent": [198174, 198198], "body": [{"type": "para", "indent": 4, "text": ["Example: (1)"], "extent": [198198, 198220]}, {"type": "para", "indent": 4, "text": ["Read only integer value that indicates whether the current light (for example in an illuminance loop) is a distant light source (an environment light or directional light)."], "extent": [198220, 198398]}], "container": true}], "container": true, "role": "item_group"}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Computed properties"], "extent": [198398, 198426], "body": [{"type": "para", "indent": 0, "text": ["The following properties are computed in scripts  during the mapping process. They do not have directly equivalent Houdini properties."], "extent": [198426, 198563]}, {"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["image:resolution"]}], "role": "item", "extent": [198563, 198585], "body": [{"type": "para", "indent": 4, "text": ["The output image resolution."], "extent": [198621, 198655]}], "container": true, "attrs": {"ifdprop": "image:resolution"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["image:field"]}], "role": "item", "extent": [198655, 198672], "body": [{"type": "para", "indent": 4, "text": ["The video field to render."], "extent": [198699, 198735]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["0"]}], "extent": [198735, 198744], "body": [{"type": "para", "indent": 8, "text": ["Both even & odd fields."], "extent": [198744, 198776]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["1"]}], "extent": [198776, 198785], "body": [{"type": "para", "indent": 8, "text": ["Odd field."], "extent": [198785, 198804]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["2"]}], "extent": [198804, 198813], "body": [{"type": "para", "indent": 8, "text": ["Even field."], "extent": [198813, 198834]}], "container": true}], "container": true}], "container": true, "attrs": {"ifdprop": "image:field"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["image:crop"]}], "role": "item", "extent": [198834, 198850], "body": [{"type": "para", "indent": 4, "text": ["A rectangle in screen space as (", {"type": "code", "text": ["xmin"]}, ", ", {"type": "code", "text": ["xmax"]}, ", ", {"type": "code", "text": ["ymin"]}, ", ", {"type": "code", "text": ["ymax"]}, "), where the values are between 0 and 1. Only pixels within this region will be rendered."], "extent": [198880, 199041]}], "container": true, "attrs": {"ifdprop": "image:crop"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["image:window"]}], "role": "item", "extent": [199041, 199059], "body": [{"type": "para", "indent": 4, "text": ["This is used in determining the camera projection. Like the crop window, this specifies a rectangle in the screen. Unlike the crop window, the window is expanded to fill the full image."], "extent": [199087, 199282]}], "container": true, "attrs": {"ifdprop": "image:window"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["light:window"]}], "role": "item", "extent": [199282, 199300], "body": [{"type": "para", "indent": 4, "text": ["This property is used when computing the projection matrix for light sources in shadow mapping.  If the projection from the texture is used (default behavior), this property is ignored."], "extent": [199328, 199523]}], "container": true, "attrs": {"ifdprop": "light:window"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["camera:projection"]}], "role": "item", "extent": [199523, 199546], "body": [{"type": "para", "indent": 4, "text": ["The camera\u2019s projection model. This may be one of ", {"type": "code", "text": ["perspective"]}, ", ", {"type": "code", "text": ["orthographic"]}, ", ", {"type": "code", "text": ["polar"]}, ", or ", {"type": "code", "text": ["cylindrical"]}, "."], "extent": [199583, 199700]}], "container": true, "attrs": {"ifdprop": "camera:projection"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["camera:clip"]}], "role": "item", "extent": [199700, 199717], "body": [{"type": "para", "indent": 4, "text": ["Near and far clipping planes for the projection."], "extent": [199748, 199806]}], "container": true, "attrs": {"ifdprop": "camera:clip"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["camera:zoom"]}], "role": "item", "extent": [199806, 199823], "body": [{"type": "para", "indent": 4, "text": ["Ratio of the focal length to the aperture of the camera. It is used to determine the field of view of the camera. "], "extent": [199854, 199974]}], "container": true, "attrs": {"ifdprop": "camera:zoom"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["camera:focal"]}], "role": "item", "extent": [199974, 199992], "body": [], "container": true, "attrs": {"ifdprop": "camera:focal"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["camera:stereoeye"]}], "role": "item", "extent": [200020, 200042], "body": [{"type": "para", "indent": 4, "text": ["Not an intrinsic mantra property, but added by SOHO when rendering stereo\n    pairs."], "extent": [200074, 200164]}, {"type": "para", "indent": 4, "text": ["This is used to determine whether a camera represents the left eye or the\n    right eye in a stereo projection. If stereo is not enabled for the camera,\n    this property is undefined."], "extent": [200164, 200354]}, {"type": "para", "indent": 4, "text": ["If defined, the value may be one of ", {"type": "code", "text": ["left"]}, ", ", {"type": "code", "text": ["right"]}, ", or ", {"type": "code", "text": ["both"]}, "."], "extent": [200354, 200423]}], "container": true, "attrs": {"ifdprop": "camera:stereoeye"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["geometry:name"]}], "role": "item", "extent": [200423, 200442], "body": [{"type": "para", "indent": 4, "text": ["The name associated with the geometry. This is the name which instance objects use to access the geometry."], "extent": [200475, 200587]}], "container": true, "attrs": {"ifdprop": "geometry:name"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["geometry:basepath"]}], "role": "item", "extent": [200587, 200610], "body": [{"type": "para", "indent": 4, "text": ["Materials may be specified on a per-primitive basis. However, since materials refer to SHOP paths, it\u2019s sometimes important to be able to resolve relative paths."], "extent": [200647, 200814]}], "container": true, "attrs": {"ifdprop": "geometry:basepath"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["object:surface"]}], "role": "item", "extent": [200814, 200834], "body": [{"type": "para", "indent": 4, "text": ["The surface shader attached to the object."], "extent": [200868, 200916]}], "container": true, "attrs": {"ifdprop": "object:surface"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["object:displace"]}], "role": "item", "extent": [200916, 200937], "body": [{"type": "para", "indent": 4, "text": ["The displacement shader attached to the object."], "extent": [200968, 201021]}], "container": true, "attrs": {"ifdprop": "object:displace"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["fog:shader"]}], "role": "item", "extent": [201021, 201037], "body": [{"type": "para", "indent": 4, "text": ["The VEX shader used to shade a fog object."], "extent": [201067, 201119]}], "container": true, "attrs": {"ifdprop": "fog:shader"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["light:shader"]}], "role": "item", "extent": [201119, 201137], "body": [{"type": "para", "indent": 4, "text": ["The shader used to compute the illumination of the light source."], "extent": [201169, 201243]}], "container": true, "attrs": {"ifdprop": "light:shader"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["light:shadow"]}], "role": "item", "extent": [201243, 201261], "body": [{"type": "para", "indent": 4, "text": ["The shader used to compute occlusion of light from the light source."], "extent": [201293, 201367]}], "container": true, "attrs": {"ifdprop": "light:shadow"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["light:samplershader"]}], "role": "item", "extent": [201367, 201392], "body": [{"type": "para", "indent": 4, "text": ["This is a light shader used to handle geometry light intersections.  This is used to implement the ", {"type": "code", "text": ["sample_light()"]}, " function for area lights.  This light shader cannot reference any global variables or light-specific functionality."], "extent": [201431, 201672]}], "container": true, "attrs": {"ifdprop": "light:samplershader"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["light:tracershader"]}], "role": "item", "extent": [201672, 201696], "body": [{"type": "para", "indent": 4, "text": ["This is a light shader used to handle geometry light intersections.  This is used to implement the ", {"type": "code", "text": ["intersect_lights()"]}, " function for area lights.  This light shader cannot reference any global variables or light-specific functionality."], "extent": [201734, 201979]}], "container": true, "attrs": {"ifdprop": "light:tracershader"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["light:projection"]}], "role": "item", "extent": [201979, 202001], "body": [{"type": "para", "indent": 4, "text": ["Used when computing NDC (Normalized Device Coordinates) from within VEX shaders."], "extent": [202037, 202127]}], "container": true, "attrs": {"ifdprop": "light:projection"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["light:zoom"]}], "role": "item", "extent": [202127, 202143], "body": [{"type": "para", "indent": 4, "text": ["Used when computing NDC (Normalized Device Coordinates) from within VEX shaders."], "extent": [202173, 202263]}], "container": true, "attrs": {"ifdprop": "light:zoom"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["light:orthowidth"]}], "role": "item", "extent": [202263, 202285], "body": [{"type": "para", "indent": 4, "text": ["Used when computing NDC (Normalized Device Coordinates) from within VEX shaders."], "extent": [202321, 202407]}], "container": true, "attrs": {"ifdprop": "light:orthowidth"}}], "container": true, "role": "item_group"}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Misc. properties"], "extent": [202407, 202430], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Descriptive Name"], "role": "item", "extent": [202430, 202451], "body": [{"type": "para", "indent": 4, "text": ["A literal string to use as the ", {"type": "q", "text": ["descriptive text"]}, " displayed with the\n    render node in the network editor. Usually, you will want to set\n    ", {"type": "code", "text": ["soho_descriptiveparmname"]}, " instead, since it\u2019s more useful to show the\n    value of a parameter instead of a static string."], "extent": [202489, 202760]}], "container": true, "attrs": {"hprop": "soho_descriptivename"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Descriptive Parm Name"], "role": "item", "extent": [202760, 202785], "body": [{"type": "para", "indent": 4, "text": ["The internal name of a paremeter to use as the content of the ", {"type": "q", "text": ["descriptive\n    text"]}, " displayed with the render node in the network editor. For example, if\n    you set this ", {"type": "code", "text": ["camera"]}, ", the network editor will display the value of the\n    render node\u2019s Camera parameter beside the node in the network editor."], "extent": [202827, 203137]}], "container": true, "attrs": {"hprop": "soho_descriptiveparmname"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["vm_motiontimescale"]}, " / ", {"type": "code", "text": ["geometry:timescale"]}], "role": "item", "extent": [203137, 203184], "body": [{"type": "para", "indent": 4, "text": ["When the ", {"type": "code", "text": ["-v"]}, " option is specified on the ", {"type": "code", "text": ["ray_detail"]}, " line, this determines the time scale for velocity based motion blur."], "extent": [203249, 203377]}, {"type": "para", "indent": 4, "text": ["You must add this as a float spare parameter if you want to change it, since it doesn\u2019t exist in the render properties interface."], "extent": [203377, 203512]}], "container": true, "attrs": {"hprop": "vm_motiontimescale", "ifdprop": "geometry:timescale"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": [{"type": "code", "text": ["vobject"]}], "role": "item", "extent": [203512, 203525], "body": [{"type": "para", "indent": 4, "text": ["Is a spare parameter on the camera that will influence which objects are captured by the camera. This parameter is also recognized in the viewport, so if the camera has this parameter defined, when viewing through the camera the viewport will use it as a mask to filter which options should be visible."], "extent": [203550, 203858]}], "container": true, "attrs": {"hprop": "vobject"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Shading position (P)"], "role": "item", "extent": [203858, 203882], "body": [{"type": "para", "indent": 4, "text": ["Add an extra image plane for the shading position (", {"type": "code", "text": ["P"]}, ") using pre-defined settings.  For finer control, add the image channel using the generic image plane interface."], "extent": [203911, 204083]}], "container": true, "attrs": {"hprop": "vm_quickplane_P"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Shading depth (Pz)"], "role": "item", "extent": [204083, 204105], "body": [{"type": "para", "indent": 4, "text": ["Add an extra image plane for the shading depth (", {"type": "code", "text": ["Pz"]}, ") using pre-defined settings.  For finer control, add the image channel using the generic image plane interface."], "extent": [204135, 204305]}], "container": true, "attrs": {"hprop": "vm_quickplane_Pz"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Shading normal (N)"], "role": "item", "extent": [204305, 204327], "body": [{"type": "para", "indent": 4, "text": ["Add an extra image plane for the shading normal (", {"type": "code", "text": ["N"]}, ") using pre-defined settings.  For finer control, add the image channel using the generic image plane interface."], "extent": [204356, 204526]}], "container": true, "attrs": {"hprop": "vm_quickplane_N"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Shading tangent-space normal (Nt)"], "role": "item", "extent": [204526, 204563], "body": [{"type": "para", "indent": 4, "text": ["Add an extra image plane for the shading tangent-space normal (", {"type": "code", "text": ["Nt"]}, ") using pre-defined settings.  For finer control, add the image channel using the generic image plane interface."], "extent": [204593, 204778]}, {"type": "para", "indent": 4, "text": ["This is specific to texture baking and exists by default on the baking output driver."], "extent": [204778, 204869]}], "container": true, "attrs": {"hprop": "vm_quickplane_Nt"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Combined lighting (per-component)"], "role": "item", "extent": [204869, 204906], "body": [{"type": "para", "indent": 4, "text": ["Add an extra image plane for the combined lighting (all components) using pre-defined settings.  For finer control, add the image channel using the generic image plane interface."], "extent": [204942, 205126]}], "container": true, "attrs": {"hprop": "vm_quickplane_all_comp"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Direct lighting (per-component)"], "role": "item", "extent": [205126, 205161], "body": [{"type": "para", "indent": 4, "text": ["Add an extra image plane for the direct lighting (all components) using pre-defined settings.  For finer control, add the image channel using the generic image plane interface."], "extent": [205200, 205382]}], "container": true, "attrs": {"hprop": "vm_quickplane_direct_comp"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Indirect lighting (per-component)"], "role": "item", "extent": [205382, 205419], "body": [{"type": "para", "indent": 4, "text": ["Add an extra image plane for the indirect lighting (all components) using pre-defined settings.  For finer control, add the image channel using the generic image plane interface."], "extent": [205460, 205644]}], "container": true, "attrs": {"hprop": "vm_quickplane_indirect_comp"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Combined emission"], "role": "item", "extent": [205644, 205665], "body": [{"type": "para", "indent": 4, "text": ["Add an extra image plane for all types of light emission using pre-defined settings.  For finer control, add the image channel using the generic image plane interface."], "extent": [205705, 205878]}], "container": true, "attrs": {"hprop": "vm_quickplane_all_emission"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Direct unshadowed"], "role": "item", "extent": [205878, 205899], "body": [{"type": "para", "indent": 4, "text": ["Add an extra image plane for the direct, un-shadowed lighting using pre-defined settings.  For finer control, add the image channel using the generic image plane interface."], "extent": [205942, 206120]}], "container": true, "attrs": {"hprop": "vm_quickplane_direct_noshadow"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Direct ray samples"], "role": "item", "extent": [206120, 206142], "body": [{"type": "para", "indent": 4, "text": ["Add an extra image plane for the number of direct shading samples using pre-defined settings.  For finer control, add the image channel using the generic image plane interface."], "extent": [206184, 206366]}], "container": true, "attrs": {"hprop": "vm_quickplane_direct_samples"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Indirect ray samples"], "role": "item", "extent": [206366, 206390], "body": [{"type": "para", "indent": 4, "text": ["Add an extra image plane for the number of indirect shading samples using pre-defined settings.  For finer control, add the image channel using the generic image plane interface."], "extent": [206434, 206618]}], "container": true, "attrs": {"hprop": "vm_quickplane_indirect_samples"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["SSS Single/Multi"], "role": "item", "extent": [206618, 206638], "body": [{"type": "para", "indent": 4, "text": ["Add two extra image planes for single and multiple subsurface scattering using pre-defined settings.  For finer control, add the image channel using the generic image plane interface."], "extent": [206669, 206858]}], "container": true, "attrs": {"hprop": "vm_quickplane_sss"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Tangent Space Normal (Nt)"], "role": "item", "extent": [206858, 206887], "body": [{"type": "para", "indent": 4, "text": ["Used when baking textures. The high-res object\u2019s normal projected into the low-res object\u2019s tangent-space."], "extent": [206917, 207029]}], "container": true, "attrs": {"hprop": "vm_quickplane_Nt"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Displacement (Ds)"], "role": "item", "extent": [207029, 207050], "body": [{"type": "para", "indent": 4, "text": ["Used when baking textures. Stores the magnitude between the high-res and low-res objects."], "extent": [207080, 207175]}], "container": true, "attrs": {"hprop": "vm_quickplane_Ds"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Vector Displacement (Vd)"], "role": "item", "extent": [207175, 207203], "body": [{"type": "para", "indent": 4, "text": ["Used when baking textures. Stores the deltas between the high-res and low-res objects."], "extent": [207233, 207325]}], "container": true, "attrs": {"hprop": "vm_quickplane_Vd"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Tangent-Space Vector Displacement (Vdt)"], "role": "item", "extent": [207325, 207368], "body": [{"type": "para", "indent": 4, "text": ["Used when baking textures. Stores the deltas between the high-res and low-res objects in the low-res object\u2019s tangent-space."], "extent": [207399, 207529]}], "container": true, "attrs": {"hprop": "vm_quickplane_Vdt"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Occlusion (Oc)"], "role": "item", "extent": [207529, 207547], "body": [{"type": "para", "indent": 4, "text": ["Used when baking textures. The occlusion at the shading position."], "extent": [207577, 207648]}], "container": true, "attrs": {"hprop": "vm_quickplane_Oc"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Cavity (Cv)"], "role": "item", "extent": [207648, 207663], "body": [{"type": "para", "indent": 4, "text": ["Used when baking textures. The occlusion along the inverted normal at the shading position.  This produces ", {"type": "q", "text": ["relief"]}, " shading."], "extent": [207693, 207823]}], "container": true, "attrs": {"hprop": "vm_quickplane_Cv"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Thickness (Th)"], "role": "item", "extent": [207823, 207841], "body": [{"type": "para", "indent": 4, "text": ["Used when baking textures. The thickness at the shading position."], "extent": [207871, 207942]}], "container": true, "attrs": {"hprop": "vm_quickplane_Th"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Curvature (Cu)"], "role": "item", "extent": [207942, 207960], "body": [{"type": "para", "indent": 4, "text": ["Used when baking textures. The curvature at the shading position."], "extent": [207990, 208061]}], "container": true, "attrs": {"hprop": "vm_quickplane_Cu"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Alpha (Ab)"], "role": "item", "extent": [208061, 208075], "body": [{"type": "para", "indent": 4, "text": ["Used when baking textures. The Alpha channel with white in areas where\n    rays hit the high-res object."], "extent": [208105, 208215]}], "container": true, "attrs": {"hprop": "vm_quickplane_Ab"}}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Baking Properties"], "extent": [208215, 208239], "body": [{"type": "properties_item_group", "body": [{"ext": null, "type": "properties_item", "indent": 0, "text": ["Disable Lighting/Emission"], "role": "item", "extent": [208239, 208269], "body": [{"type": "para", "indent": 4, "text": ["Disables all lighting on primary image plane in order to make baking faster."], "extent": [208296, 208378]}], "container": true, "attrs": {"hprop": "vm_bake_skipcf"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Add Baking Exports to Shader Layers"], "role": "item", "extent": [208378, 208417], "body": [{"type": "para", "indent": 4, "text": ["Add baking related shader exports to layers structs, so they can be mixed by layer compositing operations and finally exported."], "extent": [208449, 208582]}], "container": true, "attrs": {"hprop": "vm_bake_layerexport"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Baking samples"], "role": "item", "extent": [208582, 208600], "body": [{"type": "para", "indent": 4, "text": ["Number of samples to use for raytraced shading (eg. Occlusion, Cavity, Thickness). Increasing the number of samples will reduce noise in the shading."], "extent": [208628, 208783]}], "container": true, "attrs": {"hprop": "vm_bake_samples"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Use MikkT Tangent Space"], "role": "item", "extent": [208783, 208810], "body": [{"type": "para", "indent": 4, "text": ["Use Mikkelsen\u2019s Tangent Space for baking tangent space normals (", {"type": "code", "text": ["Nt"]}, "). The basis is computed per-fragment (Unreal Engine compatible). Use a ", {"scheme": "Node", "value": "/nodes/sop/divide", "type": "link", "text": ["Divide SOP"], "fullpath": "/nodes/sop/divide"}, " to convert the UV Object into triangle mesh before baking because other applications may interpolate tangents across quads differently."], "extent": [208881, 209191]}], "container": true, "attrs": {"hprop": "vm_bake_usemikkt", "ifdprop": "renderer:bake_usemikkt"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Tangent Normal Face Forward"], "role": "item", "extent": [209191, 209222], "body": [{"type": "para", "indent": 4, "text": ["When enabled, backfacing normals in tangent space (i.e. its Z axis in tangent basis is negative) will be flipped to always face forward."], "extent": [209313, 209455]}], "container": true, "attrs": {"hprop": "vm_bake_normalsfaceforward", "ifdprop": "renderer:bake_normalsfaceforward"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Tangent Normal Flip X"], "role": "item", "extent": [209455, 209480], "body": [{"type": "para", "indent": 4, "text": ["Toggles flipping of the normal\u2019s X axis. Various packages may expect normal maps in different spaces. The flip parameters allow you to match these various spaces."], "extent": [209519, 209687]}], "container": true, "attrs": {"hprop": "vm_bake_tangentnormalflipx"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Tangent Normal Flip Y"], "role": "item", "extent": [209687, 209712], "body": [{"type": "para", "indent": 4, "text": ["Toggles flipping of the normal\u2019s Y axis. Various packages may expect normal maps in different spaces. The flip parameters allow you to match these various spaces."], "extent": [209751, 209919]}], "container": true, "attrs": {"hprop": "vm_bake_tangentnormalflipy"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Include Displacement in Tangent Normal"], "role": "item", "extent": [209919, 209961], "body": [], "container": true, "attrs": {"hprop": "vm_bake_tangentnormalincludedisp"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Occlusion Bias"], "role": "item", "extent": [210017, 210035], "body": [{"type": "para", "indent": 4, "text": ["This acts as a contrast control over the occlusion shading, with values higher and lower than ", {"type": "code", "text": ["0.5"]}, " resulting in more and less contrast."], "extent": [210069, 210211]}], "container": true, "attrs": {"hprop": "vm_bake_occlusionbias"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Cavity Distance"], "role": "item", "extent": [210211, 210230], "body": [{"type": "para", "indent": 4, "text": ["Controls the distance within which features will influence the shading."], "extent": [210265, 210342]}], "container": true, "attrs": {"hprop": "vm_bake_cavitydistance"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Cavity Bias"], "role": "item", "extent": [210342, 210357], "body": [{"type": "para", "indent": 4, "text": ["This acts as a contrast control over the cavity occlusion shading, with values higher and lower than ", {"type": "code", "text": ["0.5"]}, " resulting in more and less contrast."], "extent": [210388, 210537]}], "container": true, "attrs": {"hprop": "vm_bake_cavitybias"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Occlusion-based Curvature"], "role": "item", "extent": [210537, 210566], "body": [{"type": "para", "indent": 4, "text": ["This is a course but fast approximation for measuring curvature. When off (the default), the renderer measures curvature using local topology. Turning this on measures curvature by casting occlusion rays. The number of occlusion rays is controlled by ", {"type": "ui", "text": ["Baking Samples"]}, " parameter."], "extent": [210604, 210890]}], "container": true, "attrs": {"hprop": "vm_bake_curvatureocc"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Curvature Ray Distance"], "role": "item", "extent": [210890, 210916], "body": [{"type": "para", "indent": 4, "text": ["Maximum occlusion ray distance to use when ", {"type": "ui", "text": ["Occlusion-based Curvature"]}, " is on."], "extent": [210956, 211041]}], "container": true, "attrs": {"hprop": "vm_bake_curvaturesdist"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Curvature Scale"], "role": "item", "extent": [211041, 211060], "body": [{"type": "para", "indent": 4, "text": ["Multiplies the output curvature value. If you are seeing any curvature shading you should increase this value until the gradient is visible."], "extent": [211100, 211246]}], "container": true, "attrs": {"hprop": "vm_bake_curvaturescale"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Curvature Bias"], "role": "item", "extent": [211246, 211264], "body": [{"type": "para", "indent": 4, "text": ["This acts as a contrast control over the curvature\u2019s shading, with values higher and lower than ", {"type": "code", "text": ["0.5"]}, " resulting in more and less contrast."], "extent": [211303, 211451]}], "container": true, "attrs": {"hprop": "vm_bake_curvaturebias"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Custom UDIM Range"], "role": "item", "extent": [211451, 211472], "body": [{"type": "para", "indent": 4, "text": ["Used to specify UDIM tiles to bake. Example: ", {"type": "q", "text": ["1001-1004,1011"]}, " (without quotes). If left blank, mantra will bake all UDIM tiles the UV object occupies."], "extent": [211545, 211701]}], "container": true, "attrs": {"hprop": "vm_bake_udimrange", "ifdprop": "renderer:bake_udimrange"}}, {"ext": null, "type": "properties_item", "indent": 0, "text": ["Extra image planes"], "role": "item", "extent": [211701, 211723], "body": [{"type": "para", "indent": 4, "text": ["These controls let you output VEX variables as auxiliary image planes, either as extra planes in the output file or extra files."], "extent": [211750, 211888]}, {"type": "tip_group", "body": [{"type": "tip", "indent": 4, "role": "item", "extent": [211888, 211897], "body": [{"type": "para", "indent": 8, "text": ["As of Houdini 9.1, each channel can now be written out to a different file. This lets you work with OpenEXR programs that don\u2019t support multiple channels in a single ", {"type": "code", "text": [".exr"]}, " image."], "extent": [211897, 212090]}, {"type": "para", "indent": 8, "text": ["You can also do fancy stuff like send one channel to the ", {"type": "code", "text": ["md"]}, " device (a non-interactive MPlay window), or split your image into multiple ", {"type": "code", "text": [".pic"]}, " files with a handful of ", {"type": "code", "text": [".tif"]}, " files thrown in. But if the primary image is ", {"type": "code", "text": ["ip"]}, ", all planes go to ", {"type": "code", "text": ["ip"]}, "."], "extent": [212090, 212352]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 4, "text": ["The Channel Name parameter lets you give the channel in the output file a different name than the default (the name of the VEX variable). For example, you want to send out the Of variable. If the Channel Name is left blank, the plane name in the ", {"type": "code", "text": [".pic"]}, " file will be ", {"type": "code", "text": ["Of"]}, ". If you set Channel Name to ", {"type": "code", "text": ["Opacity"]}, ", the plane in the ", {"type": "code", "text": [".pic"]}, " file will be called ", {"type": "code", "text": ["Opacity"]}, "."], "extent": [212352, 212721]}], "container": true, "attrs": {"hprop": "vm_numaux"}}], "container": true, "role": "item_group"}]}], "text": "Properties"}], "title": ["Mantra rendering properties"], "included": ["/props/_minmax_styles"]}