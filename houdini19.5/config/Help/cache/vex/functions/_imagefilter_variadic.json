{"type": "root", "attrs": {"type": "include"}, "body": [{"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Image filtering options"], "extent": [16, 46], "body": [{"type": "para", "indent": 0, "text": ["Examples of specifying filter parameters:"], "extent": [46, 90]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\ncolormap(map, u, v, \"smode\", \"decal\", \"tmode\", \"repeat\", \"border\", {.1,1,1});\ncolormap(map, u, v, \"mode\", \"clamp\", \"width\", 1.3);\ncolormap(map, u, v, \"filter\", \"gauss\", \"width\", 1.3, \"mode\", \"repeat\");\n"], "extent": [90, 306]}, {"type": "para", "indent": 0, "text": ["If the texture is a deep ", {"type": "code", "text": [".rat"]}, " file, you can use the ", {"type": "code", "text": ["\"channel\""]}, " keyword argument\nto specify a channel in the file:"], "extent": [306, 425]}, {"lang": null, "type": "pre", "indent": 0, "text": ["\nstring channelname = \"N\";\ncf = colormap(map, u, v, \"channel\", channelname);\n"], "extent": [425, 509]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["When you read a texture in a format other than Houdini\u2019s native ", {"type": "code", "text": [".pic"]}, " or ", {"type": "code", "text": [".rat"]}, ", Houdini uses ", {"scheme": "Wp", "value": "http://en.wikipedia.org/wiki/OpenImageIO", "type": "link", "text": ["OpenImageIO"], "exists": true}, " to read the image data from the file. In that case, some of the variadic arguments below may not have any effect."], "extent": [509, 751]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["When the texture function evaluates non-houdini format textures, Houdini switches to use OpenImageIO for texture evaluation.  While there are corresponding values to many of the variadic keywords, some keywords don\u2019t have an equivalent function in OpenImageIO."], "extent": [751, 1015], "body": [{"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["OIIO will ", {"type": "em", "text": ["not"]}, " create MIP maps for images that don\u2019t have multi-resolution images by default. You can turn this on by adding ", {"type": "code", "text": ["automip=1"]}, " to the content of the the ", {"type": "code", "text": ["OPENIMAGEIO_IMAGECACHE_OPTIONS"]}, " environment variable."], "extent": [1015, 1241], "body": [{"type": "para", "indent": 8, "text": ["Without MIP maps, blurring and filtering may not work as expected."], "extent": [1241, 1317]}], "container": true}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["You can also use ", {"type": "code", "text": ["OPENIMAGEIO_IMAGECACHE_OPTIONS"]}, " to override the amount of memory OIIO uses for caching."], "extent": [1317, 1430], "body": [{"type": "para", "indent": 8, "text": ["By default, Houdini will set the cache memory to 1/8th of the physical computer memory.  If you set the ", {"type": "code", "text": ["OPENIMAGEIO_IMAGECACHE_OPTIONS"]}, " variable it overrides that computed cache size."], "extent": [1430, 1624]}], "container": true}], "container": true}], "container": true}], "container": true}, {"type": "arg_group", "body": [{"ext": null, "type": "arg", "indent": 0, "text": ["wrap"], "role": "item", "extent": [1624, 1636], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["repeat"]}, " or ", {"type": "code", "text": ["periodic"]}, " "], "extent": [1682, 1711], "body": [{"type": "para", "indent": 8, "text": ["The image map will repeat outside the range 0 to 1.\n        Basically, the integer component of the texture\n        coordinate is ignored. This is the default."], "extent": [1711, 1879]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["clamp"]}, " or ", {"type": "code", "text": ["edge"]}, " or ", {"type": "code", "text": ["streak"]}, " "], "extent": [1879, 1915], "body": [{"type": "para", "indent": 8, "text": ["The texture coordinates will be clamped to the range 0\n        to 1. This causes evaluations outside the range to\n        evaluate to the color at the closest edge of the image\n        (the border pixels are streaked outside the range)."], "extent": [1915, 2160]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["black"]}, " or ", {"type": "code", "text": ["decal"]}, " or ", {"type": "code", "text": ["color"]}, " "], "extent": [2160, 2196], "body": [{"type": "para", "indent": 8, "text": ["Coordinates outside the range 0 to 1 will evaluate to\n        the border color (rather than a color in the image). The\n        border color is black (i.e. 0) by default."], "extent": [2196, 2375]}], "container": true}], "container": true}], "container": true, "attrs": {"type": "string", "default": "\"repeat\""}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["uwrap"], "role": "item", "extent": [2375, 2388], "body": [{"type": "para", "indent": 4, "text": ["(AKA ", {"type": "code", "text": ["swrap"]}, ")\n    Specifies the behavior when the u coordinate is outside\n    the range 0 to 1. The values are the same as with ", {"type": "code", "text": ["wrap"]}, "."], "extent": [2411, 2552]}], "container": true, "attrs": {"type": "string"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["vwrap"], "role": "item", "extent": [2552, 2565], "body": [{"type": "para", "indent": 4, "text": ["(AKA ", {"type": "code", "text": ["twrap"]}, ")\n    Specifies the behavior when the v coordinate is outside\n    the range 0 to 1. The values are the same as with ", {"type": "code", "text": ["wrap"]}, "."], "extent": [2588, 2729]}], "container": true, "attrs": {"type": "string"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["border"], "role": "item", "extent": [2729, 2743], "body": [{"type": "para", "indent": 4, "text": ["Specifies the border color when Black/Decal/Color wrapping is used.\n    ", {"type": "strong", "text": ["Has no effect for OpenImageIO formats"]}, "."], "extent": [2796, 2914]}], "container": true, "attrs": {"type": "float|vector|vector4", "default": "0"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["channel"], "role": "item", "extent": [2914, 2929], "body": [{"type": "para", "indent": 4, "text": ["Specifies the color channel for textures that have multiple color\n    planes (for example, ", {"type": "code", "text": ["diffuse_indirect"]}, " or ", {"type": "code", "text": ["N"]}, ").\n    For ptex images, this specifies the index of the first channel\n    (for example, ", {"type": "code", "text": ["0"]}, " or ", {"type": "code", "text": ["4"]}, ")."], "extent": [2929, 3155]}], "container": true, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["blur"], "role": "item", "extent": [3155, 3167], "body": [{"type": "para", "indent": 4, "text": ["Blurs in x and y directions. Blur is measured as a percentage\n    of the image size - so a blur of 0.1 will blur 10% of the image\n    width.  Use ", {"type": "code", "text": ["xblur"]}, " and ", {"type": "code", "text": ["yblur"]}, " if you need different blur\n    amounts in either dimension."], "extent": [3189, 3420]}], "container": true, "attrs": {"type": "float"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["xblur"], "role": "item", "extent": [3420, 3433], "body": [{"type": "para", "indent": 4, "text": ["(AKA ", {"type": "code", "text": ["ublur"]}, ", ", {"type": "code", "text": ["sblur"]}, ")\n    Blur amount in the x image direction."], "extent": [3433, 3507]}], "container": true, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["yblur"], "role": "item", "extent": [3507, 3520], "body": [{"type": "para", "indent": 4, "text": ["(AKA ", {"type": "code", "text": ["vblur"]}, ", ", {"type": "code", "text": ["tblur"]}, ")\n    Blur amount in the y image direction."], "extent": [3520, 3594]}], "container": true, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["pixelblur"], "role": "item", "extent": [3594, 3611], "body": [{"type": "para", "indent": 4, "text": ["Blurs the texture by a floating point number of pixels.\n    ", {"type": "strong", "text": ["Has no effect for OpenImageIO formats"]}, "."], "extent": [3633, 3743]}, {"lang": "vex", "type": "pre", "indent": 4, "text": ["\n    Cf = texture(\"map.rat\", ss, tt, \"pixelblur\", 2.0);\n    "], "extent": [3743, 3824]}], "container": true, "attrs": {"type": "float"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["xpixelblur"], "role": "item", "extent": [3824, 3843], "body": [{"type": "para", "indent": 4, "text": ["Blurs the texture by a floating point number of pixels in the X direction."], "extent": [3865, 3945]}], "container": true, "attrs": {"type": "float"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["ypixelblur"], "role": "item", "extent": [3945, 3963], "body": [{"type": "para", "indent": 4, "text": ["Blurs the texture by a floating point number of pixels in the Y direction."], "extent": [3985, 4069]}], "container": true, "attrs": {"type": "float"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["filter"], "role": "item", "extent": [4069, 4083], "body": [{"type": "para", "indent": 4, "text": ["Specifies the type of anti-aliasing filter to be used for\n    evaluation."], "extent": [4126, 4205]}, {"type": "para", "indent": 4, "text": [{"type": "strong", "text": ["For Houdini native formats"]}, ", the following value should be a string specifying one of:"], "extent": [4205, 4298]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["\"point\""]}], "extent": [4298, 4313], "body": [{"type": "para", "indent": 8, "text": ["Point sampling (i.e. no filtering)"], "extent": [4313, 4356]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["\"box\""]}], "extent": [4356, 4369], "body": [{"type": "para", "indent": 8, "text": ["Box filter (default)"], "extent": [4369, 4398]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["\"gauss\""]}], "extent": [4398, 4413], "body": [{"type": "para", "indent": 8, "text": ["Gaussian filter"], "extent": [4413, 4437]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["\"bartlett\""]}], "extent": [4437, 4455], "body": [{"type": "para", "indent": 8, "text": ["Bartlett/Triangular filter"], "extent": [4455, 4490]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["\"sinc\""]}], "extent": [4490, 4504], "body": [{"type": "para", "indent": 8, "text": ["Sinc sharpening filter"], "extent": [4504, 4535]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["\"hanning\""]}], "extent": [4535, 4552], "body": [{"type": "para", "indent": 8, "text": ["Hanning filter"], "extent": [4552, 4575]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["\"blackman\""]}], "extent": [4575, 4593], "body": [{"type": "para", "indent": 8, "text": ["Blackman filter"], "extent": [4593, 4617]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["\"catrom\""]}], "extent": [4617, 4633], "body": [{"type": "para", "indent": 8, "text": ["Catmull-Rom filter"], "extent": [4633, 4661]}], "container": true}], "container": true}, {"type": "para", "indent": 4, "text": [{"type": "strong", "text": ["For all other formats (loaded by OpenImageIO)"]}, ", specifying the ", {"type": "code", "text": ["\"point\""]}, " filter sets the OIIO interpolation mode to ", {"type": "code", "text": ["\"closest\""]}, " and disables MIP mapping. Any other value uses OIIO smart-bicubic interpolation. You can get finer control using the ", {"type": "code", "text": ["\"filtermode\""]}, " variadic argument (see below)."], "extent": [4661, 4958]}], "container": true, "attrs": {"type": "string", "default": "\"box\""}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["xfilter"], "role": "item", "extent": [4958, 4973], "body": [{"type": "para", "indent": 4, "text": ["(AKA ", {"type": "code", "text": ["ufilter"]}, ", ", {"type": "code", "text": ["sfilter"]}, ")\n    Specifies the filter for the X direction. The filters are\n    the same as with ", {"type": "code", "text": ["filter"]}, "."], "extent": [4996, 5121]}], "container": true, "attrs": {"type": "string"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["yfilter"], "role": "item", "extent": [5121, 5136], "body": [{"type": "para", "indent": 4, "text": ["(AKA ", {"type": "code", "text": ["vfilter"]}, ", ", {"type": "code", "text": ["tfilter"]}, ")\n    Specifies the filter for the Y direction. The filters are\n    the same as with ", {"type": "code", "text": ["filter"]}, "."], "extent": [5159, 5284]}], "container": true, "attrs": {"type": "string"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["filtermode"], "role": "item", "extent": [5284, 5302], "body": [{"type": "para", "indent": 4, "text": [{"type": "strong", "text": ["For Houdini native formats"]}, ", VEX also supports simpler filtering.  The\n    ", {"type": "code", "text": ["filtermode"]}, " can be set to one of:"], "extent": [5321, 5437]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["filter"]}], "extent": [5437, 5451], "body": [{"type": "para", "indent": 11, "text": ["Use the filter specified by the ", {"type": "code", "text": ["filter"]}, " keyword argument."], "extent": [5451, 5521]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["bilinear"]}], "extent": [5521, 5537], "body": [{"type": "para", "indent": 11, "text": ["Use simple bilinear filtering.  This is the fastest specialized filtering mode, but provides the lowest quality filtering."], "extent": [5537, 5671]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["biquadratic"]}], "extent": [5671, 5690], "body": [{"type": "para", "indent": 11, "text": ["Use simple quadratic filtering (order 3 filtering)."], "extent": [5690, 5753]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["bicubic"]}], "extent": [5753, 5768], "body": [{"type": "para", "indent": 11, "text": ["Use simple bicubic filtering."], "extent": [5768, 5810]}], "container": true}], "container": true}, {"type": "para", "indent": 4, "text": ["When the ", {"type": "code", "text": ["filtermode"]}, " is set to ", {"type": "code", "text": ["bilinear"]}, ", ", {"type": "code", "text": ["biquadratic"]}, " or ", {"type": "code", "text": ["bicubic"]}, ",\n    several arguments (like ", {"type": "code", "text": ["filter"]}, " and ", {"type": "code", "text": ["width"]}, ") are ignored and a fixed\n    interpolation filter is used instead.  Other arguments (notably the ", {"type": "code", "text": ["lerp"]}, "\n    and ", {"type": "code", "text": ["blur"]}, " keywords) are still valid."], "extent": [5810, 6082]}, {"type": "para", "indent": 4, "text": [{"type": "strong", "text": ["For all other formats (loaded by OpenImageIO)"]}, " you can set the ", {"type": "code", "text": ["filtermode"]}, " to ", {"type": "code", "text": ["\"filter\""]}, " (see ", {"type": "code", "text": ["\"filter\""]}, " above), ", {"type": "code", "text": ["\"bilinear\""]}, ", ", {"type": "code", "text": ["\"biquadratic\""]}, ", or ", {"type": "code", "text": ["\"bicubic\""]}, "."], "extent": [6082, 6249]}], "container": true, "attrs": {"type": "string"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["width"], "role": "item", "extent": [6249, 6262], "body": [{"type": "para", "indent": 4, "text": [{"type": "strong", "text": ["For Houdini native formats"]}, ", this sets the filter width in both X and Y directions."], "extent": [6302, 6392]}, {"type": "para", "indent": 4, "text": [{"type": "strong", "text": ["For all other formats (loaded by OpenImageIO)"]}, ", this sets the OIIO ", {"type": "code", "text": ["swidth"]}, " and ", {"type": "code", "text": ["twidth"]}, " options."], "extent": [6392, 6496]}], "container": true, "attrs": {"type": "float", "default": "1.0"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["xwidth"], "role": "item", "extent": [6496, 6510], "body": [{"type": "para", "indent": 4, "text": ["(AKA ", {"type": "code", "text": ["uwidth"]}, ", ", {"type": "code", "text": ["swidth"]}, ")\n    Filter width in the X direction."], "extent": [6532, 6599]}], "container": true, "attrs": {"type": "float"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["ywidth"], "role": "item", "extent": [6599, 6613], "body": [{"type": "para", "indent": 4, "text": ["(AKA ", {"type": "code", "text": ["vwidth"]}, ", ", {"type": "code", "text": ["twidth"]}, ")\n    Filter width in the Y direction."], "extent": [6635, 6702]}], "container": true, "attrs": {"type": "float"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["zwidth"], "role": "item", "extent": [6702, 6716], "body": [{"type": "para", "indent": 4, "text": ["Filter width in the Z direction (for shadow maps).\n    This is measured in world space units, unlike the other width arguments."], "extent": [6738, 6871]}], "container": true, "attrs": {"type": "float"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["extrapolate"], "role": "item", "extent": [6871, 6890], "body": [{"type": "para", "indent": 4, "text": ["whether to use derivative extrapolation\n    when computing anti-aliasing information. Extrapolation of\n    derivatives is on by default. The argument should be either 0 or\n    1."], "extent": [6910, 7094]}], "container": true, "attrs": {"type": "int"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["lerp"], "role": "item", "extent": [7094, 7106], "body": [{"type": "para", "indent": 4, "text": [{"type": "strong", "text": ["For Houdini native formats"]}, ", this specifies whether RAT files should interpolate between different MIP levels. By default, this is turned off. Turning interpolation on will help remove discontinuities when different\n    MIP levels of a ", {"type": "code", "text": [".rat"]}, " file are accessed. However, the results of texture evaluation will be slightly softer (i.e. blurrier) and will take more time."], "extent": [7122, 7498]}, {"type": "para", "indent": 4, "text": ["There are three possible values for this argument."], "extent": [7498, 7558]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["0"]}], "extent": [7558, 7567], "body": [{"type": "para", "indent": 8, "text": ["Disable MIP map interpolation (fastest)."], "extent": [7567, 7616]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["1"]}], "extent": [7616, 7625], "body": [{"type": "para", "indent": 8, "text": ["Approximate MIP map interpolation (fast)."], "extent": [7625, 7675]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["2"]}], "extent": [7675, 7684], "body": [{"type": "para", "indent": 8, "text": ["High Quality MIP map interpolation (slower but highest quality)."], "extent": [7684, 7758]}], "container": true}], "container": true}, {"type": "para", "indent": 4, "text": [{"type": "strong", "text": ["For all other formats (loaded by OpenImageIO)"]}, ", a value of 0 specifies a single MIP level, any other value specifies trilinear interpolation."], "extent": [7758, 7906]}], "container": true, "attrs": {"type": "int"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["depthinterp"], "role": "item", "extent": [7906, 7925], "body": [{"type": "para", "indent": 4, "text": ["Specifies the depth interpolation mode for deep shadow maps,\n    to control the opacity value that will be returned when the\n    map is sampled between two z-records."], "extent": [7944, 8120]}, {"type": "para", "indent": 4, "text": ["The argument must be a string."], "extent": [8120, 8156]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["discrete"]}, " "], "extent": [8156, 8173], "body": [{"type": "para", "indent": 8, "text": ["(default) Return the first z-record before the sample\n        point."], "extent": [8173, 8250]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["linear"]}, " "], "extent": [8250, 8265], "body": [{"type": "para", "indent": 8, "text": ["Linearly interpolate the opacities of the z-records\n        before and after the sample point."], "extent": [8265, 8377]}], "container": true}], "container": true}, {"type": "para", "indent": 4, "text": ["See ", {"scheme": null, "value": "/render/lights", "type": "link", "text": ["deep shadow maps"], "fullpath": "/render/lights"}, " for more on\n    the difference between the two modes."], "extent": [8377, 8474]}], "container": true, "attrs": {"type": "string"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["beerlambert"], "role": "item", "extent": [8474, 8493], "body": [{"type": "para", "indent": 4, "text": ["When evaluating volumetric deep shadow maps, this will enable Beer-Lambert\n    interpolation of opacity.  Beer-Lambert is more a accurate but more\n    expensive form of interpolation."], "extent": [8513, 8702]}, {"type": "para", "indent": 4, "text": ["The argument should be either 0 or 1."], "extent": [8702, 8745]}], "container": true, "attrs": {"type": "int"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["srccolorspace"], "role": "item", "extent": [8745, 8766], "body": [{"type": "para", "indent": 4, "text": ["Specifies the color space in which the texture is stored.\n    When texture values are accessed, they will be translated from\n    this space into linear space for rendering if needed."], "extent": [8789, 8977]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["auto"]}, " "], "extent": [8977, 8990], "body": [{"type": "para", "indent": 8, "text": ["(default) Determine the source color space based on the\n        file.  Currently, this will assume sRGB color space for\n        8-bit textures and linear for all other textures."], "extent": [8990, 9176]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["linear"]}, " "], "extent": [9176, 9191], "body": [{"type": "para", "indent": 8, "text": ["Transform to linear space.  This currently only affects\n        8-bit textures, since all others are assumed to be already\n        in linear space.  Use this option to force linear\n        interpretation of textures used for bump or displacement\n        maps."], "extent": [9191, 9460]}], "container": true}], "container": true}], "container": true, "attrs": {"type": "string"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["face"], "role": "item", "extent": [9460, 9472], "body": [{"type": "para", "indent": 4, "text": ["When using a Ptex texture map, the ", {"type": "code", "text": ["face"]}, " argument is used to specify the face for ptexture lookup.\n    ", {"type": "strong", "text": ["Has no effect for OpenImageIO formats"]}, "."], "extent": [9472, 9622]}], "container": true, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["ptexorient"], "role": "item", "extent": [9622, 9640], "body": [{"type": "para", "indent": 4, "text": ["When using Ptex textures, the implicit texture coordinates on\n    polygons are used as the interpolants for texture lookup (combined\n    with the ", {"type": "code", "text": ["face"]}, ").  However, different software may have different\n    beliefs about winding and orientation.  This keyword argument\n    allows you to control the interpretation of orientation for Houdini\n    polygons.  The ", {"type": "code", "text": ["ptexorient"]}, " expects an integer argument which is\n    composed of a bit-field"], "extent": [9660, 10103]}, {"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["bit 0\u00d701: Complement the ", {"type": "code", "text": ["s"]}, " coordinate"], "extent": [10103, 10149]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["bit 0\u00d702: Complement the ", {"type": "code", "text": ["t"]}, " coordinate"], "extent": [10149, 10195]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["bit 0\u00d704: Swap the ", {"type": "code", "text": ["s"]}, " and ", {"type": "code", "text": ["t"]}, " coordinates"], "extent": [10195, 10245]}], "container": true}, {"type": "para", "indent": 4, "text": ["For example, a value of 6 (0\u00d74|0\u00d72) is equivalent to calling\n    ", {"type": "code", "text": ["texture(map, 1-t, s)"]}, " instead of ", {"type": "code", "text": ["texture(map, s, t)"]}, "."], "extent": [10245, 10371]}, {"type": "para", "indent": 4, "text": ["The default ", {"type": "code", "text": ["ptexorient"]}, " is 0, which works correctly with the\n    examples found at ", {"scheme": null, "value": "http://ptex.us", "type": "link", "text": "", "exists": true}, "."], "extent": [10371, 10478]}, {"type": "para", "indent": 4, "text": [{"type": "strong", "text": ["Has no effect for OpenImageIO formats"]}, "."], "extent": [10478, 10524]}], "container": true, "attrs": {"type": "int"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["iesnormalization"], "role": "item", "extent": [10524, 10548], "body": [{"type": "para", "indent": 4, "text": ["Select different methods of normalizing IES map\u2019s output values when\n    querying via ", {"type": "code", "text": ["environment()"]}, " function."], "extent": [10592, 10709]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["none"]}, " "], "extent": [10709, 10722], "body": [{"type": "para", "indent": 8, "text": ["Use raw values scaled by the candela multiplier in the header."], "extent": [10722, 10793]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["maxvalue"]}, " "], "extent": [10793, 10810], "body": [{"type": "para", "indent": 8, "text": ["(default) Normalized by the maximum value. This is legacy behavior used\n        by mantra\u2019s default light shader."], "extent": [10810, 10932]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["preserveenergy"]}, " "], "extent": [10932, 10955], "body": [{"type": "para", "indent": 8, "text": ["Normalized by values integrated over coverage angles, so that IES\n        profile affects shaping of the light while preserving its overall\n        energy output."], "extent": [10955, 11126]}], "container": true}], "container": true}], "container": true, "attrs": {"type": "string", "default": "\"maxvalue\""}, "variadic": true}], "container": true, "role": "item_group"}]}]}