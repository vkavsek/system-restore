{"type": "root", "attrs": {"type": "vex", "context": "all", "tags": "shading", "group": "shading", "showtags": "true"}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["area"], "extent": [0, 9]}, {"type": "summary", "indent": 0, "text": ["Returns the area of the micropolygon containing a variable such as P."], "extent": [67, 144]}, {"type": "usage_group", "body": [{"ext": null, "type": "usage", "indent": 0, "text": [" ", {"type": "code", "text": ["float area(vector p, ...)"]}], "role": "item", "extent": [144, 181]}], "container": true, "role": "item_group"}, {"type": "para", "indent": 0, "text": ["This is a more accurate and convenient method to get the micropolygon area\nthan multiplying the length of ", {"type": "code", "text": ["Du(P)"]}, " by the length of ", {"type": "code", "text": ["Dv(P)"]}, ".\nThis function is typically used to get the shading area in pixels."], "extent": [181, 389]}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [389, 395], "body": [{"type": "para", "indent": 4, "text": ["This function works because VEX ", {"type": "q", "text": ["knows"]}, " that the variable ", {"type": "code", "text": ["P"]}, "\n    has derivatives (", {"type": "code", "text": ["dPdu"]}, " and ", {"type": "code", "text": ["dPdv"]}, "). Passing a literal vector\n    instead of a special variables such as ", {"type": "code", "text": ["P"]}, " will return ", {"type": "code", "text": ["0"]}, " since\n    VEX will not be able to access the derivatives."], "extent": [395, 649]}], "container": true}], "container": true, "role": "item_group"}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Derivatives options"], "extent": [16, 42], "body": [{"type": "para", "indent": 0, "text": ["Functions which compute derivatives take additional arguments to\nallow tuning of the derivative computation."], "extent": [42, 153]}, {"type": "arg_group", "body": [{"ext": null, "type": "arg", "indent": 0, "text": {"type": "code", "text": ["extrapolate"]}, "role": "item", "extent": [153, 172], "body": [{"type": "para", "indent": 4, "text": ["Whether derivatives are\n    ", {"type": "q", "text": ["smooth"]}, " across patch boundaries. In most cases this is true and if\n    extrapolation is turned on, derivative computation should be exact\n    for C2 surfaces. However, when the VEX variables are changing with a\n    high frequency (for example, a high frequency displacement map\n    causing high frequency changes to the P variable), extrapolation of\n    derivative computation may cause exaggeration of discontinuities\n    between patch boundaries."], "extent": [208, 695]}], "container": true, "attrs": {"type": "int", "default": "0"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": {"type": "code", "text": ["smooth"]}, "role": "item", "extent": [695, 709], "body": [{"type": "para", "indent": 4, "text": ["Adjust the magnitude of the\n    differentials non-uniformly over patches. This will usually reduce\n    patch discontinuities in displacement/textured shaders. However, in\n    some odd cases you may want to turn this feature off."], "extent": [745, 979]}], "container": true, "attrs": {"type": "int", "default": "1"}, "variadic": true}], "container": true, "role": "item_group"}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\nN = computenormal(P, \"extrapolate\", 1, \"smooth\", 0);\n"], "extent": [979, 1046]}]}, {"level": 1, "id": "examples", "container": true, "type": "examples_section", "indent": 0, "role": "section", "extent": [678, 688], "body": [{"type": "para", "indent": 0, "text": ["Return the area of the current micro-polygon in camera space:"], "extent": [688, 752]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\narea(P)\n"], "extent": [752, 774]}, {"type": "para", "indent": 0, "text": ["Return the area of the current micro-polygon in NDC space:"], "extent": [774, 835]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\narea(transform(\"ndc\", P))\n"], "extent": [835, 875]}, {"type": "para", "indent": 0, "text": ["Returns ", {"type": "code", "text": ["0"]}, ", since the argument is not a variable VEX knows the derivatives for:"], "extent": [875, 958]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\narea({0.1, 2.3, 4.5})\n"], "extent": [958, 994]}], "text": "Examples"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [994, 1004], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Vex", "value": "/vex/functions/volume", "type": "link", "text": "", "fallback_text": "volume()", "fullpath": "/vex/functions/volume"}], "extent": [1004, 1020]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Vex", "value": "/vex/functions/Du", "type": "link", "text": "", "fallback_text": "Du()", "fullpath": "/vex/functions/Du"}], "extent": [1020, 1031]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Vex", "value": "/vex/functions/Dv", "type": "link", "text": "", "fallback_text": "Dv()", "fullpath": "/vex/functions/Dv"}], "extent": [1031, 1042]}], "container": true}], "text": "Related"}], "title": ["area"], "summary": ["Returns the area of the micropolygon containing a variable such as P."], "included": ["/vex/functions/_derive_variadic"]}