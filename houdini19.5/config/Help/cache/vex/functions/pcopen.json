{"type": "root", "attrs": {"type": "vex", "context": "all", "tags": "ptcloud, file", "group": "ptcloud", "showtags": "true"}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["pcopen"], "extent": [0, 11]}, {"type": "summary", "indent": 0, "text": ["Returns a handle to a point cloud file."], "extent": [75, 122]}, {"type": "usage_group", "body": [{"ext": null, "type": "usage", "indent": 0, "text": [" ", {"type": "code", "text": ["int pcopen(string filename, string channel, int shaded, ...)"]}], "role": "item", "extent": [122, 193]}, {"ext": null, "type": "usage", "indent": 0, "text": [" ", {"type": "code", "text": ["int pcopen(string filename, string Pchannel, vector P, float radius, int maxpoints, ...)"]}], "role": "item", "extent": [193, 292]}, {"ext": null, "type": "usage", "indent": 0, "text": [" ", {"type": "code", "text": ["int pcopen(string filename, string Pchannel, vector P, string Nchannel, vector N, float radius, int maxpoints, ...)"]}], "role": "item", "extent": [292, 419]}, {"ext": null, "type": "usage", "indent": 0, "text": [" ", {"type": "code", "text": ["int pcopen(int opinput, string Pchannel, vector P, float radius, int maxpoints)"]}], "role": "item", "extent": [419, 510]}], "container": true, "role": "item_group"}, {"type": "para", "indent": 0, "text": ["This function opens a point cloud file (", {"type": "code", "text": [".pc"]}, ") and queues up access to the\npoints contained in it.  You can then iterate over the points with\n", {"scheme": "Vex", "value": "/vex/functions/pcunshaded", "type": "link", "text": "", "fallback_text": "pcunshaded()", "fullpath": "/vex/functions/pcunshaded"}, " or ", {"scheme": "Vex", "value": "/vex/functions/pciterate", "type": "link", "text": "", "fallback_text": "pciterate()", "fullpath": "/vex/functions/pciterate"}, "."], "extent": [510, 690]}, {"type": "para", "indent": 0, "text": ["The first two versions of this function queue up points centered around a\ncertain location ", {"type": "var", "text": ["P"]}, " within ", {"type": "var", "text": ["radius"]}, ", based on point positions found in\n", {"type": "var", "text": ["Pchannel"]}, ".  Only the ", {"type": "var", "text": ["maxpoints"]}, " closest points within the given\nradius will be queued.  When using ", {"type": "code", "text": ["pcopen()"]}, " with ", {"type": "code", "text": ["pciterate()"]}, ", points will\nbe sorted from nearest to farthest.  The file name may use the ", {"type": "code", "text": ["op:"]}, " syntax\nto reference SOP geometry in the OP contexts.  The ", {"type": "var", "text": ["Pchannel"]}, " parameter\nindicates the channel in the texture which contains the positions to be\nsearched. ", {"type": "var", "text": ["Pchannel"]}, " will be made read-only if it is not already. Any\nsubsequent attempts to use the channel with ", {"scheme": "Vex", "value": "/vex/functions/pcexport", "type": "link", "text": "", "fallback_text": "pcexport()", "fullpath": "/vex/functions/pcexport"}, " or\n", {"scheme": "Vex", "value": "/vex/functions/pcunshaded", "type": "link", "text": "", "fallback_text": "pcunshaded()", "fullpath": "/vex/functions/pcunshaded"}, " will fail.  Optionally, the ", {"type": "var", "text": ["Nchannel"]}, " specifies a\ndirection channel and the ", {"type": "var", "text": ["N"]}, " vector specifies a search direction. Only\npoints which are pointed in the same direction (i.e. ", {"type": "code", "text": ["dot(N, Npoint) > 0"]}, ")\nwill be queued."], "extent": [690, 1580]}, {"type": "para", "indent": 0, "text": ["In some cases, you may need to add additional channels to a point cloud.  You can do this by using ", {"scheme": "Vex", "value": "/vex/functions/pcexport", "type": "link", "text": "", "fallback_text": "pcexport()", "fullpath": "/vex/functions/pcexport"}, " and ", {"scheme": "Vex", "value": "/vex/functions/pcunshaded", "type": "link", "text": "", "fallback_text": "pcunshaded()", "fullpath": "/vex/functions/pcunshaded"}, ".  Often,\nyou will not need to add extra channel data to every point in the point cloud. For example, if only part of the point cloud is inside the camera\u2019s frustum.\nIn these cases, it is best to only add channel data to points returned by\na proximity query.  However, sometimes all points in a point cloud must\nreceive extra channel data before meaningful queries can be made. For example, when adding a position channel.  In these cases, the third version of this function can be used to queue up all shaded (", {"type": "var", "text": ["shaded"]}, " != 0) or unshaded (", {"type": "var", "text": ["shaded"]}, " == 0) points of a certain channel, ", {"type": "var", "text": ["channel"]}, ".  If ", {"type": "var", "text": ["channel"]}, " does not exist, all points will be queued.  This function, unlike the first two, does not lock ", {"type": "var", "text": ["channel"]}, "."], "extent": [1580, 2439]}, {"type": "para", "indent": 0, "text": ["You can specify an additional string parameter ", {"type": "code", "text": ["\"prefix\""]}, ", with the next\nparameter being a channel prefix string, used to reference tiled block\nfiles."], "extent": [2439, 2591]}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [2591, 2597], "body": [{"type": "para", "indent": 4, "text": ["The preload option loads the entire point cloud into memory. Disabling this option will cause it to use a tile cache."], "extent": [2597, 2721]}], "container": true}], "container": true, "role": "item_group"}, {"level": 1, "id": "examples", "container": true, "type": "examples_section", "indent": 0, "role": "section", "extent": [2721, 2731], "body": [{"type": "box_group", "body": [{"ext": null, "type": "box", "indent": 0, "text": ["Performing a proximity query"], "role": "item", "extent": [2731, 2766], "body": [{"lang": "vex", "type": "pre", "indent": 4, "text": ["\n    int handle = pcopen(texturename, \"P\", P, maxdistance, maxpoints);\n    while (pcunshaded(handle, \"irradiance\"))\n    {\n        pcimport(handle, \"P\", cloudP);\n        pcimport(handle, \"N\", cloudN);\n        ir = computeIrraciance(cloudP, cloudN);\n        pcexport(handle, \"irradiance\", ir);\n    }\n    pcfilter(handle, radius, \"irradiance\", ir);\n    "], "extent": [2766, 3137]}], "container": true}, {"ext": null, "type": "box", "indent": 0, "text": ["Shading an entire channel"], "role": "item", "extent": [3137, 3169], "body": [{"lang": "vex", "type": "pre", "indent": 4, "text": ["\n    vector sample;\n    int rval, handle;\n\n    handle = pcopen(texturename, \"P\", 0);\n    while (pcunshaded(handle, \"P\"))\n    {\n        sample = set(nrandom(\"qstrat\"), nrandom(\"qstrat\"), 0.0);\n        rval = sample_geometry(\n            sample, sample, Time,\n            \"scope\", getobjectname(),\n            \"pipeline\", \"displacement\",\n            \"P\", pos);\n        if (rval)\n            rval = pcexport(handle, \"P\", pos);\n    }\n    pcclose(handle);\n    "], "extent": [3169, 3645]}], "container": true}, {"ext": null, "type": "box", "indent": 0, "text": ["Controlling the minimum dot product between the point normal and the normal passed to ", {"type": "code", "text": ["pcopen()"]}, " for points to be filtered"], "role": "item", "extent": [3645, 3776], "body": [{"lang": "vex", "type": "pre", "indent": 4, "text": ["\n    // This will only return points where dot(N, Npoint) > 0.8\n    int handle = pcopen(\"test.pc\", \"P\", P, \"N\", N, 1e6, 100, \"ndot\", 0.8);\n    "], "extent": [3776, 3940]}], "container": true}], "container": true, "role": "item_group"}], "text": "Examples"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [3940, 3957], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Vex", "value": "/vex/functions/pcgenerate", "type": "link", "text": "", "fallback_text": "pcgenerate()", "fullpath": "/vex/functions/pcgenerate"}], "extent": [3957, 3977]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Vex", "value": "/vex/functions/pcwrite", "type": "link", "text": "", "fallback_text": "pcwrite()", "fullpath": "/vex/functions/pcwrite"}], "extent": [3977, 3993]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Vex", "value": "/vex/functions/pcfilter", "type": "link", "text": "", "fallback_text": "pcfilter()", "fullpath": "/vex/functions/pcfilter"}], "extent": [3993, 4010]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Vex", "value": "/vex/functions/pciterate", "type": "link", "text": "", "fallback_text": "pciterate()", "fullpath": "/vex/functions/pciterate"}], "extent": [4010, 4028]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Vex", "value": "/vex/functions/pcunshaded", "type": "link", "text": "", "fallback_text": "pcunshaded()", "fullpath": "/vex/functions/pcunshaded"}], "extent": [4028, 4047]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Vex", "value": "/vex/functions/pcimport", "type": "link", "text": "", "fallback_text": "pcimport()", "fullpath": "/vex/functions/pcimport"}], "extent": [4047, 4064]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Vex", "value": "/vex/functions/pcclose", "type": "link", "text": "", "fallback_text": "pcclose()", "fullpath": "/vex/functions/pcclose"}], "extent": [4064, 4081]}], "container": true}], "text": "Related"}], "title": ["pcopen"], "summary": ["Returns a handle to a point cloud file."]}