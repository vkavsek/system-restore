{"type": "root", "attrs": {"type": "vex", "context": "all", "tags": "prim, search, intersect", "group": "geo", "showtags": "true"}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["primfind"], "extent": [0, 13]}, {"type": "summary", "indent": 0, "text": ["Returns a list of primitives potentially intersecting a given bounding box."], "extent": [83, 166]}, {"type": "usage_group", "body": [{"ext": null, "type": "usage", "indent": 0, "text": [" ", {"type": "code", "text": ["int[] primfind(<geometry>, vector min, vector max)"]}], "role": "item", "extent": [166, 228], "body": [{"type": "para", "indent": 4, "text": ["Find all the primitives whose bounding boxes overlap the given box."], "extent": [228, 301]}], "container": true}, {"ext": null, "type": "usage", "indent": 0, "text": [" ", {"type": "code", "text": ["int[] primfind(<geometry>, string group, vector min, vector max)"]}], "role": "item", "extent": [301, 377], "body": [{"type": "para", "indent": 4, "text": ["Find all primitives in a group whose bounding boxes overlap the given box."], "extent": [377, 457]}], "container": true}], "container": true, "role": "item_group"}, {"type": "arg_group", "body": [{"ext": null, "type": "arg", "indent": 0, "text": [{"type": "code", "text": ["<geometry>"]}], "role": "item", "extent": [16, 35], "body": [{"type": "para", "indent": 4, "text": ["When running in the context of a node (such as a wrangle SOP), this argument can be an integer representing the input number (starting at 0) to read the geometry from."], "extent": [58, 235]}, {"type": "para", "indent": 4, "text": ["Alternatively, the argument can be a string specifying a geometry file (for example, a ", {"type": "code", "text": [".bgeo"]}, ") to read from. When running inside Houdini, this can be an ", {"type": "code", "text": ["op:/path/to/sop"]}, " reference."], "extent": [235, 423]}], "container": true, "attrs": {"id": "geometry"}}, {"ext": null, "type": "arg", "indent": 0, "text": [{"type": "code", "text": ["min"]}, ", ", {"type": "code", "text": ["max"]}], "role": "item", "extent": [485, 504], "body": [{"type": "para", "indent": 4, "text": ["These vectors define the minimum and maximum corners of the bounding box to search."], "extent": [504, 593]}], "container": true}, {"ext": null, "type": "arg", "indent": 0, "text": [{"type": "code", "text": ["group"]}], "role": "item", "extent": [593, 607], "body": [{"type": "para", "indent": 4, "text": ["If given, only match primitives in this group.\n    An empty group string will include all primitives.\n    The string supports Ad-hoc patterns like ", {"type": "code", "text": ["0-10"]}, " and ", {"type": "code", "text": ["@Cd.x>0"]}, "."], "extent": [607, 781]}], "container": true}, {"ext": null, "type": "arg", "indent": 0, "role": "item", "extent": [781, 791], "body": [{"type": "para", "indent": 4, "text": ["An array of primitive numbers."], "extent": [791, 827]}], "container": true, "returns": true}], "container": true, "role": "item_group"}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [827, 833], "body": [{"type": "para", "indent": 4, "text": ["These functions are intended to be used as an optimization to finding primitives\n    in a particular area for processing.  For instance, to find all the curves\n    from one input intersecting polygons on another input, we may naively iterate\n    over all polygons for each curve to determine their intersection.  To speed this\n    process, we may find which primitives may intersect a particular curve using\n    these functions, and iterate solely over the potentially intersecting\n    primitives.  This significantly improves performance since ", {"type": "code", "text": ["primfind"]}, " uses an\n    underlying tree structure to speed up search."], "extent": [833, 1453]}], "container": true}], "container": true, "role": "item_group"}, {"level": 1, "id": "examples", "container": true, "type": "examples_section", "indent": 0, "role": "section", "extent": [1453, 1463], "body": [{"type": "para", "indent": 0, "text": ["Remove primitives that may be intersecting the unit box centered at the origin:"], "extent": [1463, 1545]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\nint[] prims = primfind(geometry, {-0.5, -0.5, -0.5}, {0.5, 0.5, 0.5});\nforeach ( int prim; prims )\n{\n    removeprim(\"primitives.bgeo\", prim, 1);\n}\n"], "extent": [1545, 1706]}, {"type": "para", "indent": 0, "text": ["Alternatively, we can use a query bounding box from an auxiliary source:"], "extent": [1706, 1781]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\nvector min, max;\ngetbbox(\"bbox.bgeo\", min, max);\nint[] prims = primfind(geometry, min, max);\nforeach ( int prim; prims )\n{\n    removeprim(\"primitives.bgeo\", prim, 1);\n}\n"], "extent": [1781, 1964]}, {"type": "para", "indent": 0, "text": ["To see the performance benefit of ", {"type": "code", "text": ["primfind"]}, ", compare it to the following equivalent\nimplementation of the function above:"], "extent": [1964, 2089]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\nfloat tol = 1e-5;\nvector min, max;\ngetbbox(\"bbox.bgeo\",min,max);\nint n = nprimitives(0);\nfor ( int prim = 0; prim < n; ++prim )\n{\n    int[] verts = primvertices(\"primitives.bgeo\", prim);\n    \n    // compute primitive bounding box and store it in prim_min and prim_max\n    vector vert_pos = point(\"primitives.bgeo\", \"P\", vertexpoint(\"primitives.bgeo\", verts[0]));\n    vector prim_min = vert_pos, prim_max = vert_pos;\n    for ( int v = 1; v < len(verts); ++v )\n    {\n        vert_pos = point(\"primitives.bgeo\", \"P\", vertexpoint(\"primitives.bgeo\", verts[v]));\n        prim_min = min(prim_min, vert_pos);\n        prim_max = max(prim_max, vert_pos);\n    }\n    \n    // bounding box intersection test\n    if ( prim_max.x - min.x < -tol ) continue;\n    if ( prim_max.y - min.y < -tol ) continue;\n    if ( prim_max.z - min.z < -tol ) continue;\n    if ( prim_min.x - max.x > tol ) continue;\n    if ( prim_min.y - max.y > tol ) continue;\n    if ( prim_min.z - max.z > tol ) continue;\n    removeprim(\"primitives.bgeo\", prim, 1);\n}\n"], "extent": [2089, 3122]}], "text": "Examples"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [3122, 3133], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Vex", "value": "/vex/functions/getbbox", "type": "link", "text": "", "fallback_text": "getbbox()", "fullpath": "/vex/functions/getbbox"}], "extent": [3133, 3150]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Vex", "value": "/vex/functions/pcfind", "type": "link", "text": "", "fallback_text": "pcfind()", "fullpath": "/vex/functions/pcfind"}], "extent": [3150, 3165]}], "container": true}], "text": "Related"}], "title": ["primfind"], "summary": ["Returns a list of primitives potentially intersecting a given bounding box."], "included": ["/vex/functions/_common"]}