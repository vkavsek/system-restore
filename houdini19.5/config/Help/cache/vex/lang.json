{"type": "root", "attrs": {}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["VEX language reference"], "extent": [0, 27]}, {"type": "summary", "indent": 0, "text": ["Details of VEX syntax, data types, and so on."], "extent": [27, 81]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Contexts"], "extent": [81, 96], "body": [{"type": "para", "indent": 0, "text": ["VEX programs are written for a specific ", {"type": "em", "text": ["context"]}, ". For example, a shader that \ncontrols the surface color of an object is written for the ", {"type": "code", "text": ["surface"]}, " context. \nA shader that determines the illuminance from a light is written for the \n", {"type": "code", "text": ["light"]}, " context. A VEX program that creates or filters channel data is \nwritten for the ", {"type": "code", "text": ["chop"]}, " context."], "extent": [96, 434]}, {"type": "para", "indent": 0, "text": ["The context affects which functions, statements, and global variables are \navailable."], "extent": [434, 521]}, {"type": "para", "indent": 0, "text": ["See ", {"scheme": null, "value": "contexts/", "type": "link", "text": ["VEX contexts"], "fullpath": "/vex/contexts/index"}, "  for an overview of the ways in which\nyou can use VEX."], "extent": [521, 606]}, {"type": "para", "indent": 0, "text": ["If you are writing for a shading context (surface, displacement, light, etc.), \nyou should also read the ", {"scheme": null, "value": "/vex/contexts/shading_contexts", "type": "link", "text": ["shading context specific information"], "fullpath": "/vex/contexts/shading_contexts"}, "."], "extent": [606, 784]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Statements"], "extent": [784, 801], "body": [{"type": "para", "indent": 0, "text": ["VEX supports the usual ", {"scheme": null, "value": "statement", "type": "link", "text": ["statements"], "fullpath": "/vex/statement"}, " familiar from C. It also supports \nshading-specific statements such as the ", {"scheme": "Vex", "value": "/vex/functions/illuminance", "type": "link", "text": "", "fallback_text": "illuminance()", "fullpath": "/vex/functions/illuminance"}, " and ", {"scheme": "Vex", "value": "/vex/functions/gather", "type": "link", "text": "", "fallback_text": "gather()", "fullpath": "/vex/functions/gather"}, " loops \nthat are only available in certain contexts."], "extent": [801, 1012]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Built-in functions"], "extent": [1012, 1037], "body": [{"type": "para", "indent": 0, "text": ["VEX contains a large library of ", {"scheme": null, "value": "functions/", "type": "link", "text": ["built-in functions"], "fullpath": "/vex/functions/index"}, ". Some functions \nare only available in certain contexts."], "extent": [1037, 1160]}, {"type": "para", "indent": 0, "text": ["See ", {"scheme": null, "value": "functions/", "type": "link", "text": ["VEX functions"], "fullpath": "/vex/functions/index"}, "."], "extent": [1160, 1194]}]}, {"level": 2, "id": "functions", "container": true, "type": "h", "indent": 0, "text": ["User-defined functions"], "extent": [1194, 1235], "body": [{"type": "para", "indent": 0, "text": ["Functions are defined similarly to C: specify the return type, \nthe function name, and parenthesized list of arguments, followed by \nthe code block."], "extent": [1235, 1386]}, {"type": "para", "indent": 0, "text": ["Arguments of the same type can be declared in a comma separated list without \nre-declaring the type. Other arguments must be separated by a semi-colon."], "extent": [1386, 1539]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\nint test(int a, b; string c) {\n    if (a > b) {\n        printf(c);\n    }\n}\n"], "extent": [1539, 1628]}, {"type": "para", "indent": 0, "text": ["You can ", {"type": "em", "text": ["overload"]}, " functions with the same name but different argument \nsignatures ", {"type": "em", "text": ["and/or return type"]}, "."], "extent": [1628, 1735]}, {"type": "para", "indent": 0, "text": ["You can introduce a function definition with the optional ", {"type": "code", "text": ["function"]}, " keyword to avoid type ambiguity."], "extent": [1735, 1838]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\nfunction int test(int a, b; string c) {\n    if (a > b) {\n        printf(c);\n    }\n}\n"], "extent": [1838, 1936]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n\nvoid print(basis b) { \n    printf(\"basis: { i: %s, j: %s, k: %s }\\n\", b.i, b.j, b.k); \n} \nvoid print(matrix m) { \n    printf(\"matrix: %s\\n\", m); \n} \nvoid print(bases b) { \n    printf(\"bases <%s> {\\n\", b.description); \n    printf(\"  \"); print(b.m); \n    printf(\"  \"); print(b.n); \n    printf(\"  \"); print(b.o); \n    printf(\"}\\n\"); \n} \n\nbasis rotate(basis b; vector axis; float amount) { \n    matrix m = 1; \n    rotate(m, amount, axis); \n    basis result = b; \n    result.i *= m; \n    result.j *= m; \n    result.k *= m; \n    return result; \n} \nvoid rotate(basis b; vector axis; float amount) { \n    b = rotate(b, axis, amount); \n} \n"], "extent": [1936, 2582]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Notes"], "extent": [2582, 2598], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["User functions must be declared before they are referenced."], "extent": [2598, 2662]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["The functions are in-lined automatically by the ", {"scheme": null, "value": "vcc", "type": "link", "text": ["compiler"], "fullpath": "/vex/vcc"}, ", so \n  ", {"type": "strong", "text": ["recursion will not work"]}, ". To write a recursive algorithm, you should use \n  ", {"scheme": null, "value": "shadercalls", "type": "link", "text": ["shader calls"], "fullpath": "/vex/shadercalls"}, " instead."], "extent": [2662, 2848]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["As in RenderMan Shading Language, parameters to user functions are always \n  passed ", {"type": "strong", "text": ["by reference"]}, ", so modifications in a user function affect the variable \n  the function was called with. You can force a shader parameter to be read-only \n  by prefixing it with the ", {"type": "code", "text": ["const"]}, " keyword. To ensure that the user function \n  writes to an output parameter, prefix it with the ", {"type": "code", "text": ["export"]}, " keyword."], "extent": [2848, 3238]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["There is no limit on the number of user functions."], "extent": [3238, 3292]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You can have more than one return statement in a function."], "extent": [3292, 3354]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You can access global variables directly (unlike RenderMan Shading\n  Language, you do not need to declare them with ", {"type": "code", "text": ["extern"]}, "). However, we \n  recommend you avoid accessing global variables, since this limits your \n  function to only work in one context (where those globals exist). \n  Instead, pass the global(s) to the function as parameters."], "extent": [3354, 3701]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Functions can be defined inside of a function (nested functions)."], "extent": [3701, 3771]}], "container": true}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Main (context) function"], "extent": [3771, 3801], "body": [{"type": "para", "indent": 0, "text": ["A VEX program must contain one function whose return type is the name of \nthe context. This is the main function of the program that is called by mantra. \nThe compiler expects one context function per file."], "extent": [3801, 4010]}, {"type": "para", "indent": 0, "text": ["This function should do the work (by calling out to built-in and/or \nuser-defined functions) of calculating any required information and modifying \nglobal variables. You do not use the ", {"type": "code", "text": ["return"]}, " statement to return a value from \nthe context function. See the specific ", {"scheme": null, "value": "contexts/", "type": "link", "text": ["context"], "fullpath": "/vex/contexts/index"}, " pages for the global \nvariables available in each context."], "extent": [4010, 4357]}, {"type": "para", "indent": 0, "text": ["The arguments to the context function, if any, become the user interface for \nthe program, for example the parameters of a shading node that references \nthe VEX program."], "extent": [4357, 4528]}, {"type": "para", "indent": 0, "text": ["If a geometry attribute exists with the same name as a parameter of the context \nfunction, the attribute overrides the parameter\u2019s value. This lets you paint \nattributes onto geometry to control VEX code."], "extent": [4528, 4734]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\nsurface\nnoise_surf(vector clr = {1,1,1}; float frequency = 1;\n           export vector nml = {0,0,0})\n{\n    Cf = clr * (float(noise(frequency * P)) + 0.5) * diffuse(normalize(N));\n    nml = normalize(N)*0.5 + 0.5;\n}\n"], "extent": [4734, 4964]}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [4964, 4971], "body": [{"type": "para", "indent": 4, "text": ["Parameters to context functions are dealt with in a special way with\n    VEX. It is possible to override a parameter\u2019s value using a geometry\n    attribute with the same name as the variable. Aside from this\n    special case, parameters should be considered ", {"type": "q", "text": ["const"]}, " within the\n    scope of the shader. This means that it is illegal to modify a\n    parameter value. The compiler will generate errors if this occurs."], "extent": [4971, 5391]}, {"type": "para", "indent": 4, "text": ["You can used the ", {"type": "code", "text": ["export"]}, " keyword to flag parameters you do wish\n    to modify on the original geometry."], "extent": [5391, 5502]}], "container": true}], "container": true, "role": "item_group"}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["User interface pragmas"], "extent": [5502, 5533], "body": [{"type": "para", "indent": 0, "text": ["The user interface generated from this program by Houdini will be minimal, \nbasically just the variable name and a generic text field based on the datatype. \nFor example, you might want to specify that ", {"type": "code", "text": ["frequency"]}, " should be a slider \nwith a certain range, and that ", {"type": "code", "text": ["clr"]}, " should be treated as a color (giving it a \ncolor picker UI). You can do this with ", {"scheme": null, "value": "pragmas", "type": "link", "text": ["user interface compiler pragmas"], "fullpath": "/vex/pragmas"}, "."], "extent": [5533, 5931]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n#pragma opname        noise_surf\n#pragma oplabel        \"Noisy Surface\"\n\n#pragma label    clr            \"Color\"\n#pragma label    frequency    \"Frequency\"\n\n#pragma hint    clr            color\n#pragma range    frequency    0.1 10\n\nsurface noise_surf(vector clr = {1,1,1}; float frequency = 1;\n           export vector nml = {0,0,0})\n{\n    Cf = clr * (float(noise(frequency * P)) + 0.5) * diffuse(normalize(N));\n    nml = normalize(N)*0.5 + 0.5;\n}\n"], "extent": [5931, 6392]}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Operators"], "extent": [6392, 6410], "body": [{"type": "para", "indent": 0, "text": ["VEX has the standard C operators with C precedence, with the following\ndifferences."], "extent": [6410, 6496]}, {"type": "para", "indent": 0, "text": ["Multiplication is defined between two vectors or points. The multiplication performs an element by element multiplication (rather than a dot or cross product; see ", {"scheme": "Vex", "value": "/vex/functions/cross", "type": "link", "text": "", "fallback_text": "cross()", "fullpath": "/vex/functions/cross"}, " and ", {"scheme": "Vex", "value": "/vex/functions/dot", "type": "link", "text": "", "fallback_text": "dot()", "fullpath": "/vex/functions/dot"}, ")."], "extent": [6496, 6688]}, {"type": "para", "indent": 0, "text": ["Many operators are defined for non-scalar data types (i.e. a vector multiplied by a matrix will transform the vector by the matrix)."], "extent": [6688, 6822]}, {"type": "para", "indent": 0, "text": ["In ambiguous situations where you combine two different types with an operator, the result has the type of the second (right hand side) value, for example"], "extent": [6822, 6978]}, {"lang": null, "type": "pre", "indent": 0, "text": ["\nint + vector = vector\n"], "extent": [6978, 7008]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Dot operator"], "extent": [7008, 7030], "body": [{"type": "para", "indent": 0, "text": ["You can use the dot operator (", {"type": "code", "text": ["."]}, ") to reference individual\ncomponents of a vector, matrix or ", {"type": "code", "text": ["struct"]}, "."], "extent": [7030, 7135]}, {"type": "para", "indent": 0, "text": ["For vectors, the component names are fixed."], "extent": [7135, 7180]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "code", "text": [".x"]}, " or ", {"type": "code", "text": [".u"]}, " to reference the first element of ", {"type": "code", "text": ["vector2"]}, "."], "extent": [7180, 7241]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "code", "text": [".x"]}, " or ", {"type": "code", "text": [".r"]}, " to reference the first element of ", {"type": "code", "text": ["vector"]}, " and ", {"type": "code", "text": ["vector4"]}, "."], "extent": [7241, 7315]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "code", "text": [".y"]}, " or ", {"type": "code", "text": [".v"]}, " to reference the second element of ", {"type": "code", "text": ["vector2"]}, "."], "extent": [7315, 7377]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "code", "text": [".y"]}, " or ", {"type": "code", "text": [".g"]}, " to reference the second element of ", {"type": "code", "text": ["vector"]}, " and ", {"type": "code", "text": ["vector4"]}, "."], "extent": [7377, 7452]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "code", "text": [".z"]}, " or ", {"type": "code", "text": [".b"]}, " to reference the third element. of ", {"type": "code", "text": ["vector"]}, " and ", {"type": "code", "text": ["vector4"]}], "extent": [7452, 7526]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "code", "text": [".w"]}, " or ", {"type": "code", "text": [".a"]}, " to reference the fourth element of a ", {"type": "code", "text": ["vector4"]}, "."], "extent": [7526, 7590]}], "container": true}, {"type": "para", "indent": 0, "text": ["The choice\nof the letters u,v/x,y,z/r,g,b is arbitrary; the same letters apply even\nif the vector doesn\u2019t hold a point or color."], "extent": [7590, 7720]}, {"type": "para", "indent": 0, "text": ["For matrices, you can use a pair of letters:"], "extent": [7720, 7766]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "code", "text": [".xx"]}, " to reference the ", {"type": "code", "text": ["[0][0]"]}, " element"], "extent": [7766, 7808]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "code", "text": [".zz"]}, " to reference the ", {"type": "code", "text": ["[2][2]"]}, " element"], "extent": [7808, 7850]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "code", "text": [".ax"]}, " to reference the ", {"type": "code", "text": ["[3][0]"]}, " element"], "extent": [7850, 7893]}], "container": true}, {"type": "para", "indent": 0, "text": ["In addition, the dot operator can be used to ", {"type": "q", "text": ["swizzle"]}, " components of a vector.  For example"], "extent": [7893, 7985]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "code", "text": ["v.zyx"]}, " is equivalent to ", {"type": "code", "text": ["set(v.z, v.y, v.x)"]}], "extent": [7985, 8033]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "code", "text": ["v4.bgab"]}, " is equivalent to ", {"type": "code", "text": ["set(v4.b, v4.g, v4.a, v4.b)"]}], "extent": [8033, 8093]}], "container": true}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [8093, 8099], "body": [{"type": "para", "indent": 4, "text": ["You cannot assign to a swizzled vector, only read from them. So you cannot do ", {"type": "code", "text": ["v.zyx = b"]}, ", but instead must do ", {"type": "code", "text": ["v = b.zyx"]}, "."], "extent": [8099, 8229]}], "container": true}], "container": true, "role": "item_group"}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Comparisons"], "extent": [8229, 8249], "body": [{"type": "para", "indent": 0, "text": ["The comparison operators (==, !=, <, <=, >, >=) are defined when the\nleft hand of the operator is the same type as the right hand side,\nfor string, float and integer types only. The operations result in\ninteger types."], "extent": [8249, 8469]}, {"type": "para", "indent": 0, "text": ["The string matching operator (~=) is only defined when there is a string\non both sides of the operator, and is equivalent to calling the\n", {"scheme": "Vex", "value": "/vex/functions/match", "type": "link", "text": "", "fallback_text": "match()", "fullpath": "/vex/functions/match"}, " function with those two values."], "extent": [8469, 8651]}, {"type": "para", "indent": 0, "text": ["The logical (&&, ||, and !) and bitwise (& |, ^, and ~) operators\nare only defined for integers."], "extent": [8651, 8750]}]}, {"level": 3, "id": "precedence", "container": true, "type": "h", "indent": 0, "text": ["Precedence table"], "extent": [8750, 8788], "body": [{"type": "para", "indent": 0, "text": ["Operators higher in the table have higher precedence."], "extent": [8788, 8844]}, {"type": "table", "thead": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["Order "], "role": "th", "extent": [8844, 8853], "container": true}, {"type": "cell", "indent": 4, "text": ["Operator "], "role": "th", "extent": [8853, 8869], "container": true}, {"type": "cell", "indent": 8, "text": ["Associativity "], "role": "th", "extent": [8869, 8894], "container": true}, {"type": "cell", "indent": 12, "text": ["Description "], "role": "th", "extent": [8894, 8921]}], "divider": false}], "body": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["15 "], "role": "td", "extent": [8921, 8927], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["()"]}, " "], "role": "td", "extent": [8927, 8938], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [8938, 8952], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Function call, expression grouping, structure member."], "extent": [8952, 9018]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["13 "], "role": "td", "extent": [9018, 9023], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["!"]}, " "], "role": "td", "extent": [9023, 9033], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [9033, 9047], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Logical negation"], "extent": [9047, 9076]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["13 "], "role": "td", "extent": [9076, 9081], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["~"]}, " "], "role": "td", "extent": [9081, 9091], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [9091, 9105], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["One\u2019s complement"], "extent": [9105, 9134]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["13 "], "role": "td", "extent": [9134, 9139], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["+"]}, " "], "role": "td", "extent": [9139, 9149], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [9149, 9163], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Unary plus (for example, ", {"type": "code", "text": ["+5"]}, ")"], "extent": [9163, 9207]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["13 "], "role": "td", "extent": [9207, 9212], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["-"]}, " "], "role": "td", "extent": [9212, 9222], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [9222, 9236], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Unary minus (for example, ", {"type": "code", "text": ["-5"]}, ")"], "extent": [9236, 9280]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["13 "], "role": "td", "extent": [9280, 9285], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["++"]}, " "], "role": "td", "extent": [9285, 9296], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [9296, 9310], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Increment (for exmaple, ", {"type": "code", "text": ["x++"]}, ")"], "extent": [9310, 9353]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["13 "], "role": "td", "extent": [9353, 9358], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["--"]}, " "], "role": "td", "extent": [9358, 9369], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [9369, 9383], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Decrememt (for example, ", {"type": "code", "text": ["x--"]}, ")"], "extent": [9383, 9426]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["13 "], "role": "td", "extent": [9426, 9431], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["(", {"type": "var", "text": ["type"]}, ")"]}, " "], "role": "td", "extent": [9431, 9450], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [9450, 9464], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Type cast (for example, ", {"type": "code", "text": ["(int)x"]}, ")."], "extent": [9464, 9511]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["12 "], "role": "td", "extent": [9511, 9516], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["*"]}, " "], "role": "td", "extent": [9516, 9526], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [9526, 9540], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Multiplication"], "extent": [9540, 9567]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["12 "], "role": "td", "extent": [9567, 9572], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["/"]}, " "], "role": "td", "extent": [9572, 9582], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [9582, 9596], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Division"], "extent": [9596, 9617]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["12 "], "role": "td", "extent": [9617, 9622], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["%"]}, " "], "role": "td", "extent": [9622, 9632], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [9632, 9646], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Modulus"], "extent": [9646, 9666]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["11 "], "role": "td", "extent": [9666, 9671], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["+"]}, " "], "role": "td", "extent": [9671, 9681], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [9681, 9695], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Addition"], "extent": [9695, 9716]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["11 "], "role": "td", "extent": [9716, 9721], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["-"]}, " "], "role": "td", "extent": [9721, 9731], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [9731, 9745], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Subtraction"], "extent": [9745, 9769]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["10 "], "role": "td", "extent": [9769, 9774], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["<"]}, " "], "role": "td", "extent": [9774, 9784], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [9784, 9798], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Less-than"], "extent": [9798, 9820]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["10 "], "role": "td", "extent": [9820, 9825], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": [">"]}, " "], "role": "td", "extent": [9825, 9835], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [9835, 9849], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Greater than"], "extent": [9849, 9874]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["10 "], "role": "td", "extent": [9874, 9879], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["<="]}, " "], "role": "td", "extent": [9879, 9890], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [9890, 9904], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Less-than or equal"], "extent": [9904, 9935]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["10 "], "role": "td", "extent": [9935, 9940], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": [">="]}, " "], "role": "td", "extent": [9940, 9951], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [9951, 9965], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Greater than or equal"], "extent": [9965, 9999]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["9 "], "role": "td", "extent": [9999, 10003], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["=="]}, " "], "role": "td", "extent": [10003, 10014], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [10014, 10028], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Equal"], "extent": [10028, 10046]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["9 "], "role": "td", "extent": [10046, 10050], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["!="]}, " "], "role": "td", "extent": [10050, 10061], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [10061, 10075], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["NOT Equal"], "extent": [10075, 10097]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["9 "], "role": "td", "extent": [10097, 10101], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["~="]}, " "], "role": "td", "extent": [10101, 10112], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [10112, 10126], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["String matches"], "extent": [10126, 10153]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["8 "], "role": "td", "extent": [10153, 10157], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["&"]}, " "], "role": "td", "extent": [10157, 10167], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [10167, 10181], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Bitwise AND"], "extent": [10181, 10205]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["7 "], "role": "td", "extent": [10205, 10209], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["^"]}, " "], "role": "td", "extent": [10209, 10219], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [10219, 10233], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Bitwise XOR"], "extent": [10233, 10257]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["6 "], "role": "td", "extent": [10257, 10261], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["|"]}, " "], "role": "td", "extent": [10261, 10271], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [10271, 10285], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Bitwise OR"], "extent": [10285, 10308]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["5 "], "role": "td", "extent": [10308, 10312], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["&&"]}, "  "], "role": "td", "extent": [10312, 10324], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [10324, 10338], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Logical AND"], "extent": [10338, 10362]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["4 "], "role": "td", "extent": [10362, 10366], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["||"]}, " "], "role": "td", "extent": [10366, 10377], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [10377, 10391], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Logical OR"], "extent": [10391, 10414]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["3 "], "role": "td", "extent": [10414, 10418], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["?:"]}, " "], "role": "td", "extent": [10418, 10429], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [10429, 10443], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Ternary conditional (for example, ", {"type": "code", "text": ["x ? \"true\" : \"false\""]}, ")"], "extent": [10443, 10513]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["2 "], "role": "td", "extent": [10513, 10517], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["="]}, " ", {"type": "code", "text": ["+="]}, " ", {"type": "code", "text": ["-="]}, " ", {"type": "code", "text": ["*="]}, " ", {"type": "code", "text": ["/="]}, " ", {"type": "code", "text": ["%="]}, " ", {"type": "code", "text": ["&="]}, " ", {"type": "code", "text": ["|="]}, " ", {"type": "code", "text": ["^="]}, " "], "role": "td", "extent": [10517, 10567], "container": true}, {"type": "cell", "indent": 8, "text": ["RtL "], "role": "td", "extent": [10567, 10581], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Variable assignment"], "extent": [10581, 10613]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["1 "], "role": "td", "extent": [10613, 10617], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": [","]}, " "], "role": "td", "extent": [10617, 10627], "container": true}, {"type": "cell", "indent": 8, "text": ["LtR "], "role": "td", "extent": [10627, 10641], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Argument separator"], "extent": [10641, 10674]}]}], "divider": false}]}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Operator type interactions"], "extent": [10674, 10709], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["When you apply an operation to a ", {"type": "code", "text": ["float"]}, " and an ", {"type": "code", "text": ["int"]}, ", the result is the type to the left of the operator. That is, ", {"type": "code", "text": ["float * int = float"]}, ", while ", {"type": "code", "text": ["int * float = int"]}, "."], "extent": [10709, 10879]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["If you add, multiply, divide, or subtract a vector with a scalar value (", {"type": "code", "text": ["int"]}, " or ", {"type": "code", "text": ["float"]}, "), VEX returns a vector of the same size, with the operation applied component-wise. For example:"], "extent": [10879, 11068], "body": [{"lang": "vex", "type": "pre", "indent": 4, "text": ["\n    {1.0, 2.0, 3.0} * 2.0 == {2.0, 4.0, 6.0}\n    "], "extent": [11068, 11139]}], "container": true}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["If you add, multiply, divide, or subtract vectors of different size, VEX returns a vector of the larger size. The operation is applied component-wise."], "extent": [11139, 11294], "body": [{"type": "para", "indent": 4, "text": [{"type": "strong", "text": ["Important"]}, ": the ", {"type": "q", "text": ["missing"]}, " component(s) on the smaller vector are filled in as ", {"type": "code", "text": ["{0.0, 0.0, 0.0, 1.0}"]}], "extent": [11294, 11401]}, {"lang": "vex", "type": "pre", "indent": 4, "text": ["\n    {1.0, 2.0, 3.0} * {2.0, 3.0, 4.0, 5.0} == {2.0, 6.0, 12.0, 5.0}\n    "], "extent": [11401, 11495]}, {"type": "para", "indent": 4, "text": ["This can give surprising results if you're not expecting it, for example:"], "extent": [11495, 11583]}, {"lang": "vex", "type": "pre", "indent": 4, "text": ["\n    // Third element of the vector2 is treated as 0,\n    // but fourth element is treated as 1.0\n    {1.0, 2.0} + {1.0, 2.0, 3.0, 4.0} == {2.0, 4.0, 3.0, 5.0}\n    "], "extent": [11583, 11768]}, {"type": "para", "indent": 4, "text": ["If you're combining different-sized vectors, you might want to break out the components and operate on them ", {"type": "q", "text": ["manually"]}, " to get the results you want without surprises."], "extent": [11768, 11941]}], "container": true}], "container": true}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Data types"], "extent": [11941, 11958], "body": [{"type": "warning_group", "body": [{"type": "warning", "indent": 0, "role": "item", "extent": [11958, 11968], "body": [{"type": "para", "indent": 4, "text": ["By default, VEX uses 32 bit integers. If you use the ", {"scheme": "Node", "value": "/nodes/sop/attribcast", "type": "link", "text": ["AttribCast SOP"], "fullpath": "/nodes/sop/attribcast"}, " to cast a geometry attribute to 64 bits, VEX will silently discard the extra bits if you manipulate the attribute in VEX code."], "extent": [11968, 12190]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 0, "text": ["The VEX engine runs in either 32bit or 64bit mode.  In 32bit mode, all\nfloats, vectors, and integers are 32bit.  In 64bit mode, they are 64bit.\nThere is no ", {"type": "code", "text": ["double"]}, " or ", {"type": "code", "text": ["long"]}, " type to allow mixed precision math."], "extent": [12190, 12402]}, {"type": "para", "indent": 0, "text": ["You can use underscores to break up long numbers."], "extent": [12402, 12453]}, {"type": "table", "thead": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["Type "], "role": "th", "extent": [12453, 12461], "container": true}, {"type": "cell", "indent": 4, "text": ["Definition "], "role": "th", "extent": [12461, 12479], "container": true}, {"type": "cell", "indent": 8, "text": ["Example "], "role": "th", "extent": [12479, 12498]}], "divider": false}], "body": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["int"]}, " "], "role": "td", "extent": [12498, 12506], "container": true}, {"type": "cell", "indent": 4, "text": ["Integer values "], "role": "td", "extent": [12506, 12527], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": [{"type": "code", "text": ["21, -3, 0x31, 0b1001, 0212, 1_000_000"]}], "extent": [12527, 12575]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["float"]}, " "], "role": "td", "extent": [12575, 12585], "container": true}, {"type": "cell", "indent": 4, "text": ["Floating point scalar values "], "role": "td", "extent": [12585, 12620], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": [{"type": "code", "text": ["21.3, -3.2, 1.0, 0.000_000_1"]}], "extent": [12620, 12659]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["vector2"]}, " "], "role": "td", "extent": [12659, 12671], "container": true}, {"type": "cell", "indent": 4, "text": ["Two floating point values. You might use this to represent texture coordinates (though usually Houdini uses vectors) or complex numbers "], "role": "td", "extent": [12671, 12813], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": [{"type": "code", "text": ["{0,0}, {0.3,0.5}"]}], "extent": [12813, 12840]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["vector"]}, " "], "role": "td", "extent": [12840, 12851], "container": true}, {"type": "cell", "indent": 4, "text": ["Three floating point values. You can use this to represent positions, directions, normals or colors (RGB or HSV) "], "role": "td", "extent": [12851, 12970], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": [{"type": "code", "text": ["{0,0,0}, {0.3,0.5,-0.5}"]}], "extent": [12970, 13004]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["vector4"]}, " "], "role": "td", "extent": [13004, 13016], "container": true}, {"type": "cell", "indent": 4, "text": ["Four floating point values. You can use this to represent positions in homogeneous coordinates, or color with alpha (RGBA). It is often used to represent a quaternion. Quaternions in VEX are laid out in ", {"type": "code", "text": ["x/y/z/w"]}, " order, not ", {"type": "code", "text": ["w/x/y/z"]}, ". This applies both to both quaternions and positions with homogeneous coordinates. "], "role": "td", "extent": [13016, 13339], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": [{"type": "code", "text": ["{0,0,0,1}, {0.3,0.5,-0.5,0.2}"]}], "extent": [13339, 13379]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["array"]}, " "], "role": "td", "extent": [13379, 13389], "container": true}, {"type": "cell", "indent": 4, "text": ["A list of values. See ", {"scheme": null, "value": "arrays", "type": "link", "text": ["arrays"], "fullpath": "/vex/arrays"}, " for more information. "], "role": "td", "extent": [13389, 13455], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": [{"type": "code", "text": ["{ 1, 2, 3, 4, 5, 6, 7, 8 }"]}], "extent": [13455, 13492]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["struct"]}, " "], "role": "td", "extent": [13492, 13503], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["A fixed set of named values. See ", {"scheme": null, "value": "#structs", "type": "link", "text": ["structs"], "fullpath": "/vex/lang#structs", "fragment": "#structs"}, " for more information."], "extent": [13503, 13581]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["matrix2"]}, " "], "role": "td", "extent": [13581, 13593], "container": true}, {"type": "cell", "indent": 4, "text": ["Four floating point values representing a 2D rotation matrix  "], "role": "td", "extent": [13593, 13661], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": [{"type": "code", "text": ["{ {1,0}, {0,1} }"]}], "extent": [13661, 13688]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["matrix3"]}, " "], "role": "td", "extent": [13688, 13700], "container": true}, {"type": "cell", "indent": 4, "text": ["Nine floating point values representing a 3D rotation matrix or a 2D transformation matrix "], "role": "td", "extent": [13700, 13797], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": [{"type": "code", "text": ["{ {1,0,0}, {0,1,0}, {0,0,1} }"]}], "extent": [13797, 13837]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["matrix"]}, " "], "role": "td", "extent": [13837, 13848], "container": true}, {"type": "cell", "indent": 4, "text": ["Sixteen floating point values representing a 3D transformation matrix "], "role": "td", "extent": [13848, 13924], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": [{"type": "code", "text": ["{ {1,0,0,0}, {0,1,0,0}, {0,0,1,0}, {0,0,0,1} }"]}], "extent": [13924, 13981]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["string"]}, " "], "role": "td", "extent": [13981, 13992], "container": true}, {"type": "cell", "indent": 4, "text": ["A string of characters.  See ", {"scheme": null, "value": "strings", "type": "link", "text": ["strings"], "fullpath": "/vex/strings"}, " for more information. "], "role": "td", "extent": [13992, 14067], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": [{"type": "code", "text": ["\"hello world\""]}], "extent": [14067, 14091]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["dict"]}, " "], "role": "td", "extent": [14091, 14100], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["A dictionary mapping ", {"type": "code", "text": ["string"]}, "s to other VEX data types.  See ", {"scheme": null, "value": "dicts", "type": "link", "text": ["dicts"], "fullpath": "/vex/dicts"}, " for more information."], "extent": [14100, 14201]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["bsdf"]}, " "], "role": "td", "extent": [14201, 14210], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["A ", {"type": "em", "text": ["bidirectional scattering distribution function"]}, ". See ", {"scheme": null, "value": "pbr", "type": "link", "text": ["writing PBR shaders"], "fullpath": "/vex/pbr"}, " for information on BSDFs."], "extent": [14210, 14324]}]}], "divider": false}]}]}, {"level": 2, "id": "structs", "container": true, "type": "h", "indent": 0, "text": ["Structs"], "extent": [14324, 14348], "body": [{"type": "para", "indent": 0, "text": ["As of Houdini 12, you can define new structured types using the ", {"type": "code", "text": ["struct"]}, " keyword."], "extent": [14348, 14432]}, {"type": "para", "indent": 0, "text": ["Member data can be assigned default values in the struct definition similar to C++11 member initialization."], "extent": [14432, 14541]}, {"type": "para", "indent": 0, "text": ["Two implicit constructor functions are created for each struct.  The first takes initialization arguments in the order they are declared in the struct, the second takes no arguments but sets all members to their default values."], "extent": [14541, 14770]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n\n#include <math.h> \n\nstruct basis { \n    vector i, j, k; \n} \n\nstruct bases { \n    basis m, n, o; \n    string description; \n} \n\nstruct values {\n    int uninitialized;        // Uninitialized member data\n    int        ival = 3;\n    float fval = 3.14;\n    float aval[] = { 1, 2, 3, 4.5 };\n}\n\nbasis rotate(basis b; vector axis; float amount) { \n    matrix m = 1; \n    rotate(m, amount, axis); \n    basis result = b; \n    result.i *= m; \n    result.j *= m; \n    result.k *= m; \n    return result; \n}\n\n// Declare struct variables\nbasis b0;        // Initialize using default values (i.e. 0 in this case)\nbasis b1 = basis({1,0,0}, {0,1,0}, {0,0,1});        // Initialize using constructor\nbasis b2 = { {1,0,0}, {0,1,0}, {0,0,1} };         // Initialize as explicit struct\nb1 = rotate(b1, {0,0,1}, M_PI/6);\n"], "extent": [14770, 15584]}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [15584, 15591], "body": [{"type": "para", "indent": 8, "text": ["You must define structs before using them in the source file."], "extent": [15591, 15663]}], "container": true}], "container": true, "role": "item_group"}, {"level": 3, "id": "methods", "container": true, "type": "h", "indent": 0, "text": ["Struct functions"], "extent": [15663, 15698], "body": [{"type": "para", "indent": 0, "text": ["You can define functions inside structs to organize your code and\nallow a limited form of object-oriented programming."], "extent": [15698, 15819]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["Inside a struct function, you can use ", {"type": "code", "text": ["this"]}, " to refer to the struct instance."], "extent": [15819, 15900]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Inside a struct function, you can refer to struct fields by name as if they were variables\n  (for example, ", {"type": "code", "text": ["basis"]}, " is a shortcut for ", {"type": "code", "text": ["this.basis"]}, ")."], "extent": [15900, 16051]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You can call struct functions on a struct instance using the ", {"type": "code", "text": ["->"]}, " arrow operator,\n  for example ", {"type": "code", "text": ["sampler->sample()"]}, ".\n  Note inside a struct function that you can call other methods on the struct using ", {"type": "code", "text": ["this->method()"]}, "."], "extent": [16051, 16273]}], "container": true}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n\nstruct randsampler {\n    // Fields\n    int        seed;\n\n    // Methods\n    float sample()\n    {\n        // Struct functions can refer to fields by name\n        return random(seed++);\n    }\n} \n\ncvex shader()\n{\n    randsampler sampler = randsampler(11);\n    for (int i = 0; i < 10; i++)\n    {\n        // Use -> to call methods on struct instances\n        printf(\"%f\\n\", sampler->sample());\n    }\n}\n"], "extent": [16273, 16685]}]}]}, {"level": 2, "id": "mantratypes", "container": true, "type": "h", "indent": 0, "text": ["Mantra Specific Types"], "extent": [16685, 16729], "body": [{"type": "para", "indent": 0, "text": ["Mantra has some pre-defined struct types that are used in shading-specific functions."], "extent": [16729, 16817]}, {"type": "table", "thead": [], "body": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["light"]}, " "], "role": "td", "extent": [16817, 16827], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Defined in mantra shading contexts only.  This is a struct representing a\n    handle to a light source.  The struct has methods:"], "extent": [16827, 16961]}, {"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["illuminate(\u2026)\n    Invokes the VEX surface shader bound to the ", {"type": "code", "text": ["vm_illumshader"]}, " property of\n    the light source."], "extent": [16961, 17083]}], "container": true}, {"type": "para", "indent": 4, "text": ["In an IFD, you may see lines like ", {"type": "code", "text": ["ray_property light illumshader diffuselighting"]}, "\n    or ", {"type": "code", "text": ["ray_property light illumshader mislighting misbias 1.000000"]}, "."], "extent": [17083, 17241]}, {"type": "para", "indent": 4, "text": ["These statements define the shader invoked when the ", {"type": "code", "text": ["illuminate()"]}, " method\n    is called on a light object."], "extent": [17241, 17353]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["material"]}, " "], "role": "td", "extent": [17353, 17366], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Defined in mantra shading contexts only.  This is opaque struct\n    representing the material assigned to an object."], "extent": [17366, 17488]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["lpeaccumulator"]}, " "], "role": "td", "extent": [17488, 17507], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Defined in mantra shading contexts only.  This is a struct representing an\n    accumulator for Light Path Expressions.  The struct has methods:"], "extent": [17507, 17656]}, {"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["begin() - Construct and initialize accumulator."], "extent": [17656, 17710]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["end() - Finalize and destroy."], "extent": [17710, 17746]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["move(string eventtype; string scattertype; string tag, string bsdflabel) - Modifies internal state based on current event. If an empty string is\n    passed in, it\u2019s assumed to be 'any'."], "extent": [17746, 17938]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["pushstate() - Push internal state onto stack."], "extent": [17938, 17990]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["popstate() - Pop internal state from stack. Used to pushstate() to ", {"type": "q", "text": ["undo"]}, " move()."], "extent": [17990, 18078]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["int matches() - Returns non-zero if the current internal state matches any of the light\n    path expressions defined by user."], "extent": [18078, 18210]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["accum(vector color, \u2026) - Accumulates input color onto intermediate buffer. Also takes in optional prefix strings to be compared against prefixes that were declared with LPE image plane. All prefixes must match in order to accumulate."], "extent": [18210, 18452]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["flush(vector multiplier) - Multiply the intermediate buffer by the multiplier and add it onto image planes. The intermediate buffer exists to allow for variance anti-aliasing (i.e. the multiplier would be 1/number_of_samples)."], "extent": [18452, 18685]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["int getid() - Returns an integer id assigned to lpeaccumulator."], "extent": [18685, 18755]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["lpeaccumulator getlpeaccumulator(int id) - Returns lpeaccumulator based on id. Used with getid() to pass lpeaccumulator across shader boundaries."], "extent": [18755, 18908]}], "container": true}]}], "divider": false}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Type casting"], "extent": [18908, 18927], "body": [{"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Variable casting"], "extent": [18927, 18953], "body": [{"type": "para", "indent": 0, "text": ["This is similar to type casting in C++ or Java: you transform a\nvalue of one type into another (for example, an int into a float)."], "extent": [18953, 19086]}, {"type": "para", "indent": 0, "text": ["This is sometimes necessary, as when you have the following:"], "extent": [19086, 19148]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\nint a, b;\nfloat c;\nc = a / b;\n"], "extent": [19148, 19192]}, {"type": "para", "indent": 0, "text": ["In this example, the compiler will do integer division (see  ", {"scheme": null, "value": "#typeres", "type": "link", "text": ["type\nresolution"], "fullpath": "/vex/lang#typeres", "fragment": "#typeres"}, " ). If you wanted to do floating\npoint division instead, you need to explicitly cast ", {"type": "code", "text": ["a"]}, " and ", {"type": "code", "text": ["b"]}, " as\nfloats:"], "extent": [19192, 19389]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\nint a, b;\nfloat c;\nc = (float)a / (float)b;\n"], "extent": [19389, 19447]}, {"type": "para", "indent": 0, "text": ["This generates additional instructions to perform the casts. This\nmay be an issue in performance-sensitive sections of your code."], "extent": [19447, 19580]}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Function casting"], "extent": [19580, 19605], "body": [{"type": "para", "indent": 0, "text": ["VEX dispatches functions based not only on the types of the\narguments (like C++ or Java), but also on the return type. To\ndisambiguate calls to functions with the same argument types but\ndifferent return types, you can ", {"type": "em", "text": ["cast the function"]}, "."], "extent": [19605, 19847]}, {"type": "para", "indent": 0, "text": ["For example, the ", {"scheme": "Vex", "value": "/vex/functions/noise", "type": "link", "text": ["noise"], "fallback_text": "noise()", "fullpath": "/vex/functions/noise"}, " function can take different\nparameter types, but can also return different types: ", {"type": "code", "text": ["noise"]}, " can\nreturn either a float or vector."], "extent": [19847, 20010]}, {"type": "para", "indent": 0, "text": ["In the code:"], "extent": [20010, 20024]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\nfloat n;\nn = noise(noise(P));\n"], "extent": [20024, 20068]}, {"type": "para", "indent": 0, "text": ["\u2026VEX could dispatch to either ", {"type": "code", "text": ["float noise(vector)"]}, " or\n", {"type": "code", "text": ["vector noise(vector)"]}, "."], "extent": [20068, 20151]}, {"type": "para", "indent": 0, "text": ["To cast a function call, surround it with ", {"type": "code", "text": [{"type": "var", "text": ["typename"]}, "( ... )"]}, ", as\nin:"], "extent": [20151, 20224]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\nn = noise( vector( noise(P) ) );\n"], "extent": [20224, 20271]}, {"type": "para", "indent": 0, "text": ["While this looks like a function call, it does nothing but disambiguate the\nfunction call inside and has no performance overhead."], "extent": [20271, 20403]}, {"type": "para", "indent": 0, "text": ["Function casting is implied when you assign a function call directly to a\nvariable of a specified type.  So the following expressions are equivalent,\nand the function cast may be omitted for more concise code:"], "extent": [20403, 20614]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\nvector n = vector( noise(P) );        // Unnecessary function cast\nvector n = noise(P);\n"], "extent": [20614, 20716]}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [20716, 20723], "body": [{"type": "para", "indent": 4, "text": ["If VEX is unable to determine which signature of a function you are\n    trying to call, it will trigger an ambiguity error and print out the\n    candidate functions.  You should then choose the appropriate return\n    value and add a function cast to select it."], "extent": [20723, 20989]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 0, "text": ["Since function casting does not generate any type conversions (it simply\nchooses a function to call), there is no performance penalty to using it.\nA good rule of thumb is to use function casting wherever possible and to\nuse variable casting only when an explicit type conversion is required."], "extent": [20989, 21283]}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Comments"], "extent": [21283, 21298], "body": [{"type": "para", "indent": 0, "text": ["VEX uses C++ style comments:"], "extent": [21298, 21329]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["One-line comments are preceded by ", {"type": "code", "text": ["//"]}], "extent": [21329, 21371]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Freeform comments begin with ", {"type": "code", "text": ["/*"]}, " and end with ", {"type": "code", "text": ["*/"]}], "extent": [21371, 21426]}], "container": true}]}, {"level": 2, "id": "reserved", "container": true, "type": "h", "indent": 0, "text": ["Reserved Keywords"], "extent": [21426, 21461], "body": [{"type": "para", "indent": 0, "text": [{"type": "code", "text": ["break"]}, ", ", {"type": "code", "text": ["bsdf"]}, ", ", {"type": "code", "text": ["char"]}, ", ", {"type": "code", "text": ["color"]}, ", ", {"type": "code", "text": ["const"]}, ", ", {"type": "code", "text": ["continue"]}, ", ", {"type": "code", "text": ["do"]}, ", ", {"type": "code", "text": ["dict"]}, ", ", {"type": "code", "text": ["else"]}, ",\n", {"type": "code", "text": ["export"]}, ", ", {"type": "code", "text": ["false"]}, ", ", {"type": "code", "text": ["float"]}, ", ", {"type": "code", "text": ["for"]}, ", ", {"type": "code", "text": ["forpoints"]}, ", ", {"type": "code", "text": ["foreach"]}, ", ", {"type": "code", "text": ["gather"]}, ",\n", {"type": "code", "text": ["hpoint"]}, ", ", {"type": "code", "text": ["if"]}, ", ", {"type": "code", "text": ["illuminance"]}, ", ", {"type": "code", "text": ["import"]}, ", ", {"type": "code", "text": ["int"]}, ", ", {"type": "code", "text": ["integer"]}, ", ", {"type": "code", "text": ["matrix"]}, ",\n", {"type": "code", "text": ["matrix2"]}, ", ", {"type": "code", "text": ["matrix3"]}, ", ", {"type": "code", "text": ["normal"]}, ", ", {"type": "code", "text": ["point"]}, ", ", {"type": "code", "text": ["return"]}, ", ", {"type": "code", "text": ["string"]}, ", ", {"type": "code", "text": ["struct"]}, ", ", {"type": "code", "text": ["true"]}, ",\n", {"type": "code", "text": ["typedef"]}, ", ", {"type": "code", "text": ["union"]}, ", ", {"type": "code", "text": ["vector"]}, ", ", {"type": "code", "text": ["vector2"]}, ", ", {"type": "code", "text": ["vector4"]}, ", ", {"type": "code", "text": ["void"]}, ", ", {"type": "code", "text": ["while"]}], "extent": [21461, 21824]}]}], "title": ["VEX language reference"], "summary": ["Details of VEX syntax, data types, and so on."]}